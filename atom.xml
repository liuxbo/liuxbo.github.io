<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liuxbo.github.io</id>
    <title>lxb&apos;blog</title>
    <updated>2020-06-08T15:57:44.424Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liuxbo.github.io"/>
    <link rel="self" href="https://liuxbo.github.io/atom.xml"/>
    <subtitle>èœé¸¡æˆé•¿ä¹‹è·¯</subtitle>
    <logo>https://liuxbo.github.io/images/avatar.png</logo>
    <icon>https://liuxbo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, lxb&apos;blog</rights>
    <entry>
        <title type="html"><![CDATA[PATé¢˜å‹æ€»ç»“]]></title>
        <id>https://liuxbo.github.io/post/pat-ti-xing-zong-jie/</id>
        <link href="https://liuxbo.github.io/post/pat-ti-xing-zong-jie/">
        </link>
        <updated>2020-05-15T01:27:45.000Z</updated>
        <content type="html"><![CDATA[<p>ä¹¦ä¸Šåšæ ‡è®°   äºŒåˆ·æ–‡ä»¶åšæ ‡è®°å¹¶åŠ é»‘é‡è¦çš„é¢˜   æ›´æ–°PATé¢˜è§£</p>
<h3 id="1æ¨¡æ‹Ÿ">1.æ¨¡æ‹Ÿ</h3>
<p>1042(æ´—ç‰Œå™¨)</p>
<p>1046(æœ€çŸ­è·¯å¾„)</p>
<p>1002(å¤šé¡¹å¼ç›¸åŠ )</p>
<p>1009(å¤šé¡¹å¼ç›¸ä¹˜)</p>
<h3 id="2æ°´é¢˜-é€»è¾‘é¢˜">2.æ°´é¢˜ã€é€»è¾‘é¢˜</h3>
<p>1006</p>
<p>1036</p>
<p>1093(25 é€»è¾‘é¢˜)</p>
<p>1101(25 é€»è¾‘é¢˜)</p>
<h3 id="3æ•°å­—-æ•°å­¦é—®é¢˜">3.æ•°å­—ã€æ•°å­¦é—®é¢˜</h3>
<p>1019(åˆ¤æ–­å›æ–‡ä¸² åè¿›åˆ¶è½¬åŒ–ä¸ºå…¶ä»–è¿›åˆ¶)</p>
<p>1027(20 è¿›åˆ¶è½¬æ¢)</p>
<p>1058(20 æ°´é¢˜)</p>
<h3 id="4å­—ç¬¦ä¸²é—®é¢˜">4.å­—ç¬¦ä¸²é—®é¢˜</h3>
<p>1061(20 ä¸€å¯¹å­—ç¬¦ä¸²ç›¸åŒçš„å…ƒç´ )</p>
<p><strong>1073(20 ç§‘å­¦è®¡æ•°æ³•)</strong></p>
<p><strong>1060(25 å­—ç¬¦ä¸² ç§‘å­¦è®¡æ•°æ³•)</strong></p>
<p>1001(20 ä¸¤æ•°ç›¸åŠ )</p>
<p>1005(20 å­—ç¬¦ä¸²)</p>
<p>1035(20 å­—ç¬¦ä¸²)</p>
<p><strong>1077(20  å¤šä¸ªå­—ç¬¦ä¸²æ‰¾å…¬å…±åç¼€)</strong></p>
<p><strong>1082(25 åˆ†æ®µå¤„ç†å­—ç¬¦ä¸²)</strong></p>
<p>1084(20 å­—ç¬¦ä¸²)</p>
<p>1071(25 map  å­—ç¬¦ä¸²)</p>
<h3 id="5æ’åº">5.æ’åº</h3>
<p>1062(25 æŒ‰æ¡ä»¶æ’åº)</p>
<p><strong>1012(25 æ¡ä»¶æ’åº)</strong></p>
<p><strong>1016(25 æ’åº å¤„ç†å¤šæ¡é€šè¯æ—¶é—´è®°å½•)</strong></p>
<p>1025(25 æ¡ä»¶æ’åº)</p>
<p>1028(25  æ’åº)</p>
<p><strong>1055(25 æŒ‰æ¡ä»¶æŸ¥æ‰¾å¹¶æ’åºè¾“å‡º)</strong></p>
<p><strong>1075(25 æ’åº)</strong></p>
<p>1083(25 æ’åº)</p>
<p><strong>1080(30 æ’åº  æŒ‰æ’åä¾æ¬¡å½•å–æŠ¥è€ƒå¿—æ„¿)</strong></p>
<p><strong>1095(30 æ ¡å›­åœè½¦ æ’åº  ä¸¤è¾†é…å¯¹  æ—¶é—´æŸ¥è¯¢è¾“å‡º)</strong></p>
<p><strong>1089  (25 æ’å…¥æ’åºå’Œå½’å¹¶æ’åº)</strong></p>
<h3 id="6hash">6.<code>hash</code></h3>
<p>1092(20 å­—ç¬¦ä¸² hash)</p>
<p>1041(20 hash)</p>
<p>1050(20 hash)</p>
<p><strong>1048(25 hash æ‰¾å‡ºä¸¤ä¸ªæ•°çš„å’Œä¸ºæŒ‡å®šçš„æ•°)</strong></p>
<h3 id="7è´ªå¿ƒ">7.è´ªå¿ƒ</h3>
<p>1070(25 è´ªå¿ƒ)</p>
<p>1037(25 è´ªå¿ƒ)</p>
<p><strong>1067(25  è´ªå¿ƒ swapæ’åºï¼Œæ±‚æœ€å°äº¤æ¢æ¬¡æ•°)</strong></p>
<p><strong>1038(30 è´ªå¿ƒ  æ±‚æœ€å°å­—ç¬¦ä¸²åºåˆ—)</strong></p>
<h3 id="8äºŒåˆ†-twopoints">8.äºŒåˆ† ã€<code>twopoints</code></h3>
<p><strong>1085(25 äºŒåˆ† twopoints å¤šè§£æ³•)</strong></p>
<p><strong>1010(25 äºŒåˆ†)</strong></p>
<p><strong>1044(25 äºŒåˆ†)</strong></p>
<p><strong>1029(25 æ±‚ä¸­ä½æ•° twopoints)</strong></p>
<h3 id="9stl">9.<code>STL</code></h3>
<p><strong>1039(25 vector  hash)</strong></p>
<p>1047(25 vector)</p>
<p><strong>1063(25 set)</strong>    æ³¨æ„findçš„ç”¨æ³•</p>
<p>1054(20 map)</p>
<p>1100(20 å­—ç¬¦ä¸² string map)</p>
<h3 id="10æ ˆ-é˜Ÿåˆ—-é“¾è¡¨">10.æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨</h3>
<p><strong>1051(25 æ ˆ)</strong></p>
<p><strong>1056(25 queueé˜Ÿåˆ—)</strong></p>
<p>1074(25 åè½¬é“¾è¡¨)</p>
<p>1032(25 é“¾è¡¨  æ‰¾å…¬å…±åç¼€)</p>
<p><strong>1052(25 é“¾è¡¨æŒ‰keyæ’åº)</strong>   æ³¨æ„æ”¹é¢˜ç‰¹åˆ¤é“¾è¡¨é•¿åº¦ä¸º0çš„æƒ…å†µï¼Œå¦åˆ™é€ æˆæ®µé”™è¯¯</p>
<p><strong>1097(25 é“¾è¡¨åˆ†ç¦»)</strong>   æ³¨æ„ç‰¹åˆ¤ç§»å‡ºçš„é“¾è¡¨é•¿åº¦ä¸º0ï¼Œå¦åˆ™é€ æˆæ®µé”™è¯¯</p>
<h3 id="11dfs-bfs">11.DFSã€BFS</h3>
<p><strong>1103(30 DFS åˆ†è§£å› å¼)</strong>   ç»å…¸DFSï¼Œå¿…çœ‹</p>
<p><strong>1091(30 ç»å…¸BFSæ±‚çŸ©é˜µä¸­å—çš„ä¸ªæ•°)</strong>   å¿…çœ‹</p>
<h3 id="12æ ‘">12.æ ‘</h3>
<ul>
<li>
<p>æ™®é€šæ ‘</p>
<p>1020(25 ååº+ä¸­åºå»ºæ ‘ï¼Œè¾“å‡ºå±‚åº)</p>
<p><strong>1086(25 æ ˆæ¨¡æ‹Ÿä¸­åºå’Œå…ˆåºå»ºæ ‘ï¼Œè¾“å‡ºååº)</strong></p>
<p>1102(25 äºŒå‰æ ‘åè½¬)</p>
<p>1090(25 æ ‘çš„dfsæ±‚æ·±åº¦)</p>
<p>1079(25 æ ‘çš„dfs)</p>
<p>1094(25 æ ‘çš„dfs)</p>
<p>1106(25 æ ‘çš„dfs)</p>
<p>**1053(30 è¾“å‡ºæƒå€¼æ€»å’ŒåŒä¸ºç»™å®šå€¼çš„è·¯å¾„(dfs)) ** å¿…çœ‹</p>
</li>
<li>
<p>å®Œå…¨äºŒå‰æ ‘</p>
<p><strong>1064(30 å®Œå…¨äºŒå‰æ ‘(ä¸­åºéå†å»ºæ ‘))</strong></p>
</li>
<li>
<p>äºŒå‰æœç´¢æ ‘</p>
<p><strong>1043(25 äºŒå‰æœç´¢æ ‘çš„éå†ä¸åè½¬)</strong></p>
<p><strong>1099(30 ä¸­åºéå†å»ºç«‹äºŒå‰æœç´¢æ ‘)</strong></p>
</li>
<li>
<p>å¹³è¡¡äºŒå‰æ ‘</p>
<p><strong>1066(25 å»ºç«‹å¹³è¡¡äºŒå‰æ ‘)</strong>  èƒŒèƒŒæ¨¡æ¿</p>
</li>
</ul>
<h3 id="13å¹¶æŸ¥é›†">13.å¹¶æŸ¥é›†</h3>
<p><strong>1107(30 ç»å…¸å¹¶æŸ¥é›†)</strong>  å¿…çœ‹</p>
<h3 id="14å †">14.å †</h3>
<p><strong>1098(25 åˆ¤æ–­æ’å…¥æ’åºå’Œå †æ’åº)</strong></p>
<h3 id="15å›¾">15.å›¾</h3>
<p>1013(25 å›¾çš„dfséå†ï¼Œè®¡ç®—è¿é€šå—ä¸ªæ•°)</p>
<p><strong>1021(25 æ‰¾å‡ºå›¾ä¸­ä½¿æ·±åº¦æœ€æ·±çš„ç»“ç‚¹(é¦–å…ˆåˆ¤æ–­æ˜¯å¦èƒ½çœ‹æˆæ ‘))</strong>  å¿…çœ‹ï¼Œç»“è®º</p>
<h3 id="å•è¯">å•è¯</h3>
<p>coefficients ç³»æ•°</p>
<p>Palindromic å›æ–‡çš„</p>
<p>suffix åç¼€</p>
<p>simultaneously åŒæ—¶åœ°</p>
<p>simulate æ¨¡ä»¿</p>
<p>plate  ç¢Ÿï¼›é‡‘å±æ¿ï¼›é‡‘å±ç‰Œï¼›æ„Ÿå…‰åº•ç‰‡</p>
<p>ascending ä¸Šå‡çš„</p>
<p>permutation æ’åˆ—</p>
<p>deduplication å»é‡</p>
<p>recursive é€’å½’çš„ï¼Œå¾ªç¯çš„</p>
<p>cluster ç¾¤</p>
<p>repetition é‡å¤ï¼ŒèƒŒè¯µ</p>
<p>acyclic éå¾ªç¯çš„ï¼Œéå‘¨æœŸçš„</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°å­¦é—®é¢˜]]></title>
        <id>https://liuxbo.github.io/post/shu-xue-wen-ti/</id>
        <link href="https://liuxbo.github.io/post/shu-xue-wen-ti/">
        </link>
        <updated>2020-05-07T13:15:56.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>æ±‚æœ€å¤§å…¬çº¦æ•°,(æœ€å°å…¬å€æ•°ï¼šaå’Œbçš„æœ€å¤§å…¬çº¦æ•°ä¸ºdï¼Œåˆ™aå’Œbçš„æœ€å°å…¬å€æ•°ä¸ºab/d)</p>
<pre><code>long long gcd(long long a, long long b) {
     return b == 0 ? abs(a) : gcd(b, a %b);
 }
</code></pre>
</li>
<li>
<p>åˆ†æ•°åŒ–ç®€</p>
<pre><code>struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
</code></pre>
</li>
<li>
<p>å››åˆ™è¿ç®—</p>
<pre><code>fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
</code></pre>
</li>
<li>
<p>åˆ†æ•°è¾“å‡º</p>
<pre><code>void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
</code></pre>
</li>
<li>
<p>åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°</p>
<pre><code>bool isprime(int n) {
	if (n &lt;= 1) return false;
    int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}

</code></pre>
</li>
<li>
<p>å»ºç«‹ç´ æ•°è¡¨</p>
<pre><code>
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
</code></pre>
</li>
<li>
<p>å¤§æ•´æ•°è¿ç®—</p>
<pre><code>struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++åˆ·é¢˜å¸¸ç”¨å‡½æ•°]]></title>
        <id>https://liuxbo.github.io/post/cshua-ti-chang-yong-han-shu/</id>
        <link href="https://liuxbo.github.io/post/cshua-ti-chang-yong-han-shu/">
        </link>
        <updated>2020-05-07T13:13:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><code>math.h</code>å¤´æ–‡ä»¶å‡½æ•°</p>
<p><code>fabs(double x)</code>  å–ç»å¯¹å€¼ ï¼Œ</p>
<p><code>floor(double x)</code>å’Œ<code>ceil(double x)</code> ï¼Œåˆ†åˆ«ä¸ºå‘ä¸Šå–æ•´å’Œå‘ä¸‹å–æ•´ï¼Œè¿”å›doubleå‹</p>
<p><code>pow(double r,double p)</code> ç”¨äºè¿”å›r^p</p>
<p><code>sqrt(double x)</code> ,è¿”å›ç®—æ•°å¹³æ–¹æ ¹</p>
<p><code>log(double x)</code> ,è¿”å›ä»¥è‡ªç„¶å¯¹æ•°ä¸ºåº•çš„å¯¹æ•°ï¼Œç”¨æ¢åº•å…¬å¼æ±‚å…·ä½“å¯¹æ•°</p>
<p><code>sin(double x)</code> <code>cos(double x)</code> <code>tan(double x)</code></p>
<p><code>asin(double x)</code> <code>acos(double x)</code> <code>atan(double x)</code></p>
<p><code>round(double x)</code> å°†xå››èˆäº”å…¥ï¼Œè¿”å›ä¸ºdoubleå‹</p>
</li>
<li>
<p><code>algorithm</code>å¤´æ–‡ä»¶ä¸‹çš„å‡½æ•°ï¼ŒåŠ <code>using namespace std;</code></p>
<p><code>max(x,y)</code> <code>min(x,y)</code>  <code>abs(x)</code> è¿”å›xçš„ç»å¯¹å€¼ï¼Œxå¿…é¡»ä¸ºæ•´æ•°</p>
<p><code>swap(x,y)</code></p>
<p><code>reverse(it,it2)</code> <code>reverse(a,a+4)</code>  ,å°†æ•°ç»„å…ƒç´ åè½¬</p>
<p><code>next_permutation(a,a+...)</code> ,ç»™å‡ºä¸€ä¸ªåºåˆ—åœ¨å…¨æ’åˆ—ä¸­çš„ä¸‹ä¸€ä¸ªåºåˆ—ï¼Œè¯¥å‡½æ•°åœ¨åˆ°è¾¾å…¨æ’åˆ—çš„æœ€åä¸€ä¸ªæ—¶ä¼šè¿”å›false</p>
<p><code>fill(a,a+4,233)</code> ,èµ‹ç›¸åŒå€¼ï¼Œå¯¹äº<code>G[maxn] [maxn]</code>äºŒç»´æ•°ç»„<code>fill(G[0],G[0]+maxn*maxn,INF);</code></p>
<p><code>sort(é¦–å…ƒç´ åœ°å€ï¼Œå°¾å…ƒç´ åœ°å€çš„ä¸‹ä¸€ä¸ªåœ°å€ï¼Œæ¯”è¾ƒå‡½æ•°ï¼ˆéå¿…å¡«)ï¼‰</code>,æ— æ¯”è¾ƒå‡½æ•°ï¼Œé»˜è®¤é€’å¢æ’åºã€‚</p>
<p><code>sort(a, a+n, greater());</code>  ä»å¤§åˆ°å°æ’åº(è¦ç”¨<code>iostream</code>å¤´æ–‡ä»¶)</p>
<p><code>lower_bound(first,last,val)</code>  <code>upper_bound(first,last,val)</code> ,ç”¨äºæœ‰åºæ•°ç»„æˆ–å®¹å™¨ï¼Œå‰è€…ç”¨æ¥å¯»æ‰¾[first,last)èŒƒå›´å†…ç¬¬ä¸€ä¸ªå€¼å¤§äºç­‰äºvalçš„å…ƒç´ çš„ä½ç½®ï¼Œåè€…å¯»æ‰¾ç¬¬ä¸€ä¸ªå€¼å¤§äºvalçš„å…ƒç´ ä½ç½®.è‹¥æ˜¯æ•°ç»„ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°è¿”å›çš„æ˜¯åœ°å€ï¼Œå¦‚<code>int* right=upper_bound(num, num+n, k)</code>ï¼Œè¿”å›numæ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºkçš„å…ƒç´ æ‰€åœ¨åœ°å€ï¼Œå…¶ä¸‹æ ‡=<code>right-num</code></p>
<p><code>max_element(a, a+len)</code>è¿”å›åºåˆ—ä¸­æœ€å¤§å…ƒç´ åœ°å€ï¼ˆè¿­ä»£å™¨ï¼‰,å¯ç”¨å…¶å‡å»æ•°ç»„é¦–åœ°å€(å³æ•°ç»„å)è·å–å…¶ä¸‹æ ‡,è‹¥è¦è·å–è¯¥å…ƒç´ å€¼ï¼Œç›´æ¥åœ¨å‰é¢åŠ ä¸€ä¸ª*,è¡¨ç¤ºå–åœ°å€å³å¯</p>
<p><code>min_element(begin, end)</code> è¿”å›åºåˆ—ä¸­æœ€å°å…ƒç´ åœ°å€</p>
</li>
<li>
<p><code>string.h</code> å¤´æ–‡ä»¶(<code>cstring</code>å¤´æ–‡ä»¶)</p>
<p><code>memset(æ•°ç»„å,-1æˆ–0,sizeof(æ•°ç»„å))</code></p>
<p><code>strlen(å­—ç¬¦æ•°ç»„)</code> å¾—åˆ°å­—ç¬¦æ•°ç»„ä¸­ç¬¬ä¸€ä¸ª\0å‰çš„å­—ç¬¦ä¸ªæ•°</p>
<p><code>strcmp(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code>è¿”å›ä¸¤ä¸ªå­—ç¬¦ä¸²å¤§å°æ¯”è¾ƒç»“æœï¼ŒæŒ‰å­—å…¸åºã€‚å­—ç¬¦æ•°ç»„1&lt;2 ,è¿”å›è´Ÿæ•´æ•°;1=2ï¼Œè¿”å›0;1&gt;2ï¼Œè¿”å›æ­£æ•´æ•°</p>
<p><code>strcpy(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code>ï¼ŒæŠŠå­—ç¬¦æ•°ç»„2å¤åˆ¶ç»™å­—ç¬¦æ•°ç»„1ï¼ŒåŒ…æ‹¬\0</p>
<p><code>strcat(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code> ,æŠŠ2æ¥åœ¨1åé¢</p>
</li>
<li>
<p><code>cctype</code>å¤´æ–‡ä»¶</p>
<p>1.ä¸ä»…ä»…èƒ½åˆ¤æ–­å­—âºŸï¼Œè¿˜èƒ½åˆ¤æ–­æ•°å­—ã€â¼©å†™å­—âºŸã€â¼¤å†™å­—âºŸç­‰</p>
<p><code>isalpha</code>å­—âºŸï¼ˆåŒ…æ‹¬â¼¤å†™ã€â¼©å†™ï¼‰</p>
<p><code>islower</code> ï¼ˆâ¼©å†™å­—âºŸï¼‰</p>
<p><code>isupper</code>ï¼ˆâ¼¤å†™å­—âºŸï¼‰</p>
<p><code>isalnum</code> ï¼ˆå­—âºŸâ¼¤å†™â¼©å†™+æ•°å­—ï¼‰</p>
<p><code>isblank</code>ï¼ˆspaceå’Œ \t ï¼‰</p>
<p><code>isspace</code>ï¼ˆ space ã€ \t ã€ \r ã€ \n ï¼‰</p>
<p><code>isdigit</code>(æ•°å­—)</p>
<p>2 .<code>tolower (char c)</code>å’Œ <code>toupper(char c)</code> å°†æŸä¸ªå­—ç¬¦è½¬ä¸ºâ¼©å†™æˆ–â¼¤å†™</p>
<ul>
<li>ä½¿â½¤ <code>stoi()</code> ã€ <code>stod()</code>  å¯ä»¥å°†å­—ç¬¦ä¸² string è½¬åŒ–ä¸ºå¯¹åº”çš„ int å‹ã€ double å‹å˜é‡</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//è¾“å‡º123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//è¾“å‡º123.44
 return 0;
}
</code></pre>
</li>
</ul>
<p>3.<code>stoi</code>å¦‚æœé‡åˆ°çš„æ˜¯â¾®æ³•è¾“â¼Šï¼ˆâ½å¦‚<code>stoi(&quot;123.4&quot;)</code>ï¼Œ123.4ä¸æ˜¯â¼€ä¸ªintå‹å˜é‡ï¼‰ï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„     æ•°å­—ï¼Œç›´åˆ°é‡åˆ°ä¸æ˜¯æ•°å­—ä¸ºâ½Œ (æ‰€ä»¥è¯´å¦‚æœæ˜¯æµ®ç‚¹å‹ï¼Œä¼šæˆªå–å‰â¾¯çš„æ•´æ•°éƒ¨åˆ†) 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯</p>
<p><code>stod</code>å¦‚æœæ˜¯â¾®æ³•è¾“â¼Šï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„æµ®ç‚¹æ•°ï¼Œç›´åˆ°é‡åˆ°ä¸æ»¡â¾œæµ®ç‚¹æ•°ä¸ºâ½Œ 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—æˆ–è€…â¼©æ•°ç‚¹ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯ 3.å¦‚æœæœ€å‰â¾¯æ˜¯â¼©æ•°ç‚¹ï¼Œä¼šâ¾ƒåŠ¨è½¬åŒ–ååœ¨å‰â¾¯è¡¥0</p>
<p>ä¸ä»…æœ‰<code>stoi</code>ã€<code>stod</code>ä¸¤ç§ï¼Œç›¸åº”çš„è¿˜æœ‰ï¼š</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
<ul>
<li>
<p><code>to_string()</code>å°†æ•°å€¼è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚è¿”å›å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚å¤´æ–‡ä»¶åŒæ ·ä¸º<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  å¦‚æœæƒ³â½¤<code>printf</code>è¾“å‡ºstringï¼Œéœ€è¦åŠ â¼€ ä¸ª<code>.c_str()</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[å­—ç¬¦ä¸²ç›¸å…³]]></title>
        <id>https://liuxbo.github.io/post/zi-fu-chuan-xiang-guan/</id>
        <link href="https://liuxbo.github.io/post/zi-fu-chuan-xiang-guan/">
        </link>
        <updated>2020-05-07T11:31:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><code>scanf (&quot;%s&quot;)</code>è¯†åˆ«ç©ºæ ¼ä½œä¸ºå­—ç¬¦ä¸²ç»“å°¾</p>
<p><code>getchar</code>  <code>putchar</code> ç”¨æ¥è¾“å…¥è¾“å‡ºå•ä¸ªå­—ç¬¦</p>
<p><code>gets</code> <code>puts</code> ç”¨æ¥è¾“å…¥è¾“å‡ºä¸€è¡Œå­—ç¬¦ä¸²ï¼Œ<code>gets</code> è¯†åˆ«æ¢è¡Œç¬¦\nä½œä¸ºè¾“å…¥ç»“æŸ  ï¼Œgetsç°åœ¨å·²ç»ä¸æ”¯æŒäº†</p>
</li>
<li>
<p><code>cin</code> è¯»å…¥å­—ç¬¦ä¸²æ—¶ï¼Œä»¥ç©ºæ ¼ä¸ºåˆ†éš”ç¬¦ï¼Œå¦‚æœæƒ³è¯»å…¥ä¸€æ•´è¡Œå­—ç¬¦ä¸²ï¼Œç”¨<code>getline(cin,s)</code>ï¼Œæ³¨æ„å‰é¢å¦‚æœè¾“å…¥æ•°å­—nï¼Œä¸€å®šè¦æ³¨æ„<code>scanf(&quot;%d\n&quot;,&amp;n);</code> è¿™æ ·å†™ï¼Œé˜²æ­¢getlineè¯»å…¥é”™è¯¯</p>
</li>
<li>
<p>åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸€æ ·æ—¶å¯ä»¥ç”¨<code>strcmp()==0</code>ï¼Œè¯¥å‡½æ•°å…¶ä¸­ä¸€ä¸ªå‚æ•°å¯ä»¥ä¸ºå­—ç¬¦æ•°ç»„çš„åç§°</p>
</li>
<li>
<p>ä½¿â½¤ <code>stoi()</code> ã€ <code>stod()</code>  å¯ä»¥å°†å­—ç¬¦ä¸² string è½¬åŒ–ä¸ºå¯¹åº”çš„ int å‹ã€ double å‹å˜é‡</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//è¾“å‡º123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//è¾“å‡º123.44
 return 0;
}
</code></pre>
<p><code>stoi</code>å¦‚æœé‡åˆ°çš„æ˜¯â¾®æ³•è¾“â¼Šï¼ˆâ½å¦‚<code>stoi(&quot;123.4&quot;)</code>ï¼Œ123.4ä¸æ˜¯â¼€ä¸ªintå‹å˜é‡ï¼‰ï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„     æ•°å­—ï¼Œç›´åˆ°é‡åˆ°ä¸æ˜¯æ•°å­—ä¸ºâ½Œ (æ‰€ä»¥è¯´å¦‚æœæ˜¯æµ®ç‚¹å‹ï¼Œä¼šæˆªå–å‰â¾¯çš„æ•´æ•°éƒ¨åˆ†) 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯</p>
<p><code>stod</code>å¦‚æœæ˜¯â¾®æ³•è¾“â¼Šï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„æµ®ç‚¹æ•°ï¼Œç›´åˆ°é‡åˆ°ä¸æ»¡â¾œæµ®ç‚¹æ•°ä¸ºâ½Œ 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—æˆ–è€…â¼©æ•°ç‚¹ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯ 3.å¦‚æœæœ€å‰â¾¯æ˜¯â¼©æ•°ç‚¹ï¼Œä¼šâ¾ƒåŠ¨è½¬åŒ–ååœ¨å‰â¾¯è¡¥0</p>
<p>ä¸ä»…æœ‰<code>stoi</code>ã€<code>stod</code>ä¸¤ç§ï¼Œç›¸åº”çš„è¿˜æœ‰ï¼š</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
</li>
<li>
<p><code>to_string()</code>å°†æ•°å€¼è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚è¿”å›å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚å¤´æ–‡ä»¶åŒæ ·ä¸º<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  å¦‚æœæƒ³â½¤<code>printf</code>è¾“å‡ºstringï¼Œéœ€è¦åŠ â¼€ ä¸ª<code>.c_str()</code></p>
</li>
<li>
<p>å­—ç¬¦ä¸²å½¢å¼çš„ä¸¤ä¸ªæ•°å­—ç›¸åŠ </p>
<pre><code>string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ç–«æƒ…]]></title>
        <id>https://liuxbo.github.io/post/yi-qing/</id>
        <link href="https://liuxbo.github.io/post/yi-qing/">
        </link>
        <updated>2020-05-06T13:24:14.000Z</updated>
        <content type="html"><![CDATA[<p>è§„åˆ’å·²ä¹…çš„å­¦ä¹ è®¡åˆ’è¢«ä¸€åœºçªå¦‚å…¶æ¥çš„ç–«æƒ…æ‰“ä¹±ã€‚èµ·åˆå¤§å®¶ä¸ä»¥ä¸ºæ„ï¼Œæ²¡æƒ³åˆ°åæ¥ä¼ æ’­é€Ÿåº¦å¦‚æ­¤ä¹‹å¿«ï¼Œåˆ°ç°åœ¨å‘å±•åˆ°ä¸­å›½å¢ƒå¤–è®¸å¤šå›½å®¶ä¹Ÿå‡ºç°äº†å¤§é‡ç¡®è¯Šç—…ä¾‹...<br>
â€‹ å¥‹æ–—åœ¨ä¸€çº¿çš„åŒ»åŠ¡äººå‘˜ã€å…¬å®‰æ°‘è­¦ç­‰å„æ–¹é¢åŠ›é‡æ—¥æ—¥å¤œå¤œä¸ºæ‰“èµ¢è¿™åœºæˆ˜æ–—è€Œåšå®ˆï¼Œè‡ªå‘è¯·æˆ˜ï¼ŒåŒ»ç”ŸæŠ¤å£«ä»¬å‰ªå»é•¿å‘ï¼Œç©¿ç€å¯†ä¸é€é£çš„é˜²æŠ¤æœè¿ç»­é•¿æ—¶é—´å·¥ä½œï¼Œæ±—å¦‚é›¨ä¸‹ï¼Œæ„Ÿè°¢è¿™äº›ç¾ä¸½çš„å¥³æ±‰å­ä»¬ã€‚æ¯å¤©éƒ½æœ‰è‹±é›„å€’åœ¨é˜²ç–«ä¸€çº¿ï¼Œä»¤äººæ‚²ç—›ä¸å·²ï¼Œ åŒæ ·æ¯å¤©ä¹Ÿæœ‰æ‚£è€…èµ°å‡ºåŒ»é™¢ï¼Œé‡è·å¥åº·ï¼Œè®©æˆ‘ä»¬çœ‹åˆ°è¿™åœºæˆ˜å½¹çš„å¸Œæœ›ã€‚åœ¨æ­¤å¯¹å¥‹æ–—åœ¨ä¸€çº¿çš„äººä»¬è‡´ä»¥å´‡é«˜çš„æ•¬æ„ã€‚<br>
â€‹ ä¸€æ–¹æœ‰éš¾ï¼Œå…«æ–¹æ”¯æ´ï¼Œå›½éš¾å½“å¤´ï¼Œæˆ‘ä»¬æ›´å¤šåœ°çœ‹åˆ°äº†äººæ€§çš„çœŸå®ï¼Œæœ‰è´ªç”Ÿæ€•æ­»ã€ä¸´é˜µé€ƒè·‘çš„æŸäº›å®˜å‘˜ï¼Œæœ‰æ— ç§å¥‰çŒ®ï¼Œæ— å¿æä¾›å¸®åŠ©çš„å¤–å–å°å“¥ã€ç§å®¶è½¦å¸æœºã€ç†å‘å¸ˆã€é…’åº—è€æ¿ï¼Œæœ‰å‘åŒ»åŠ¡äººå‘˜åå£æ°´ã€ä¸æˆ´å£ç½©ã€éª‚éª‚å’§å’§çš„æ— çŸ¥ç¾¤ä¼—ï¼Œæœ‰åŠæ—¶ææ¬¾æ´åŠ©çš„ä¼ä¸šå®¶ã€æ˜æ˜Ÿï¼Œæœ‰åšå®ˆå²—ä½ã€ä¸å¹¸ç¦»ä¸–çš„åŒ»ç”ŸæŠ¤å£«ã€æ°‘è­¦è¾…è­¦ã€æ‘å®˜å¹²éƒ¨...... ã€‚2æœˆ7æ—¥å‡Œæ™¨ï¼Œæ¹–åŒ—æ­¦æ±‰å¸‚çœ¼ç§‘ææ–‡äº®åŒ»ç”Ÿå»ä¸–ï¼Œæ‚²ç—›éš¾ä»¥è¨€è¡¨ã€‚å½“æ—¶åŒèƒ¡æ˜åŒ»ç”Ÿä¸€èµ·æ¥æ”¯æ´å‰çº¿çš„æˆ˜å‹å¦‚ä»Šå´èººåœ¨ICUï¼Œå¤šä¹ˆä»¤äººå¿ƒé…¸......ï¼Œå¸Œæœ›å¤§å®¶éƒ½èƒ½å¹³å®‰çš„çœ‹åˆ°ç–«æƒ…ç»“æŸçš„é‚£ä¸€å¤©ã€‚<br>
â€‹ å®…åœ¨å®¶çš„æˆ‘ä»¬è¯¥æ€æ ·å……å®åœ°åº¦è¿‡å‘¢ã€‚å¤§å®¶æœ‰çš„å¨è‰ºè§é•¿ï¼Œæœ‰çš„å¯ä»¥åœ¨å®¶å¥½å¥½é™ªé™ªäº²äººï¼Œæœ‰çš„è¶æ­¤æœºä¼šä¸“å¿ƒå­¦ä¹ ï¼Œæ¯”å¦‚æˆ‘ï¼Œå­¦ä¼šäº†å’Œé¢ã€åŒ…é¥ºå­ã€çƒ™é¥¼ã€åšå‡‰çš®ã€è’¸è›‹ç³•ğŸ˜‚ç­‰å¥½å¤šæŠ€èƒ½ï¼Œå¹¶ä¸”å¯ä»¥åœ¨å®¶é™ªä¼´çˆ¶æ¯è¿™ä¹ˆé•¿æ—¶é—´ï¼Œä¹Ÿæ˜¯ä¸é”™çš„ä¸€æ®µæ—¶å…‰ã€‚å®‰é€¸å½’å®‰é€¸ï¼Œèº«åœ¨å¤§ä¸‰çš„æˆ‘ä»¬ä¹Ÿä¸‡ä¸èƒ½åœä¸‹å‰è¿›çš„è„šæ­¥ï¼Œå‰å‡ æ—¥æ•™è‚²éƒ¨ä¸€ä½ä¸“å®¶è¯´çš„è¯æˆ‘è®¤ä¸ºå¾ˆæœ‰é“ç†ï¼Œè¯è¯´çš„å°‘äº†ï¼Œæ€è€ƒçš„å°±å¤šäº†ï¼Œè¿™æ˜¯éš¾å¾—çš„åœ¨æµ®èºå–§å“—ä¸­çªç„¶è·å–å¹³é™çš„æ—¥å­ï¼Œæˆ‘ä»¬å¯ä»¥åœä¸‹è„šæ­¥ï¼Œæ€è€ƒå¹¶è§„åˆ’ä¸€ä¸‹è‡ªå·±çš„å¥‹æ–—è®¡åˆ’ï¼Œå¤šå­¦çŸ¥è¯†ï¼Œå¤šæŒæ¡äº›æŠ€èƒ½ï¼Œæ‰€è°“æŠ€å¤šä¸å‹èº«ï¼Œå‡†å¤‡å››å…­çº§ã€è€ƒç ”ã€é¢è¯•ã€å‡ºå›½ç­‰ã€‚<br>
â€‹ é™å¾…èŠ±å¼€ã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PATè€ƒè¯•å¤§çº²]]></title>
        <id>https://liuxbo.github.io/post/pat-kao-shi-da-gang/</id>
        <link href="https://liuxbo.github.io/post/pat-kao-shi-da-gang/">
        </link>
        <updated>2020-05-06T13:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>è€ƒè¯•å¤§çº²<br>
ä¹™çº§</p>
<p>è€ƒç”Ÿåº”å…·å¤‡ä»¥ä¸‹åŸºæœ¬èƒ½åŠ›ï¼š</p>
<ol>
<li>åŸºæœ¬çš„C/C++çš„ä»£ç è®¾è®¡èƒ½åŠ›ï¼Œä»¥åŠç›¸å…³å¼€å‘ç¯å¢ƒçš„åŸºæœ¬è°ƒè¯•æŠ€å·§ï¼›</li>
<li>ç†è§£å¹¶æŒæ¡æœ€åŸºæœ¬çš„æ•°æ®å­˜å‚¨ç»“æ„ï¼Œå³ï¼šæ•°ç»„ã€é“¾è¡¨ï¼›</li>
<li>ç†è§£å¹¶ç†Ÿç»ƒç¼–ç¨‹å®ç°ä¸åŸºæœ¬æ•°æ®ç»“æ„ç›¸å…³çš„åŸºç¡€ç®—æ³•ï¼ŒåŒ…æ‹¬é€’å½’ã€æ’åºã€æŸ¥æ‰¾ç­‰ï¼›</li>
<li>èƒ½å¤Ÿåˆ†æç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦å’Œç®—æ³•ç¨³å®šæ€§ï¼›</li>
<li>å…·å¤‡é—®é¢˜æŠ½è±¡å’Œå»ºæ¨¡çš„åˆæ­¥èƒ½åŠ›ï¼Œå¹¶èƒ½å¤Ÿç”¨æ‰€å­¦æ–¹æ³•è§£å†³å®é™…é—®é¢˜ã€‚</li>
</ol>
<p>ç”²çº§ï¼ˆAdvanced Levelï¼‰</p>
<p>åœ¨è¾¾åˆ°ä¹™çº§è¦æ±‚çš„åŸºç¡€ä¸Šï¼Œè¿˜è¦æ±‚ï¼š</p>
<ol>
<li>å…·æœ‰å……åˆ†çš„è‹±æ–‡é˜…è¯»ç†è§£èƒ½åŠ›ï¼›</li>
<li>ç†è§£å¹¶æŒæ¡åŸºç¡€æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬ï¼šçº¿æ€§è¡¨ã€æ ‘ã€å›¾ï¼›</li>
<li>ç†è§£å¹¶ç†Ÿç»ƒç¼–ç¨‹å®ç°ç»å…¸é«˜çº§ç®—æ³•ï¼ŒåŒ…æ‹¬å“ˆå¸Œæ˜ å°„ã€å¹¶æŸ¥é›†ã€æœ€çŸ­è·¯å¾„ã€æ‹“æ‰‘æ’åºã€å…³é”®è·¯å¾„ã€è´ªå¿ƒã€æ·±åº¦ä¼˜å…ˆæœç´¢ã€å¹¿åº¦ä¼˜å…ˆæœç´¢ã€å›æº¯å‰ªæç­‰ï¼›</li>
<li>å…·å¤‡è¾ƒå¼ºçš„é—®é¢˜æŠ½è±¡å’Œå»ºæ¨¡èƒ½åŠ›ï¼Œèƒ½å®ç°å¯¹å¤æ‚å®é™…é—®é¢˜çš„æ¨¡æ‹Ÿæ±‚è§£ã€‚ã€‚</li>
</ol>
<p>é¡¶çº§ï¼ˆTop Levelï¼‰</p>
<p>åœ¨è¾¾åˆ°ç”²çº§è¦æ±‚çš„åŸºç¡€ä¸Šï¼Œè¿˜è¦æ±‚ï¼š<br>
1Â· å¯¹é«˜çº§ã€å¤æ‚æ•°æ®ç»“æ„æŒæ¡å…¶ç”¨æ³•å¹¶èƒ½å¤Ÿç†Ÿç»ƒä½¿ç”¨ï¼Œå¦‚åç¼€æ•°ç»„ã€æ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘ã€Treapã€é™æ€KDTreeç­‰ï¼›<br>
2Â· èƒ½å¤Ÿåˆ©ç”¨ç»å…¸ç®—æ³•æ€æƒ³è§£å†³è¾ƒéš¾çš„ç®—æ³•é—®é¢˜ï¼Œå¦‚åŠ¨æ€è§„åˆ’ã€è®¡ç®—å‡ ä½•ã€å›¾è®ºé«˜çº§åº”ç”¨ï¼ˆåŒ…æ‹¬æœ€å¤§æµ/æœ€å°å‰²ï¼Œå¼ºè¿é€šåˆ†æ”¯ã€æœ€è¿‘å…¬å…±ç¥–å…ˆã€æœ€å°ç”Ÿæˆæ ‘ã€æ¬§æ‹‰åºåˆ—ï¼‰ç­‰ï¼Œå¹¶çµæ´»è¿ç”¨ï¼›<br>
3Â· èƒ½å¤Ÿè§£å†³å¤æ‚çš„æ¨¡æ‹Ÿé—®é¢˜ï¼Œç¼–å†™å¹¶è°ƒè¯•ä»£ç é‡è¾ƒå¤§çš„ç¨‹åºï¼›<br>
4Â· å…·æœ‰ç¼œå¯†çš„ç§‘å­¦æ€ç»´ï¼Œè€ƒè™‘é—®é¢˜å‘¨å…¨ï¼Œèƒ½å¤Ÿæ­£ç¡®åº”å¯¹å¤æ‚é—®é¢˜çš„è¾¹ç•Œæƒ…å†µã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEAçš„ä½¿ç”¨]]></title>
        <id>https://liuxbo.github.io/post/idea-de-shi-yong/</id>
        <link href="https://liuxbo.github.io/post/idea-de-shi-yong/">
        </link>
        <updated>2020-05-06T13:22:10.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>æ„æˆ</p>
<p>æ–‡ä»¶ä»å¤§åˆ°å°ä¾æ¬¡æ˜¯project-&gt;module-&gt;packageï¼Œ</p>
</li>
</ul>
<p>â€‹       è‡ªå·±çš„ä»£ç æ”¾åœ¨srcæ–‡ä»¶ä¸‹</p>
<p>â€‹       packageçš„å‘½åä¸€èˆ¬ç”±æ•°å­—ã€å°æ•°ç‚¹ ã€å°å†™å­—æ¯æ„æˆ(ä¾‹å¦‚ cn.itcast.day04.demo01 æ¯ä¸ªå°æ•°ç‚¹å‰éƒ½æ˜¯ä¸€ä¸ªæ–‡</p>
<p>â€‹       ä»¶å¤¹ï¼ŒåŒ…å«å°æ•°ç‚¹åçš„æ–‡ä»¶ï¼Œæ˜¯ä¸€ç»„å±‚çº§æ–‡ä»¶)</p>
<ul>
<li>è®¾ç½®å’Œæ“ä½œ</li>
</ul>
<p>â€‹       å¯¼å…¥ä¸€ä¸ªæ¨¡å—ï¼šfile-&gt;project Structure-&gt;import module</p>
<p>â€‹       settings-&gt;keymap-&gt;Mainmenu-&gt;code-&gt;completion-&gt;basic(å°†å…¶æ”¹ä¸ºAlt+/) ï¼Œç”¨äºä»£ç æç¤ºå¿«æ·è¾“å…¥ã€‚</p>
<ul>
<li>
<p>å¸¸ç”¨å¿«æ·é”®</p>
<p><code>Alt+/</code>ï¼Œå¿«æ·è¾“å…¥ ï¼› <code>Alt+Enter</code>ï¼Œå¯¼å…¥åŒ…ï¼Œè‡ªåŠ¨ä¿®æ­£ä»£ç ï¼› <code>Ctrl+Y</code> åˆ é™¤å…‰æ ‡æ‰€åœ¨è¡Œï¼›</p>
<p><code>Ctrl+D</code> å¤åˆ¶å…‰æ ‡æ‰€åœ¨è¡Œçš„å†…å®¹ï¼Œæ’å…¥å…‰æ ‡ä½ç½®ä¸‹é¢ ï¼›  <code>Ctrl+Alt+L</code> æ ¼å¼åŒ–ä»£ç  ï¼›</p>
<p><code>Ctrl+/</code>å•è¡Œæ³¨é‡Š ï¼› <code>Ctrl+Shift+/</code>é€‰ä¸­ä»£ç æ³¨é‡Šï¼Œå¤šè¡Œæ³¨é‡Šï¼Œå†æŒ‰å–æ¶ˆæ³¨é‡Š ï¼›</p>
<p><code>Alt+Ins</code>è‡ªåŠ¨ç”Ÿæˆä»£ç ï¼ŒtoStringï¼Œgetï¼Œsetç­‰æ–¹æ³• ï¼›<code>Alt+Shift+ä¸Šä¸‹ç®­å¤´</code> ç§»åŠ¨å½“å‰ä»£ç è¡Œ</p>
<p><code>n.fori</code> å¿«é€Ÿç”Ÿæˆnæ¬¡å¾ªç¯forè¯­å¥</p>
<p>psvmå¿«æ·ç”Ÿæˆ<code>public static void main(String[], args)</code></p>
<p>soutå¿«é€Ÿè¾“å‡º</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PATé¢˜è§£]]></title>
        <id>https://liuxbo.github.io/post/pat-ti-jie/</id>
        <link href="https://liuxbo.github.io/post/pat-ti-jie/">
        </link>
        <updated>2020-05-06T13:21:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="a-100120-ä¸¤æ•°ç›¸åŠ ">A 1001(20  ä¸¤æ•°ç›¸åŠ )</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	int a,b;
	cin&gt;&gt;a&gt;&gt;b;
	string s=to_string(a+b);
	int len=s.length();
	for(int i=0;i&lt;len;i++){
		cout&lt;&lt;s[i];
		if(s[i]=='-') continue;
		if((i+1)%3==len%3&amp;&amp;i!=len-1) cout&lt;&lt;&quot;,&quot;;
	}
	return 0;
}
</code></pre>
<h3 id="a1002å¤šé¡¹å¼æ±‚å’Œ">A1002(å¤šé¡¹å¼æ±‚å’Œ)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=1001;
int count1,count2;
double coe[maxn]={},a;
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
	while(count1--){
		int i;
	    scanf(&quot;%d%lf&quot;,&amp;i,&amp;a);
		coe[i]=coe[i]+a;
	}
	scanf(&quot;%d&quot;,&amp;count2);
	while(count2--){
        int k;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		coe[k]=coe[k]+a;
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0) printf(&quot; %d %.1f&quot;,k,coe[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a1003">A1003</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=510;
const int INF=1000000000;
int weight[maxn],d[maxn],w[maxn],num[maxn],G[maxn][maxn];
int n;
bool vis[maxn]={false};
void dijks(int s){
	fill(d,d+maxn,INF);
	fill(num,num+maxn,0);
	fill(w,w+maxn,0);
	w[s]=weight[s];
	d[s]=0;
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					num[v]=num[u];
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];
				}else if(d[u]+G[u][v]==d[v]){
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
					}
					num[v]+=num[u];
				}
			}
		}
	}
}
int main(){
	int m,st,end;
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;end);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;weight[i]);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int c1,c2;
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		scanf(&quot;%d&quot;,&amp;G[c1][c2]);
		G[c2][c1]=G[c1][c2]; 
	}
	dijks(st);
	printf(&quot;%d %d&quot;,num[end],w[end]);
	return 0;
}
</code></pre>
<h3 id="a1004">A1004</h3>
<pre><code>1.DFSæ³•
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		level[depth]++;
		if(depth&gt;maxdepth)	maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		while(k--){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,0);
	for(int i=0;i&lt;=maxdepth;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,level[i]);
	}
	return 0;
}

2.BFSæ³•
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int hashtable[maxn] = { 0 };
vector&lt;int&gt; child[maxn];
int n, m, level[maxn] = { 0 },maxlevel=0;
void BFS() {
	level[1] = 1;
	queue&lt;int&gt; q;
	q.push(1);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		if (child[now].size() == 0) {
			hashtable[level[now]]++;
			maxlevel = max(maxlevel, level[now]);
		}
		for (int i = 0; i &lt; child[now].size(); i++) {
			level[child[now][i]] = level[now] + 1;
			q.push(child[now][i]);
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int father,num,temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father, &amp;num);
		while (num--) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[father].push_back(temp);
		}
	}
	BFS();
	for (int i = 1; i &lt;= maxlevel; i++) {
		printf(&quot;%d&quot;, hashtable[i]);
		if (i &lt; maxlevel) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a100520-å­—ç¬¦ä¸²">A1005(20 å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n,spell[10]={&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;};
	cin&gt;&gt;n;
	int sum=0;
	for(int i=0;i&lt;n.size();i++) sum+=(n[i]-'0');
	string ans=to_string(sum);
	cout&lt;&lt;spell[ans[0]-'0'];
	for(int i=1;i&lt;ans.size();i++) cout&lt;&lt;&quot; &quot;&lt;&lt;spell[ans[i]-'0'];
	return 0;
}
</code></pre>
<h3 id="a1006">A1006</h3>
<pre><code>#include&lt;cstdio&gt; 

struct person {
	char id[16];
	int hh, mm, ss;
}temp,first,last;
bool great(person node1, person node2) {
	if (node1.hh != node2.hh) return node1.hh &gt; node2.hh;
	if (node2.mm != node2.mm) return node1.mm &gt; node2.mm;
	return node1.ss &gt; node2.ss;
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	first.hh = 24, first.mm = 60, first.ss = 60;
	last.hh = 0, last.mm = 0, last.ss = 0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %d:%d:%d&quot;, temp.id, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, first) == false)  first = temp;
		scanf(&quot;%d:%d:%d&quot;, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, last))   last = temp;
	}
	printf(&quot;%s %s&quot;, first.id, last.id);
	return 0;
}
</code></pre>
<h3 id="a1007">A1007</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
	dp[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
<h3 id="a1008">A1008</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
	int n,a[100000],totaltime=0;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
		if (i == 0) totaltime = a[i] * 6 + 5;
		else {
			if (a[i] &gt; a[i - 1]) totaltime +=(a[i] - a[i - 1]) * 6 + 5;
			else totaltime += ((a[i-1] - a[i]) * 4 + 5);
		}
	}
	cout &lt;&lt; totaltime;
	return 0;
}
</code></pre>
<h3 id="a1009-å¤šé¡¹å¼ç›¸ä¹˜">A1009 å¤šé¡¹å¼ç›¸ä¹˜</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=2001;
int count1,count2;
struct poly{
	int exp;
	double coef;
}coe[1001];
double result[maxn];
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
for(int i =0;i&lt;count1;i++){
	scanf(&quot;%d%lf&quot;,&amp;coe[i].exp,&amp;coe[i].coef);
    }
	scanf(&quot;%d&quot;,&amp;count2);
for(int i=0;i&lt;count2;i++){
	int k;
	double a;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		for(int i=0;i&lt;count1;i++){
			result[k+coe[i].exp]+=(a*coe[i].coef);
		}
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0) printf(&quot; %d %.1f&quot;,k,result[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a101025-äºŒåˆ†">A1010(25 äºŒåˆ†)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
long long convert(string n,long long radix){
	long long sum=0,index=0,temp;
	for(auto it=n.rbegin();it!=n.rend();it++){
		temp=isdigit(*it)? (*it)-'0' : (*it)-'a'+10;
		sum+=temp*pow(radix,index++);
	}
	return sum;
}
long long findradix(string n,long long num){
	char it=*max_element(n.begin(),n.end());
	long long low=(isdigit(it)? (it)-'0' : (it)-'a'+10)+1;
	long long high=max(low,num);
	while(low&lt;=high){
		long long mid=(low+high)/2;
		long long temp=convert(n,mid);
		if(temp&lt;0||temp&gt;num) high=mid-1;//å°äº0çš„æƒ…å†µæ˜¯è¿›åˆ¶å¤ªå¤§å¯¼è‡´æº¢å‡º 
		else if(temp==num) return mid;
		else low=mid+1;
	}
	return -1;
}
int main(){
	string n1,n2;
	long long tag,radix,ans;
	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;tag&gt;&gt;radix;
	ans=tag==1?findradix(n2,convert(n1,radix)) : findradix(n1,convert(n2,radix));
	if(ans==-1) cout&lt;&lt;&quot;Impossible&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1011">A1011</h3>
<pre><code>#include&lt;cstdio&gt; 
char s[4] = &quot;WTL&quot;;
double a,res=1;
int main() {
	for (int i = 0; i &lt; 3; i++) {
		int imax;
		double temp = 0;
		for (int i = 0; i &lt; 3; i++) {
			scanf_s(&quot;%lf&quot;, &amp;a);
			if (a &gt; temp) {
				temp = a;
				imax = i;
			}
		}
		res *= temp;
		printf(&quot;%c &quot;, s[imax]);
	}
	printf(&quot;%.2f&quot;, (res * 0.65 - 1) * 2);
	return 0;
}
</code></pre>
<h3 id="a101225-æ¡ä»¶æ’åº">A1012(25 æ¡ä»¶æ’åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
struct node{
	int id;
	int score[4];
}stu[2000];
int now,rk[1000000][4];
bool cmp(node a,node b){
	return a.score[now]&gt;b.score[now];
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	map&lt;int,bool&gt; mp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;stu[i].id,&amp;stu[i].score[1],&amp;stu[i].score[2],&amp;stu[i].score[3]);
		stu[i].score[0]=(int)((stu[i].score[1]+stu[i].score[2]+stu[i].score[3])*1.0/3+0.5);
		mp[stu[i].id]=true;
	}
	for(now=0;now&lt;=3;now++){
		sort(stu,stu+n,cmp);
		rk[stu[0].id][now]=1;
		for(int i=1;i&lt;n;i++){
			if(stu[i].score[now]==stu[i-1].score[now]) rk[stu[i].id][now]=rk[stu[i-1].id][now];
			else rk[stu[i].id][now]=i+1;
		}
	}
	char course[4]={'A','C','M','E'};
	for(int i=0;i&lt;m;i++){
		int query,bestrank=9999,index=0;
		scanf(&quot;%d&quot;,&amp;query);
		if(mp.count(query)==0){
			printf(&quot;N/A\n&quot;);
			continue;
		}
		for(int j=0;j&lt;4;j++){
			if(rk[query][j]&lt;bestrank){
				bestrank=rk[query][j];
				index=j;
			}
		}
		printf(&quot;%d %c\n&quot;,rk[query][index],course[index]);
	}
	return 0;
}
</code></pre>
<h3 id="a101325-å›¾çš„dfséå†è®¡ç®—è¿é€šå—ä¸ªæ•°">A1013(25 å›¾çš„dfséå†ï¼Œè®¡ç®—è¿é€šå—ä¸ªæ•°)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int n,m,k,G[maxn][maxn],cnt=0;
bool vis[maxn];
void dfs(int v){
	vis[v]=true;
	for(int i=1;i&lt;=n;i++){
		if(G[v][i]==1&amp;&amp;vis[i]==false) dfs(i);
	}
}
int main(){
	int a,b;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		G[a][b]=G[b][a]=1;
	}
	while(k--){
		int cnt=0;
		fill(vis,vis+maxn,false);
		scanf(&quot;%d&quot;,&amp;a);
		vis[a]=true;
		for(int i=1;i&lt;=n;i++){
			if(vis[i]==false){
				dfs(i);
				cnt++;
			}
		}
		printf(&quot;%d\n&quot;,cnt-1);//éœ€è¦æ·»åŠ çš„è·¯å¾„ä¸ºè¿é€šå—ä¸ªæ•°å‡1 
	}
	return 0;
}
</code></pre>
<h3 id="a101430-æ¨¡æ‹Ÿ-éš¾é¢˜">A1014(30 æ¨¡æ‹Ÿ  éš¾é¢˜)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node {
	int poptime, endtime;
	queue&lt;int&gt; q;
};
int main() {
	int n, m, k, Q, index = 1, query;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;Q);
	vector&lt;int&gt; time(k + 1), ans(k + 1);
	for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;time[i]);
	vector&lt;node&gt;window(n + 1);
	vector&lt;bool&gt;sorry(k + 1, false);
	for (int i = 1; i &lt;= m; i++) {
		for (int j = 1; j &lt;= n; j++) {
			if (index &lt;= k) {
				window[j].q.push(time[index]);
				if (window[j].endtime &gt;= 540) sorry[index] = true;
				window[j].endtime += time[index];
				if (i == 1) window[j].poptime = window[j].endtime;
				ans[index] = window[j].endtime;
				index++;
			}
		}
	}
	while (index &lt;= k) {
		int minpoptime = window[1].poptime, tempwindow = 1;
		for (int i = 2; i &lt;= n; i++) {
			if (window[i].poptime &lt; minpoptime) {
				minpoptime = window[i].poptime;
				tempwindow = i;
			}
		}
		window[tempwindow].q.pop();
		window[tempwindow].poptime += window[tempwindow].q.front();
		window[tempwindow].q.push(time[index]);
		if (window[tempwindow].endtime &gt;= 540) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		ans[index] = window[tempwindow].endtime;
		index++;
	}
	while (Q--) {
		scanf(&quot;%d&quot;, &amp;query);
		if (sorry[query] == true) printf(&quot;Sorry\n&quot;);
		else printf(&quot;%02d:%02d\n&quot;, (ans[query] + 480) / 60, (ans[query] + 480) % 60);
	}
	return 0;
}
</code></pre>
<h3 id="a1015">A1015</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = (int)sqrt(n * 1.0);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
int change(int n,int b) {
	int res[20],ans=0;
	int j = 0;
	do {
		res[j++] = n % b;
		n = n / b;
	} while (n != 0);
	reverse(res, res+ j);
	for (int i = 0; i &lt; j; i++) {
		ans += res[i] * pow(b*(1.0), i*(1.0));
	}
	return ans;
}
int main() {
	while (1) {
		int num, radix;
		scanf_s(&quot;%d&quot;, &amp;num);
		if (num &lt; 0) break;
		else {
			scanf_s(&quot;%d&quot;, &amp;radix);
			int ans = change(num, radix);
			if (isprime(num) &amp;&amp; isprime(ans)) printf(&quot;Yes\n&quot;);
			else printf(&quot;No\n&quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a101625-æ’åº-å¤„ç†å¤šæ¡é€šè¯æ—¶é—´è®°å½•">A1016(25 æ’åº å¤„ç†å¤šæ¡é€šè¯æ—¶é—´è®°å½•)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt; 
using namespace std;
struct node{
	string name;
	int status,time,month,day,hour,minute;
};
bool cmp(node a,node b){
	return a.name!=b.name? a.name&lt;b.name : a.time&lt;b.time;
}
double billfromzero(node a,int *rate){
	double total=a.minute*rate[a.hour]+a.day*60*rate[24];
	for(int i=0;i&lt;a.hour;i++) total+=60*rate[i];
	return total/100.0;
}
 int main(){
 	int n,rate[25]={0};
 	for(int i=0;i&lt;24;i++){
 		scanf(&quot;%d&quot;,&amp;rate[i]);
 		rate[24]+=rate[i];
	 }
	 cin&gt;&gt;n;
	 vector&lt;node&gt; v(n);
	 for(int i=0;i&lt;n;i++){
	 	cin&gt;&gt;v[i].name;
	 	scanf(&quot;%d:%d:%d:%d&quot;,&amp;v[i].month,&amp;v[i].day,&amp;v[i].hour,&amp;v[i].minute);
	 	v[i].time=v[i].day*24*60+v[i].hour*60+v[i].minute;
	 	string temp;
	 	cin&gt;&gt;temp;
	 	v[i].status=(temp==&quot;on-line&quot;)? 1 : 0 ;
	 } 
	 sort(v.begin(),v.end(),cmp);
	 map&lt;string,vector&lt;node&gt; &gt;mp;
	 for(int i=1;i&lt;n;i++){
	 	if(v[i].name==v[i-1].name&amp;&amp;v[i-1].status==1&amp;&amp;v[i].status==0){
	 		mp[v[i-1].name].push_back(v[i-1]);
	 		mp[v[i].name].push_back(v[i]);
		 }
	 }
	 for(auto it:mp){
	 	cout&lt;&lt; it.first;
	 	vector&lt;node&gt; temp=it.second;
	 	printf(&quot; %02d\n&quot;,temp[0].month);
	 	double total=0.0;
	 	for(int i=1;i&lt;temp.size();i+=2){
	 		double t=billfromzero(temp[i],rate)-billfromzero(temp[i-1],rate);
	 		printf(&quot;%02d:%02d:%02d&quot;,temp[i-1].day,temp[i-1].hour,temp[i-1].minute);
			printf(&quot; %02d:%02d:%02d %d&quot;,temp[i].day,temp[i].hour,temp[i].minute,temp[i].time-temp[i-1].time);
			printf(&quot; $%.2f\n&quot;,t);
			total+=t;
		 }
		 printf(&quot;Total amount: $%.2f\n&quot;,total);
	 } 
	 return 0;
 }
</code></pre>
<h3 id="a1017-25-æ¨¡æ‹Ÿ-æ—¶é—´å¤„ç†-æ’åº">A1017 ï¼ˆ25 æ¨¡æ‹Ÿ ï¼Œæ—¶é—´å¤„ç†ã€æ’åºã€ï¼‰</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int cometime;
	int servetime;
}newcustomer; 
int Endtime[101];
vector&lt;node&gt; customer;
int convert(int h,int m,int s){
	return h*3600+m*60+s;
}
bool cmp(node a,node b){
	return a.cometime&lt;b.cometime;
}
int main(){
	int n,w,totwait=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;w);
	int starttime=convert(8,0,0);
	int endtime=convert(17,0,0);
	for(int i=0;i&lt;n;i++){
		int hh,mm,ss,serve;
		scanf(&quot;%d:%d:%d %d&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;serve);
		newcustomer.cometime=convert(hh,mm,ss);
		if(newcustomer.cometime&gt;endtime) continue;
		newcustomer.servetime=(serve&lt;=60?serve*60:3600);
		customer.push_back(newcustomer);
	}
	sort(customer.begin(),customer.end(),cmp);
	for(int i=0;i&lt;=101;i++) Endtime[i]=starttime;
	for(int i=0;i&lt;customer.size();i++){
		int minendtime=1000000000,id=-1;
		for(int j=0;j&lt;w;j++){
			if(Endtime[j]&lt;minendtime){
				minendtime=Endtime[j];
				id=j;
			}
		}
		if(Endtime[id]&lt;=customer[i].cometime){
			Endtime[id]=customer[i].cometime+customer[i].servetime;
		}else{
			totwait+=Endtime[id]-customer[i].cometime; 
			Endtime[id]+=customer[i].servetime; 
		}
	}
	if(customer.size()==0) printf(&quot;0.0&quot;);
	else printf(&quot;%.1f&quot;,(double)((totwait*1.0/60.0)/customer.size()));
	return 0;
}
</code></pre>
<h3 id="a1018">A1018</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int  maxn=510;
const int INF=1000000000;
int minneed=INF,minremain=INF,cmax,n,sp,m;
int G[maxn][maxn],d[maxn],weight[maxn];
vector&lt;int&gt; path,temppath;
vector&lt;int&gt;pre[maxn];
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;=n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;=n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;=n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					pre[v].clear();
					pre[v].push_back(u);
				}else if(d[v]==G[u][v]+d[u]){
					pre[v].push_back(u);
				}
			}
		}
	}
}
void DFS(int v){
	if(v==0){
		temppath.push_back(v);
		int need=0,remain=0;
		for(int i=temppath.size()-1;i&gt;=0;i--){
			int id=temppath[i];
			if(weight[id]&gt;0){
				remain+=weight[id];
			}else{
				if(abs(weight[id])&lt;remain){
					remain-=abs(weight[id]);
				}else {
					need+=abs(weight[id])-remain;
					remain=0;
				}
			}
		} 
		if(need&lt;minneed){
			minneed=need;
			minremain=remain;
			path=temppath;
		}else if(need==minneed&amp;&amp;remain&lt;minremain){
			minremain=remain;
			path=temppath;
		}
		temppath.pop_back();
		return;
	}
	temppath.push_back(v);
	for(int i=0;i&lt;pre[v].size();i++){
		DFS(pre[v][i]);
	}
	temppath.pop_back();
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;cmax,&amp;n,&amp;sp,&amp;m);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;weight[i]);
		weight[i]-=cmax/2;
	}
	for(int i=1;i&lt;=m;i++){
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		scanf(&quot;%d&quot;,&amp;G[a][b]);
		G[b][a]=G[a][b];
	}
	dijkst(0);
	DFS(sp);
	printf(&quot;%d &quot;,minneed);
	for(int i=path.size()-1;i&gt;=0;i--){
		printf(&quot;%d&quot;,path[i]);
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	printf(&quot; %d&quot;,minremain);
	return 0;
}
</code></pre>
<h3 id="a1019">A1019</h3>
<pre><code>#include&lt;cstdio&gt;
 int main(){
 	int n,b,ans[50],index=0;
 	scanf(&quot;%d%d&quot;,&amp;n,&amp;b);
 	while(n!=0){
 		ans[index++]=n%b;
 		n/=b;
	 }
	 bool flag=true;
	 for(int i=0;i&lt;=index/2;i++){
	 	if(ans[i]!=ans[index-i-1]) flag=false;
	 }
	 if(flag==false) printf(&quot;No\n&quot;);
	 else printf(&quot;Yes\n&quot;);
	 for(int i=index-1;i&gt;=0;i--){
	 	if(i!=index-1) printf(&quot; &quot;);
	 	printf(&quot;%d&quot;,ans[i]);
	 }
	 return 0; 
 }
</code></pre>
<h3 id="a102025-ååºä¸­åºå»ºæ ‘è¾“å‡ºå±‚åº">A1020(25 ååº+ä¸­åºå»ºæ ‘ï¼Œè¾“å‡ºå±‚åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=31;
struct node{
	int data;
	node *left,*right;
};
int post[maxn],in[maxn],n,num=0;
node * create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;data=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root;
}
void layerorder(node *root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		node* Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top-&gt;data);
		num++;
		if(num&lt;n) printf(&quot; &quot;);
		if(Top-&gt;left!=NULL) q.push(Top-&gt;left);
		if(Top-&gt;right!=NULL) q.push(Top-&gt;right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	node*root=create(0,n-1,0,n-1);
	layerorder(root);
	return 0;
}
</code></pre>
<h3 id="a102125-æ‰¾å‡ºå›¾ä¸­ä½¿æ·±åº¦æœ€æ·±çš„ç»“ç‚¹é¦–å…ˆåˆ¤æ–­æ˜¯å¦èƒ½çœ‹æˆæ ‘">A1021(25 æ‰¾å‡ºå›¾ä¸­ä½¿æ·±åº¦æœ€æ·±çš„ç»“ç‚¹(é¦–å…ˆåˆ¤æ–­æ˜¯å¦èƒ½çœ‹æˆæ ‘))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
bool vis[10010]; 
int n,maxheight=-1;
vector&lt;int&gt; ans,G[10010];
void dfs(int index,int height){
	vis[index]=true;
	if(height&gt;maxheight){
		maxheight=height;
		ans.clear();
		ans.push_back(index);
	}else if(height==maxheight) ans.push_back(index);
	for(int i=0;i&lt;G[index].size();i++){
		if(vis[G[index][i]]==false) dfs(G[index][i],height+1); 
	} 
}
int main(){
	int v1,v2,cnt=0,st;
	set&lt;int&gt; res;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n-1;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		G[v1].push_back(v2);
		G[v2].push_back(v1);
	} 
	fill(vis,vis+10010,false);
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			dfs(i,0);
			if(i==1){
				if(ans.size()!=0) st=ans[0];
				for(int j=0;j&lt;ans.size();j++) res.insert(ans[j]);
			} 
			cnt++;
		}
	}
	if(cnt&gt;1) printf(&quot;Error: %d components&quot;,cnt);
	else{
		ans.clear(); 
		fill(vis,vis+10010,false);
		maxheight=-1;
		dfs(st,0);
		for(int i=0;i&lt;ans.size();i++) res.insert(ans[i]);
		for(auto it=res.begin();it!=res.end();it++) printf(&quot;%d\n&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1022">A1022</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string, set&lt;int&gt; &gt; mptitle, mpautor, mpkey, mppublish, mpyear;
void query(map&lt;string, set&lt;int&gt; &gt;&amp; mp, string&amp; str) {
	if (mp.count(str) == 0) cout &lt;&lt; &quot;Not Found\n&quot;;
	else {
		for (auto it = mp[str].begin(); it != mp[str].end(); it++) {
			printf(&quot;%07d\n&quot;, *it);
		}
	}
}
int main() {
	int n,m,id;
	cin &gt;&gt; n;
	string title, autor, keyword, publish, year;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		char c = getchar();
		getline(cin, title);
		mptitle[title].insert(id);
		getline(cin, autor);
		mpautor[autor].insert(id);
		while (cin &gt;&gt; keyword) {
			mpkey[keyword].insert(id);
			 c = getchar();
			if (c == '\n') break;
		}
		getline(cin, publish);
		mppublish[publish].insert(id);
		getline(cin, year);
		mpyear[year].insert(id);
	}
	cin &gt;&gt; m;
	while(m--){
		int type;
		string temp;
		scanf(&quot;%d: &quot;, &amp;type);
		getline(cin, temp);
		cout &lt;&lt; type &lt;&lt; &quot;:&quot; &lt;&lt; &quot; &quot; &lt;&lt; temp&lt;&lt;endl;
		if (type == 1) query(mptitle, temp);
		if (type == 2) query(mpautor, temp);
		if (type == 3) query(mpkey, temp);
		if (type == 4) query(mppublish, temp);
		if (type == 5) query(mpyear, temp);
	}
	return 0;
}
</code></pre>
<h3 id="a1023">A1023</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
bool judge(bign a, bign b) {
	if (a.len != b.len) return false;
	else {
		int count[10] = { 0 };
		for (int i = 0; i &lt; a.len; i++) {
			count[a.d[i]]++;
			count[b.d[i]]--;
		}
		for (int i = 0; i &lt; 10; i++) {
			if (count[i] != 0) {
				return false;
			}
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
}
int main() {
	string str;
	cin &gt;&gt; str;
	bign a, ans;
	a=change(str);
	ans = multi(a, 2);
	if (judge(a, ans)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	print(ans);
	return 0;
}
</code></pre>
<h3 id="a1024">A1024</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
struct bign {
	int d[100];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign res;
	res.len = str.size();
	for (int i = 0; i &lt; res.len; i++) {
		res.d[i] = str[res.len - 1 - i]-'0';
	}
	return res;
}
bign add(bign a, bign b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len || i &lt; b.len; i++) {
		int temp = a.d[i] + b.d[i] + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	if (carry != 0) {
		c.d[c.len++] = carry % 10;
	}
	return c;
}
bool judge(bign a) {
	for (int i = 0; i &lt;= a.len / 2; i++) {
		if (a.d[i] != a.d[a.len - 1 - i]) {
			return false;
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
	cout &lt;&lt; endl;
}
int main() {
	string str;
	int k;
	cin &gt;&gt; str;
	cin &gt;&gt; k;
	bign ans=change(str);
	int i;
	for ( i = 0; i &lt; k; i++) {
		if (judge(ans)) break;
		bign temp = ans;
		reverse(temp.d, temp.d + temp.len);
		ans = add(temp, ans);
	}
	print(ans);
	if (i &lt;= k) cout &lt;&lt; i;
	else cout &lt;&lt; k;
	return 0;
}
</code></pre>
<h3 id="a102525-æ¡ä»¶æ’åº">A1025(25 æ¡ä»¶æ’åº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string id;
	int localid,score,frank,lrank;
};
bool cmp(node a,node b){
	return a.score!=b.score? a.score&gt;b.score : a.id&lt;b.id;
}
int main(){
	int n,k;
	cin&gt;&gt;n;
	vector&lt;node&gt; total;
	for(int j=1;j&lt;=n;j++){
		scanf(&quot;%d&quot;,&amp;k);
		vector&lt;node&gt; v(k);
		for(int i=0;i&lt;k;i++) {
			cin&gt;&gt;v[i].id&gt;&gt;v[i].score;
			v[i].localid=j;
		}
		sort(v.begin(),v.end(),cmp);
		v[0].lrank=1;
		for(int i=1;i&lt;k;i++) {
			if(v[i].score==v[i-1].score) v[i].lrank=v[i-1].lrank;
			else v[i].lrank=i+1;
		}
		for(int i=0;i&lt;k;i++) total.push_back(v[i]);
	}
	sort(total.begin(),total.end(),cmp);
	total[0].frank=1;
	for(int i=1;i&lt;total.size();i++) {
		if(total[i].score==total[i-1].score) total[i].frank=total[i-1].frank;
		else total[i].frank=i+1;
	}
	cout&lt;&lt;total.size()&lt;&lt;endl;
	for(int i=0;i&lt;total.size();i++){
		printf(&quot;%s %d %d %d\n&quot;,total[i].id.c_str(),total[i].frank,total[i].localid,total[i].lrank);
	}
	return 0;
}
</code></pre>
<h3 id="a1027">A1027</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	char c[14]={&quot;0123456789ABC&quot;};
	printf(&quot;#&quot;);
	for(int i=0;i&lt;3;i++){
		int n;
		scanf(&quot;%d&quot;,&amp;n);
		printf(&quot;%c%c&quot;,c[n/13],c[n%13]);
	}
	return 0;
}
</code></pre>
<h3 id="a102825-æ’åº">A1028(25  æ’åº)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	int id,grade;
	string name;
};
bool cmp1(node a,node b){
	return a.id&lt;b.id;
}
bool cmp2(node a,node b){
	return a.name!=b.name? a.name&lt;b.name :a.id&lt;b.id;
}
bool cmp3(node a,node b){
	return a.grade!=b.grade? a.grade&lt;b.grade : a.id&lt;b.id;
}
int main(){
	int n,c;
	cin&gt;&gt;n&gt;&gt;c;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i].id&gt;&gt;v[i].name&gt;&gt;v[i].grade;
	if(c==1) sort(v.begin(),v.end(),cmp1);
	else if(c==2) sort(v.begin(),v.end(),cmp2);
	else if(c==3)sort(v.begin(),v.end(),cmp3);
	for(int i=0;i&lt;n;i++) printf(&quot;%06d %s %d\n&quot;,v[i].id,v[i].name.c_str(),v[i].grade);
	return 0;
}
</code></pre>
<h3 id="a102925-æ±‚ä¸­ä½æ•°-twopoints">A1029(25 æ±‚ä¸­ä½æ•° twopoints)</h3>
<pre><code>1.ç›´æ¥æš´åŠ›
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
int main(){
    int n1,n2;
    long long a[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    int i;
    for( i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for( i=n1;i&lt;n2+n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    sort(a,a+n1+n2);
    printf(&quot;%d&quot;,a[(n1+n2-1)/2]);
    return 0;
}

2.two points

#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
const int INF=(1&lt;&lt;31)-1;
int main(){
    int n1,n2;
    long long a[maxn],b[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    for(int i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for(int i=0;i&lt;n2;i++){
        scanf(&quot;%lld&quot;,&amp;b[i]);
    }
    a[n1]=INF;
    b[n2]=INF;
    int midpos=(n1+n2-1)/2;
    int count=0,j=0,i=0;
    while(count&lt;midpos){
        if(a[i]&lt;b[j]) i++;
        else j++;
        count++;
    }
    if(a[i]&lt;b[j]) printf(&quot;%lld&quot;,a[i]);
    else printf(&quot;%lld&quot;,b[j]);
    return 0;
}
</code></pre>
<h3 id="a1030">A1030</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int  maxn=510;
const int INF=1000000000;
int n,m,st,destination;
int G[maxn][maxn],d[maxn],cost[maxn][maxn],pre[maxn],costtotal[maxn];
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(costtotal,costtotal+maxn,INF);
	d[s]=0;
	costtotal[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					costtotal[v]=cost[u][v]+costtotal[u];
					pre[v]=u;
				}else if(d[v]==G[u][v]+d[u]&amp;&amp;costtotal[v]&gt;costtotal[u]+cost[u][v]){
					costtotal[v]=cost[u][v]+costtotal[u];
					pre[v]=u;
				}
			}
		}
	}
}
void DFS(int v){
	if(v==st){
		printf(&quot;%d &quot;,v);
		return;
	}
    DFS(pre[v]);
    printf(&quot;%d &quot;,v);
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;destination);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=m;i++){
		int c1,c2,dis,cos;
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		scanf(&quot;%d&quot;,&amp;G[c1][c2]);
		G[c2][c1]=G[c1][c2];
		scanf(&quot;%d&quot;,&amp;cost[c1][c2]);
		cost[c2][c1]=cost[c1][c2];
	}
	dijkst(st);
	DFS(destination);
	printf(&quot;%d %d&quot;,d[destination],costtotal[destination]);
	return 0;
}
</code></pre>
<h3 id="a1031">A1031</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
int main() {
	char str[100], uu[40][40];
    scanf(&quot;%s&quot;,str); 
	int N = strlen(str);
	int n1=(N+2)/3;
	int n3=(N+2)/3;
	int n2=N-n1-n3+2;
	int pos=0;
    memset(uu,' ',sizeof(uu));
	for(int i=0;i&lt;n1-1;i++){
		uu[i][0]=str[pos++];
	} 
	for(int j=0;j&lt;n2;j++){
		uu[n1-1][j]=str[pos++];
	}
	for(int k=n3-2;k&gt;=0;k--){
		uu[k][n2-1]=str[pos++];
	}
	for(int i=0;i&lt;n1;i++){
		for(int j=0;j&lt;n2;j++){
			printf(&quot;%c&quot;,uu[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a103225-é“¾è¡¨-æ‰¾å…¬å…±åç¼€">A1032(25 é“¾è¡¨  æ‰¾å…¬å…±åç¼€)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	char data;
	bool flag;
	int next;
}list[maxn];
int main(){
	int address,begin1,begin2,n;
	scanf(&quot;%d%d%d&quot;,&amp;begin1,&amp;begin2,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot; %c %d&quot;,&amp;list[address].data,&amp;list[address].next);
	}
	while(begin1!=-1){
		list[begin1].flag=true;
		begin1=list[begin1].next;
	}
	while(begin2!=-1){
		if(list[begin2].flag==true) {
			printf(&quot;%05d&quot;,begin2);
			return 0;
		}
		begin2=list[begin2].next;
	}
	printf(&quot;-1&quot;);
	return 0;
}
</code></pre>
<h3 id="a1033">A1033</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 510;
const int INF = 1000000000;
struct node{
	double price;
	double distance;
}station[maxn];
bool cmp(node a, node b) {
	return a.distance &lt; b.distance;
}
int main() {
	double cmax, d, davg;
	int n;
	scanf(&quot;%lf%lf%lf%d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%lf%lf&quot;, &amp;station[i].price, &amp;station[i].distance);
	}
	station[n].distance = d;
	station[n].price = 0;
	sort(station, station + n + 1, cmp);
	if (station[0].distance != 0) {
		printf(&quot;The maximum travel distance = 0.00&quot;);
		return 0;
	}
	int now = 0;
	double nowtank = 0, expend = 0,  canrun = cmax * davg;
	while (now &lt; n) {
        int k=-1;
        double minprice=INF;
		for (int i = now + 1; (station[i].distance - station[now].distance) &lt;= canrun &amp;&amp; i &lt;= n; i++) {
			if (station[i].price &lt; minprice) {
				minprice = station[i].price;
				k = i;
				if (minprice &lt; station[now].price) {
					break;
				}
			}
		}
		if (k == -1) break;
		double need = (station[k].distance - station[now].distance) / davg;
		if (station[k].price &lt; station[now].price) {
			if (nowtank &lt; need) {
				expend += (need - nowtank) * station[now].price;
				nowtank = 0;
			}
			else {
				nowtank -= need;
			}
		}
		else {
			expend += (cmax - nowtank) * station[now].price;
			nowtank = cmax - need;
		}
		now = k;
	}
	if (now == n) printf(&quot;%.2f&quot;, expend);
	else printf(&quot;The maximum travel distance = %.2f&quot;, station[now].distance + canrun);
	return 0;
}
</code></pre>
<h3 id="a1034">A1034</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
const int maxn = 2100;
map&lt;string, int&gt; stringtoint;
map&lt;int, string&gt; inttostring;
map&lt;string, int&gt; gang;
int G[maxn][maxn] = { 0 }, numperson = 0, weight[maxn] = { 0 }, k;
bool vis[maxn] = { false };
void DFS(int visnow, int&amp; head, int&amp; nummember, int&amp; totalvalue) {
	nummember++;
	vis[visnow] = true;
	if (weight[visnow] &gt; weight[head]) head = visnow;
	for (int i = 0; i &lt; numperson; i++) {
		if (G[visnow][i] &gt; 0) {
			totalvalue += G[visnow][i];
			G[visnow][i] = 0;
			G[i][visnow] = 0;
            if (vis[i] == false) {
			DFS(i, head, nummember, totalvalue);
	 	  }
		}	
	}
}
void DFStrave() {
	for (int i = 0; i &lt; numperson; i++) {
		if (vis[i] == false) {
			int head = i, nummember = 0, totalvalue = 0;
			DFS(i, head, nummember, totalvalue);
			if (totalvalue &gt; k &amp;&amp; nummember &gt; 2) {
				gang[inttostring[head]] = nummember;
			}
		}
	}
}
int change(string str) {
	if (stringtoint.count(str) == 0) {
		stringtoint[str] = numperson;
		inttostring[numperson] = str;
		return numperson++;
	}
	else {
		return stringtoint[str];
	}
}
int main() {
	int n, phonetime;
	string str1, str2;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; phonetime;
		int id1 = change(str1);
		int id2 = change(str2);
		weight[id1] += phonetime;
		weight[id2] += phonetime;
		G[id1][id2] += phonetime;
		G[id2][id1] += phonetime;
	}
	DFStrave();
	cout &lt;&lt; gang.size() &lt;&lt; endl;
	for (auto it = gang.begin();it!=gang.end();it++) {
		cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a103520-å­—ç¬¦ä¸²">A1035(20 å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;string&gt; v;
	for(int j=0;j&lt;n;j++){
		bool flag=false;
		string name,password,ans;
		cin&gt;&gt;name&gt;&gt;password;
		for(int i=0;i&lt;password.length();i++){
			switch(password[i]){
				case '1':password[i]='@';flag=true;break;
				case '0':password[i]='%';flag=true;break;
				case 'l':password[i]='L';flag=true;break;
				case 'O':password[i]='o';flag=true;break;
			}
		}
		if(flag==true) v.push_back(name+&quot; &quot;+password);
	}
	if(n==1) printf(&quot;There is 1 account and no account is modified\n&quot;);
	else if(v.size()==0) printf(&quot;There are %d accounts and no account is modified\n&quot;,n);
	else{
		printf(&quot;%d\n&quot;,v.size());
		for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1036">A1036</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
struct student {
	char name[11];
	char gender;
	char id[11];
	int score;
}male,female,temp;
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	female.score = -1;
	male.score = 101;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %c %s %d&quot;, temp.name, &amp;temp.gender, temp.id, &amp;temp.score);
		if (temp.gender == 'F') {
			if (temp.score &gt; female.score) {
				female = temp;
			}
		}
		if (temp.gender == 'M') {
			if (temp.score &lt; male.score) {
				male = temp;
			}
		}
	}
	if (female.score == -1) printf(&quot;Absent\n&quot;);
	if (female.score &gt; -1) printf(&quot;%s %s\n&quot;, female.name, female.id);
	if (male.score == 101) printf(&quot;Absent\n&quot;);
	if (male.score &lt;101) printf(&quot;%s %s\n&quot;, male.name, male.id);
	if (female.score == -1 || male.score == 101) printf(&quot;NA&quot;);
	if (female.score &gt; -1 &amp;&amp; male.score &lt; 101) printf(&quot;%d&quot;, female.score - male.score);
	return 0;
}
</code></pre>
<h3 id="a103725-è´ªå¿ƒ">A1037(25 è´ªå¿ƒ)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b){return a&gt;b;}
int main(){
 	int nc,np,c,p,ans=0;
 	vector&lt;int&gt;c1,c2,p1,p2;
 	scanf(&quot;%d&quot;,&amp;nc);
 	for(int i=0;i&lt;nc;i++){
 		scanf(&quot;%d&quot;,&amp;c);
 		if(c&gt;=0) c1.push_back(c);
 		else c2.push_back(c);
	 }
	 scanf(&quot;%d&quot;,&amp;np);
	 for(int i=0;i&lt;np;i++){
 		scanf(&quot;%d&quot;,&amp;p);
 		if(p&gt;=0) p1.push_back(p);
 		else p2.push_back(p);
	 }
	 sort(c1.begin(),c1.end(),cmp);
	 sort(p1.begin(),p1.end(),cmp);
	 sort(c2.begin(),c2.end());
	 sort(p2.begin(),p2.end());
	 for(int i=0;i&lt;c1.size()&amp;&amp;i&lt;p1.size();i++)	ans+=c1[i]*p1[i];
	 for(int i=0;i&lt;c2.size()&amp;&amp;i&lt;p2.size();i++)	ans+=c2[i]*p2[i];
	 printf(&quot;%d&quot;,ans);
	 return 0;
}
</code></pre>
<h3 id="a103830-è´ªå¿ƒ-æ±‚æœ€å°å­—ç¬¦ä¸²åºåˆ—">A1038(30 è´ªå¿ƒ  æ±‚æœ€å°å­—ç¬¦ä¸²åºåˆ—)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
bool cmp(string &amp;a,string &amp;b){
	return a+b&lt;b+a;
}
int main(){
	int n;
	cin&gt;&gt;n;
	string ans;
	vector&lt;string&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i];
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++) ans+=v[i];
	while(ans[0]=='0') ans.erase(0,1);
	if(ans.size()==0) cout&lt;&lt;&quot;0&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a103925-vector">A1039(25 vector)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=26*26*26*10+10;
int getid(char *name){
	int id=0;
	for(int i=0;i&lt;3;i++) id=26*id+(name[i]-'A');
	id=id*10+(name[3]-'0');
	return id;
}
int main(){
	int n,k,courseid,num;
	char name[4];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	vector&lt;int&gt; v[maxn];
	for(int i=0;i&lt;k;i++){
		scanf(&quot;%d%d&quot;,&amp;courseid,&amp;num);
		for(int j=0;j&lt;num;j++){
			scanf(&quot;%s&quot;,name);
			v[getid(name)].push_back(courseid);
		}
	}
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s&quot;,name);
		printf(&quot;%s %d&quot;,name,v[getid(name)].size());
		sort(v[getid(name)].begin(),v[getid(name)].end());
		for(int j=0;j&lt;v[getid(name)].size();j++) printf(&quot; %d&quot;,v[getid(name)][j]);
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1040">A1040</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a104120-hash">A1041(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	int n,flag[100001]={0},j;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;v[i]);
		flag[v[i]]++;
	}
	for(j=0;j&lt;n;j++){
		if(flag[v[j]]==1) {
			cout&lt;&lt;v[j];
			break;
		}
	}
	if(j==n) cout&lt;&lt;&quot;None&quot;;
	return 0;
}
</code></pre>
<h3 id="a1042">A1042</h3>
<pre><code>#include&lt;cstdio&gt;
const int N = 55;
int main()
{
	char mp[5] = { 'S','H','C','D','J' };
	int start[N], next[N], end[N];
	int times;
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 1; i &lt;= 54; i++) {
		scanf(&quot;%d&quot;, &amp;next[i]);
	}
	for (int i = 1; i &lt;= 54; i++) {
		start[i] = i;
	}
	for (int step = 0; step &lt; times; step++) {
		for (int i = 1; i &lt;= 54; i++) {
			end[next[i]] = start[i];
		}
		for (int i = 1; i &lt;= 54; i++) {
			start[i] = end[i];
		}
	}
	for (int i = 1; i &lt;= 54; i++) {
		if (i != 1) printf(&quot; &quot;);
		start[i]--;
		printf(&quot;%c%d&quot;, mp[start[i] / 13], start[i] % 13+1);
	}
	return 0;
}
</code></pre>
<h3 id="a104325-äºŒå‰æœç´¢æ ‘çš„éå†ä¸åè½¬">A1043(25 äºŒå‰æœç´¢æ ‘çš„éå†ä¸åè½¬)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node*left,*right;
};
void insert(node*&amp;root,int data){
	if(root==NULL){
		root=new node;
		root-&gt;data=data;
		root-&gt;left=NULL;
		root-&gt;right=NULL;
		return;
	}
	if(root-&gt;data&lt;=data) insert(root-&gt;right,data);
	else if(root-&gt;data&gt;data) insert(root-&gt;left,data);
}
void preorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorder(root-&gt;left,v);
	preorder(root-&gt;right,v);
}
void preorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorderM(root-&gt;right,v);
	preorderM(root-&gt;left,v);
}
void postorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorder(root-&gt;left,v);
	postorder(root-&gt;right,v);
	v.push_back(root-&gt;data);
}
void postorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorderM(root-&gt;right,v);
	postorderM(root-&gt;left,v);
	v.push_back(root-&gt;data);
}
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n),pre,preM,post,postM;
	node*root=NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		insert(root,v[i]);
	}
	preorder(root,pre);
	preorderM(root,preM);
	if(pre==v){
		printf(&quot;YES\n&quot;);
		postorder(root,post);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,post[i]);
		}
	}else if(preM==v){
		printf(&quot;YES\n&quot;);
		postorderM(root,postM);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,postM[i]);
		}
	}else printf(&quot;NO&quot;);
	return 0;
}
</code></pre>
<h3 id="a104425-äºŒåˆ†">A1044(25 äºŒåˆ†)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; sum,ans;
int n,m;
void func(int i,int &amp;j,int &amp;tempsum){
	int low=i,high=n;
	while(low&lt;high){
		int mid=(low+high)/2;
		if(sum[mid]-sum[i-1]&gt;=m) high=mid;
		else low=mid+1;
	}
	j=high;
	tempsum=sum[j]-sum[i-1];
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	sum.resize(n+1);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
	}
	int minans=sum[n];
	for(int i=1;i&lt;=n;i++){
		int j,tempsum;
		func(i,j,tempsum);
		if(tempsum&gt;minans) continue;
		if(tempsum&gt;=m){
			if(tempsum&lt;minans){
				ans.clear();
				minans=tempsum;
			}
			ans.push_back(i);
			ans.push_back(j);
		}
	}
	for(int i=0;i&lt;ans.size();i+=2)	printf(&quot;%d-%d\n&quot;,ans[i],ans[i+1]);
	return 0;
}
</code></pre>
<h3 id="a1045">A1045</h3>
<pre><code>æ–¹æ³•ä¸€:æœ€é•¿ä¸ä¸‹é™å­åºåˆ—LIS
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
		ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
æ–¹æ³•äºŒ:æœ€é•¿å…¬å…±å­åºåˆ—
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;
    for(int i=0;i&lt;L;i++) dp[0][i]=0;
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
<h3 id="a1046">A1046</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int dis[maxn], A[maxn];
int main() {
	int n,times,left,right,sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		sum += A[i];
        dis[i] = sum;
	}
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 0; i &lt; times; i++) {
		scanf(&quot;%d%d&quot;, &amp;left, &amp;right);
		if (left &gt; right)  swap(left, right);
		int distance = dis[right - 1] - dis[left - 1];
			printf(&quot;%d\n&quot;, min(distance,sum-distance));
	}
	return 0;
}
</code></pre>
<h3 id="a104725-vector">A1047(25 vector)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[40010][5];
vector&lt;int&gt; v[2510];
bool cmp(int a,int b){
	return strcmp(name[a],name[b])&lt;0;
}
int main(){
	int n,k,c,courseid;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s%d&quot;,name[i],&amp;c);
		while(c--){
			scanf(&quot;%d&quot;,&amp;courseid);
			v[courseid].push_back(i);
		}
	}
	for(int i=1;i&lt;=k;i++){
		printf(&quot;%d %d\n&quot;,i,v[i].size());
		sort(v[i].begin(),v[i].end(),cmp);
		for(int j=0;j&lt;v[i].size();j++) printf(&quot;%s\n&quot;,name[v[i][j]]);
	}
	return 0;
}
</code></pre>
<h3 id="a104825">A1048(25 )</h3>
<pre><code>1.å“ˆå¸Œæ•£åˆ—è§£æ³•
#include&lt;cstdio&gt;
int main(){
	int n,pay,flag[100010]={0},a[100010];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;pay);
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for(int i=1;i&lt;pay;i++){
		if(flag[i]&gt;0&amp;&amp;flag[pay-i]&gt;0){
			if((i==pay-i&amp;&amp;flag[i]&gt;1)||i!=pay-i){
				printf(&quot;%d %d&quot;,i,pay-i);
			    return 0;
			}
		}
	} 
	printf(&quot;No Solution&quot;);
	return 0;
}


2.äºŒåˆ†æ³•è§£æ³•
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num, num + n);
	int j,i;
	for ( i = 0; i &lt; n; i++) {
		 j = lower_bound(num + i, num +n, m - num[i]) - num;
		if ( (num[j] + num[i] == m&amp;&amp;j!=i)||(num[i]==num[i+1]&amp;&amp;num[i]*2==m)) {
			printf(&quot;%d %d&quot;, num[i], num[j]);
			break;
		}
	}
	if (i &gt;= n) printf(&quot;No Solution&quot;);
	return 0;
}

3.two points
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int a[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	sort(a, a + n);
	int j=n-1,i=0;
    while(i&lt;j){
        if(a[i]+a[j]==m){
            printf(&quot;%d %d&quot;,a[i],a[j]);
            return 0;
        }
        else if(a[i]+a[j]&gt;m) j--;
        else i++;
    }
	printf(&quot;No Solution&quot;);
	return 0;
}
</code></pre>
<h3 id="a1049">A1049</h3>
<pre><code>#include &lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
int main() {
	int n,ans=0,a=1,index=0;
	cin &gt;&gt; n;
	int left, now, right;
	while (n / a != 0) {
		left = n / (a * 10);
		right = n % a;
		now = n/a%10;
		if (now == 0) ans += left * pow(10, index++);
		else if(now == 1) ans += left * pow(10, index++) + 1+right;
		else ans += (left + 1) * pow(10, index++);
		a *= 10;
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h3 id="a105020-hash">A1050(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	vector&lt;int&gt; v(128,0);
	getline(cin,s1);
	getline(cin,s2);
	for(int i=0;i&lt;s2.length();i++) v[s2[i]]++;
	for(int i=0;i&lt;s1.length();i++){
		if(v[s1[i]]==0) ans+=s1[i];
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a105125-æ ˆ">A1051(25 æ ˆ)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k);
	while(k--){
		vector&lt;int&gt; v(n+1);
		stack&lt;int&gt; st;
		bool flag=true;
		int current=1;
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
		for(int i=1;i&lt;=n;i++){
			st.push(i);
			if(st.size()&gt;m){
				flag=false;
				break;
			}
			while(!st.empty()&amp;&amp;st.top()==v[current]){
				st.pop();
				current++;
			}
		}
		if(current!=n+1) flag=false;
		if(flag) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a105225-é“¾è¡¨æŒ‰keyæ’åº">A1052(25 é“¾è¡¨æŒ‰keyæ’åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=100010;
struct node{
	int data,address,next;
}list[maxn]; 
bool cmp(node a,node b){return a.data&lt;b.data;}
int main(){
	int n,begin,address;
	vector&lt;node&gt; v;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;begin);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		v.push_back(list[begin]);
		begin=list[begin].next;
	}
    if(v.size()==0) printf(&quot;0 -1&quot;);
    else{
        sort(v.begin(),v.end(),cmp);
	    printf(&quot;%d %05d\n&quot;,v.size(),v[0].address);
	    for(int i=0;i&lt;v.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,v[i].address,v[i].data,v[i+1].address);
	    printf(&quot;%05d %d -1\n&quot;,v[v.size()-1].address,v[v.size()-1].data);
    }
    return 0;
}
</code></pre>
<h3 id="a105330-è¾“å‡ºæƒå€¼æ€»å’ŒåŒä¸ºç»™å®šå€¼çš„è·¯å¾„dfs">A1053(30 è¾“å‡ºæƒå€¼æ€»å’ŒåŒä¸ºç»™å®šå€¼çš„è·¯å¾„(dfs))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,s,sum=0,path[101];
struct node{
	int w;
	vector&lt;int&gt; child;
}tree[101];
bool cmp(int a,int b){return tree[a].w&gt;tree[b].w;}
void dfs(int index,int nodenum,int sum){
	if(sum&gt;s) return;
	if(sum==s){
		if(tree[index].child.size()!=0) return;
		for(int i=0;i&lt;nodenum;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,tree[path[i]].w);
		}
		printf(&quot;\n&quot;);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++){
		int child=tree[index].child[i];
		path[nodenum]=child;
		dfs(child,nodenum+1,sum+tree[child].w);
	} 
}
int main(){
	int id,k,c;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;tree[i].w);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;c);
			tree[id].child.push_back(c);
		}
		sort(tree[id].child.begin(),tree[id].child.end(),cmp);
	}
	path[0]=0;
	dfs(0,1,tree[0].w);
	return 0;
}
</code></pre>
<h3 id="a105420-map">A1054(20 map)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int m,n,temp;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	map&lt;int,int&gt; mp;
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;m;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			mp[temp]++;
		}
	}
	int times=-1,ans;
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;times){
			times=it-&gt;second;
			ans=it-&gt;first;
		} 
	} 
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a105525-æŒ‰æ¡ä»¶æŸ¥æ‰¾å¹¶æ’åºè¾“å‡º">A1055(25 æŒ‰æ¡ä»¶æŸ¥æ‰¾å¹¶æ’åºè¾“å‡º)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	char name[10];
	int age,worth;
};
bool cmp(node a,node b){
	if(a.worth!=b.worth) return a.worth&gt;b.worth;
	else if(a.age!=b.age) return a.age&lt;b.age;
	else return strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,m,k,amin,amax;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; t(n),v;
    vector&lt;int&gt; book(201,0);
	for(int i=0;i&lt;n;i++)  scanf(&quot;%s%d%d&quot;,t[i].name,&amp;t[i].age,&amp;t[i].worth);
    sort(t.begin(),t.end(),cmp);   
    for(int i=0;i&lt;n;i++){
        if(book[t[i].age]&lt;100){
            v.push_back(t[i]);
            book[t[i].age]++;
        }
    }
	for(int i=1;i&lt;=m;i++) {
		printf(&quot;Case #%d:\n&quot;,i);
		vector&lt;node&gt; ans;
        scanf(&quot;%d%d%d&quot;,&amp;k,&amp;amin,&amp;amax);
		for(int j=0;j&lt;v.size();j++) {
			if(v[j].age&gt;=amin&amp;&amp;v[j].age&lt;=amax) ans.push_back(v[j]);
		}
		if(ans.size()==0) printf(&quot;None\n&quot;);
		else if(k&gt;=ans.size()){
			for(int j=0;j&lt;ans.size();j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}else if(k&lt;ans.size())  {
			for(int j=0;j&lt;k;j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}   
	}
	return 0;
} 
</code></pre>
<h3 id="a105625-queueé˜Ÿåˆ—">A1056(25 queueé˜Ÿåˆ—)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int w,rank;
};
int main(){
	int np,ng,orderid;
	queue&lt;int&gt; q;
	scanf(&quot;%d%d&quot;,&amp;np,&amp;ng);
	vector&lt;node&gt; v(np);
	for(int i=0;i&lt;np;i++) scanf(&quot;%d&quot;,&amp;v[i].w);
	for(int i=0;i&lt;np;i++) {
		scanf(&quot;%d&quot;,&amp;orderid);
		q.push(orderid);
	}
	int temp=np,group;
	while(q.size()!=1){
		if(temp%ng==0) group=temp/ng;
		else group=temp/ng+1;
		for(int i=0;i&lt;group;i++){
			int k=q.front();
			for(int j=1;j&lt;=ng;j++){
				if(i*ng+j&gt;temp) break;
				int front=q.front();
				if(v[front].w&gt;v[k].w) k=front;
				v[front].rank=group+1;
				q.pop();
			}
			q.push(k); 
		}
		temp=group; 
	}
	v[q.front()].rank=1;
	for(int i=0;i&lt;np;i++){
		if(i!=0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,v[i].rank);
	}
	return 0;
} 
</code></pre>
<h3 id="a105730-åˆ†å—-æ ‘çŠ¶æ•°ç»„">A1057(30 åˆ†å—ã€æ ‘çŠ¶æ•°ç»„)</h3>
<pre><code>1.åˆ†å—
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int table[100010],block[317];
stack&lt;int&gt; st;
void Peekmedian(int x) {
	int sum = 0, block_id = 0;
	while (sum + block[block_id] &lt; x) {
		sum += block[block_id++];
	}
	int num = block_id * 316;
	while (sum + table[num] &lt; x) sum+=table[num++];
	printf(&quot;%d\n&quot;, num);
}
void Push(int x) {
	st.push(x);
	table[x]++;
	block[x / 316]++;
}
void Pop() {
	int top = st.top();
	st.pop();
	table[top]--;
	block[top / 316]--;
	printf(&quot;%d\n&quot;, top);
}
int main() {
	int n, temp;
	char cmd[15];
	scanf(&quot;%d&quot;, &amp;n);
	memset(table, 0, sizeof(table));
	memset(block, 0, sizeof(block));
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, cmd);
		if (strcmp(cmd, &quot;Pop&quot;)==0) {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else Pop();
		}
		else if (strcmp(cmd, &quot;Push&quot;)==0) {
			scanf(&quot;%d&quot;, &amp;temp);
			Push(temp);
		}
		else {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else {
				int k = st.size();
				if (k % 2 == 0) k = k / 2;
				else k = k / 2 + 1;
				Peekmedian(k);
			}
		}
	}
	return 0;
}
2.æ ‘çŠ¶æ•°ç»„

</code></pre>
<h3 id="a105820-æ°´é¢˜">A1058(20 æ°´é¢˜)</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	int a,b,c,d,e,f,ans[3];
	scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);
	ans[2]=(c+f)%29;
	ans[1]=(b+e+(c+f)/29)%17;
	ans[0]=a+d+(b+e+(c+f)/29)/17;
	for(int i=0;i&lt;3;i++){
		if(i!=0) printf(&quot;.&quot;);
		printf(&quot;%d&quot;,ans[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a1059">A1059</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
const int maxn = 100010;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
struct factor {
	int x, exp;
}fac[10];
int main() {
	find_prime();
	int n,num=0;
	scanf(&quot;%d&quot;, &amp;n);
	int sqr = (int)sqrt(1.0 * n);
	if (n == 1) printf(&quot;1=1&quot;);
	else {
		printf(&quot;%d=&quot;, n);
		for (int i = 0; i &lt; pnum &amp;&amp; prime[i] &lt;= sqr; i++) {
			if (n % prime[i] == 0) {
				fac[num].x = prime[i];
				fac[num].exp = 0;
				while (n % prime[i] == 0) {
					fac[num].exp++;
					n /= prime[i];
				}
				num++;
			}
			if (n == 1) break;
		}
		if (n != 1) {
			fac[num].x = n;
			fac[num++].exp = 1;
		}
		for (int i = 0; i &lt; num; i++) {
			if (i &gt; 0) printf(&quot;*&quot;);
			printf(&quot;%d&quot;, fac[i].x);
			if (fac[i].exp &gt; 1) printf(&quot;^%d&quot;, fac[i].exp);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a106025-å­—ç¬¦ä¸²-ç§‘å­¦è®¡æ•°æ³•">A1060(25 å­—ç¬¦ä¸² ç§‘å­¦è®¡æ•°æ³•)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int n;
string deal(string s,int &amp;e){
	int k=0;
	while(s[0]=='0'&amp;&amp;s.length()&gt;0) s.erase(s.begin());//å»é™¤å‰å¯¼0 
	if(s[0]=='.'){//è‹¥å»é™¤åæ˜¯å°æ•°ç‚¹ï¼Œè¯´æ˜æ˜¯å°äº1çš„æ•° 
		s.erase(s.begin());
		while(s[0]=='0'&amp;&amp;s.length()&gt;0) {
			s.erase(s.begin());//å»é™¤å°æ•°ç‚¹åéé›¶ä½å‰çš„æ‰€æœ‰0 
			e--;
		}
	}else{
		while(s[k]!='.'&amp;&amp;k&lt;s.length()){//å¯»æ‰¾å°æ•°ç‚¹ 
			k++;
			e++;
		}
		if(k&lt;s.length()) s.erase(s.begin()+k);//åˆ é™¤å°æ•°ç‚¹ 
	}
	if(s.length()==0) e=0;
	int num=0;
	k=0;
	string ans;
	while(num&lt;n){
		if(k&lt;s.length()) ans+=s[k++];
		else ans+='0';
		num++;
	}	
	return ans; 
}		
int main(){
	string s1,s2,s3,s4;
	cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;
	int e1=0,e2=0;
	s3=deal(s1,e1);
	s4=deal(s2,e2);
	if(s3==s4&amp;&amp;e1==e2) cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1;	
	else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1&lt;&lt;&quot; 0.&quot;&lt;&lt;s4&lt;&lt;&quot;*10^&quot;&lt;&lt;e2;
	return 0;
}
</code></pre>
<h3 id="a106120-å­—ç¬¦ä¸²">A1061(20 å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	int i=0,pos=0;
	char ans[2];
	string a,b,c,d;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;(a[i]&gt;='A'&amp;&amp;a[i]&lt;='G')){
			ans[0]=a[i];
			break;
		}
		i++;
	}
	++i;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;((a[i]&gt;='A'&amp;&amp;a[i]&lt;='N')||isdigit(a[i]))){
			ans[1]=a[i];
			break;
		}
		i++;
	}
	while(pos&lt;c.length()&amp;&amp;pos&lt;d.length()){
		if(c[pos]==d[pos]&amp;&amp;isalpha(c[pos])) break;
		pos++;
	}
	string weekday[7]={&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;};
	printf(&quot;%s %02d:%02d&quot;,weekday[ans[0]-'A'].c_str(),isdigit(ans[1])?ans[1]-'0':ans[1]-'A'+10,pos);
	return 0;
} 
</code></pre>
<h3 id="a1062">A1062</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
struct node{
	int num;
	int de,cai,rank;
}temp;
bool cmp( node a,node b){
	if(a.rank!=b.rank) return a.rank&lt;b.rank;
	else if((a.de+a.cai)!=(b.de+b.cai)) return (a.de+a.cai)&gt;(b.de+b.cai);
	else if(a.de!=b.de) return a.de&gt;b.de;
	else return a.num&lt;b.num;
}
int main(){
	int n,L,H;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;H);
	vector&lt;node&gt; v;
	for(int i=0;i&lt;n;i++){
		int id,a,b,rank;
		scanf(&quot;%d%d%d&quot;,&amp;id,&amp;a,&amp;b);
		if(a&lt;L||b&lt;L) continue;
		if(a&gt;=H&amp;&amp;b&gt;=H) rank=1;
		else if(a&gt;=H&amp;&amp;b&lt;H) rank=2;
		else if(a&lt;H&amp;&amp;b&lt;H&amp;&amp;a&gt;=b) rank=3;
		else rank=4;
		v.push_back(node{id,a,b,rank});
	}
	sort(v.begin(),v.end(),cmp);
	printf(&quot;%d\n&quot;,v.size());
	for(int i=0;i&lt;v.size();i++) printf(&quot;%08d %d %d\n&quot;,v[i].num,v[i].de,v[i].cai);
	return 0;
} 
</code></pre>
<h3 id="a106325-set">A1063(25 set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int maxn = 51;
set&lt;int&gt; v[maxn];
int main() {
	int n,m,temp,k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[i].insert(temp);
		}
	}
	int a, b;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		int nc=0, nt=v[b-1].size();
		for (auto it = v[a - 1].begin(); it != v[a - 1].end(); it++) {
			if (v[b - 1].find(*it) != v[b - 1].end())  nc++;
			else nt++;
		}
		printf(&quot;%.1f%%\n&quot;, (nc * 100.0) / nt);
	}
}
</code></pre>
<h3 id="a106430-å®Œå…¨äºŒå‰æ ‘ä¸­åºéå†å»ºæ ‘">A1064(30 å®Œå…¨äºŒå‰æ ‘(ä¸­åºéå†å»ºæ ‘))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1001;
int CBT[maxn],a[maxn],n,index=0;
void inorder(int root){
	if(root&gt;n) return;
	inorder(root*2);
	CBT[root]=a[index++];
	inorder(root*2+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(1);
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,CBT[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a1065">A1065</h3>
<pre><code>#include&lt;cstdio&gt;
int main() {
	long long a, b, c;
	int n,times=1;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
		bool flag;
		long long sum = a + b;
		if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0)
			flag = true;
		else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)
			flag = false;
		else if (sum &gt; c)
			flag = true;
		else flag = false;
		if (flag == true)
			printf(&quot;Case #%d:true&quot;, times++);
		if (flag == false)
			printf(&quot;Case #%d:false&quot;, times++);
	}
	return 0;
}
</code></pre>
<h3 id="a106625-å»ºç«‹å¹³è¡¡äºŒå‰æ ‘">A1066(25 å»ºç«‹å¹³è¡¡äºŒå‰æ ‘)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v,height;
	node*left,*right;
};
node* newnode(int v){
	node* Node=new node;
	Node-&gt;v=v;
	Node-&gt;height=1;
	Node-&gt;left=Node-&gt;right=NULL;
	return Node;
}
int getheight(node*root){
	if(root==NULL) return 0;
	return root-&gt;height; 
}
void updateheight(node *root){
	root-&gt;height=max(getheight(root-&gt;right),getheight(root-&gt;left))+1;
}
int getbalance(node* root){
	return getheight(root-&gt;left)-getheight(root-&gt;right);
}
void L(node*&amp;root){
	node*temp=root-&gt;right;
	root-&gt;right=temp-&gt;left;
	temp-&gt;left=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void R(node*&amp;root){
	node*temp=root-&gt;left;
	root-&gt;left=temp-&gt;right;
	temp-&gt;right=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void insert(node*&amp;root,int v){
	if(root==NULL){
		root=newnode(v);
		return;
	}
	if(v&lt;root-&gt;v){
		insert(root-&gt;left,v);
		updateheight(root);
		if(getbalance(root)==2){
			if(getbalance(root-&gt;left)==1) R(root);
			else if(getbalance(root-&gt;left)==-1){
				L(root-&gt;left);
				R(root);
			}
		}
	}
	else{
		insert(root-&gt;right,v);
		updateheight(root);
		if(getbalance(root)==-2){
			if(getbalance(root-&gt;right)==-1) L(root);
			else if(getbalance(root-&gt;right)==1){
				R(root-&gt;right);
				L(root);
			}
		}
	}
}
int main(){
	int n,temp;
	node* root=NULL;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		insert(root,temp);
	}
	printf(&quot;%d&quot;,root-&gt;v);
	return 0;
}
</code></pre>
<h3 id="a106725-è´ªå¿ƒ-swapæ’åºæ±‚æœ€å°äº¤æ¢æ¬¡æ•°">A1067(25  è´ªå¿ƒ swapæ’åºï¼Œæ±‚æœ€å°äº¤æ¢æ¬¡æ•°)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n,t,cnt=0,a[100001];
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;t;
		a[t]=i;
	}
	for(int i=1;i&lt;n;i++){
		while(a[0]!=0){
			swap(a[0],a[a[0]]);
			cnt++;
		}
		if(a[i]!=i){
			swap(a[i],a[0]);
			cnt++;
		}
	} 
	cout&lt;&lt;cnt;
	return 0;
}
</code></pre>
<h3 id="a1068">A1068</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1069">A1069</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
bool cmp(int a, int b) {
	return a &gt; b;
}
int a[4];
int to_number(int a[]) {
	int res = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3] * 1;
	return res;
}
void to_arry(int num) {
	for (int j = 0; j &lt; 4; j++) {
		a[j] = num % 10;
		num = num / 10;
	}
}
int main() {
	int big, small, ans;
	scanf(&quot;%d&quot;, &amp;ans);
	do {
		to_arry(ans);
		sort(a, a + 4);
		small = to_number(a);
		sort(a, a + 4, cmp);
		big = to_number(a);
		ans = big - small;
		printf(&quot;%04d - %04d = %04d\n&quot;, big, small, ans);
		
	} while (ans &gt; 0 &amp;&amp; ans != 6174);
	return 0;
}
</code></pre>
<h3 id="a107025-è´ªå¿ƒ">A1070(25 è´ªå¿ƒ)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	double inventory,price;
};
bool cmp(node &amp;a,node &amp;b){ return a.price&gt;b.price;};
int main(){
	int n,D;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;D);
	double prices,profit=0.0;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%lf&quot;,&amp;v[i].inventory);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%lf&quot;,&amp;prices);
		v[i].price=prices/v[i].inventory;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++){
		if(v[i].inventory&gt;=D){
			profit+=D*v[i].price;
			break;
		}else{
			profit+=v[i].inventory*v[i].price;
			D-=v[i].inventory;
		}
	}
	printf(&quot;%.2f&quot;,profit);
	return 0;
}
</code></pre>
<h3 id="a107125-map-å­—ç¬¦ä¸²">A1071(25 map  å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	map&lt;string,int&gt; mp;
	string s,temp,ans;
	getline(cin,s);
	int maxtimes=-1;
	for(int i=0;i&lt;s.length();i++){
		if(isalnum(s[i])){
			if(isupper(s[i])) s[i]=tolower(s[i]);
			temp+=s[i];
		}
		if(!isalnum(s[i])||i==s.length()-1){
			if(!temp.empty()) mp[temp]++;
			temp.clear();
		}
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;maxtimes) {
			ans=it-&gt;first;
			maxtimes=it-&gt;second;
		}
	}
	cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;maxtimes;
	return 0;
}
</code></pre>
<h3 id="a1072">A1072</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1016;
const int INF=1000000000;
bool vis[maxn]={false};
int n,m,k,ds,G[maxn][maxn],d[maxn];
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(vis,vis+maxn,false);
	d[s]=0;
    for(int i=1;i&lt;=n+m;i++){
    	int u=-1,MIN=INF;
    	for(int j=1;j&lt;=n+m;j++){
    		if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
    			u=j;
			    MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=1;v&lt;=n+m;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
				}
			}
		}
	}	
}
int getid(char str[]){
	int i=0,len=strlen(str),id=0;
	while(i&lt;len){
		if(str[i]!='G'){
			id=id*10+(str[i]-'0');
		}
		i++;
	}
	if(str[0]=='G') return id+n;
	else return id;
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;ds);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;k;i++){
		char str1[6],str2[6];
		int distance,id1,id2;;
		scanf(&quot;%s %s %d&quot;,str1,str2,&amp;distance);
		id1=getid(str1);
		id2=getid(str2);
		G[id1][id2]=distance;
		G[id2][id1]=G[id1][id2];
	}
	double ansavg=INF,ansdis=-1;
	vector&lt;int&gt; ansid;
	for(int i=n+1;i&lt;=n+m;i++){
		dijkst(i);
		double mindis=INF,avgdis=0.0;
		int j;
		for(j=1;j&lt;=n;j++){
			if(d[j]&gt;ds) break;
			if(d[j]&lt;mindis){
				mindis=d[j];
			}
			avgdis+=d[j]*1.0/n;
		}
		if(j&lt;n+1) continue;
		if(mindis&gt;ansdis){
			ansdis=mindis;
			ansavg=avgdis;
			ansid.clear();
			ansid.push_back(i);
		}else if(mindis==ansdis){
			if(ansavg&gt;avgdis){
				ansavg=avgdis;
				ansid.clear();
			    ansid.push_back(i);
			} 
			else if(ansavg==avgdis) ansid.push_back(i);
		}
	}
	if(ansid.size()==0) printf(&quot;No Solution&quot;);
	else{
		printf(&quot;G%d\n&quot;,ansid[0]-n);
		printf(&quot;%.1f %.1f&quot;,ansdis,ansavg);
	}
	return 0;
}
</code></pre>
<h3 id="a1073-ç§‘å­¦è®¡æ•°æ³•">A1073 ç§‘å­¦è®¡æ•°æ³•</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	string s,t;
	int n,i=0;
	cin&gt;&gt;s;
	while(s[i]!='E') i++;
	t=s.substr(1,i-1);
	n=stoi(s.substr(i+1,s.length()-i-1));
	if(s[0]=='-') cout&lt;&lt;&quot;-&quot;;
	if(n&lt;0){
		cout&lt;&lt;&quot;0.&quot;;
		for(int j=0;j&lt;abs(n)-1;j++) cout&lt;&lt;&quot;0&quot;;
		for(int j=0;j&lt;t.size();j++) 
		    if(t[j]!='.') cout&lt;&lt;t[j];
	}else{
		cout&lt;&lt;t[0];
		int cnt,j;
		for(j=2,cnt=0;j&lt;t.length()&amp;&amp;cnt&lt;n;j++,cnt++) cout&lt;&lt;t[j];
		if(j==t.length()) {
			for(int k=0;k&lt;n-cnt;k++) cout&lt;&lt;&quot;0&quot;;
		} else{
			cout&lt;&lt;&quot;.&quot;;
			for(int k=j;k&lt;t.size();k++) cout&lt;&lt;t[k];
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107425-åè½¬é“¾è¡¨">A1074(25 åè½¬é“¾è¡¨)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	int address,data,next;
	int order;
}list[maxn];
bool cmp(node &amp;a,node &amp;b){
	return a.order&lt;b.order;
}
int main(){
	int begin,n,k,address,cnt=0;
	for(int i=0;i&lt;maxn;i++) list[i].order=maxn;
	scanf(&quot;%d%d%d&quot;,&amp;begin,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	int p=begin;
	while(p!=-1){
		list[p].order=cnt++;
		p=list[p].next;
	}
	sort(list,list+maxn,cmp);
	for(int i=0;i&lt;cnt/k;i++){
		for(int j=(i+1)*k-1;j&gt;i*k;j--){
			printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j-1].address);
		}
		printf(&quot;%05d %d &quot;,list[i*k].address,list[i*k].data);
		if(i&lt;cnt/k-1) printf(&quot;%05d\n&quot;,list[(i+2)*k-1].address);
		else{
			if(cnt%k==0) printf(&quot;-1\n&quot;);
			else{
				printf(&quot;%05d\n&quot;,list[(i+1)*k].address);
				for(int j=(i+1)*k;j&lt;cnt-1;j++){
				    printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j+1].address);
				}
				printf(&quot;%05d %d -1&quot;,list[cnt-1].address,list[cnt-1].data);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107525-æ’åº">A1075(25 æ’åº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int rank,id,total=0;
	vector&lt;int&gt; score;
	int passnum=0;
	bool isshown=false;
}; 
bool cmp(node a,node b){
	if(a.total!=b.total) return a.total&gt;b.total;
	else if(a.passnum!=b.passnum) return a.passnum&gt;b.passnum;
	else return a.id&lt;b.id;
}
int main(){
	int n,k,m,id,index,grade;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);
	vector&lt;node&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) v[i].score.resize(k+1,-1);
	vector&lt;int&gt; p(k+1);
	for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;p[i]);
	for(int i=0;i&lt;m;i++){
	    scanf(&quot;%d%d%d&quot;,&amp;id,&amp;index,&amp;grade);
	    v[id].id=id;
	    v[id].score[index]=max(grade, v[id].score[index]);
	    if(grade!=-1) v[id].isshown=true;
	    else if(v[id].score[index]==-1) v[id].score[index]=-2;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=k;j++){
			if(v[i].score[j]!=-1&amp;&amp;v[i].score[j]!=-2) v[i].total+=v[i].score[j];
			if(v[i].score[j]==p[j]) v[i].passnum++;
		}
	}
	sort(v.begin()+1,v.end(),cmp);
	v[1].rank=1;
	for(int i=2;i&lt;=n;i++){
		if(v[i].total==v[i-1].total) v[i].rank=v[i-1].rank;
		else v[i].rank=i;
	}
	for(int i=1;i&lt;=n;i++){
		if(v[i].isshown==true){
			printf(&quot;%d %05d %d&quot;,v[i].rank,v[i].id,v[i].total);
			for(int j=1;j&lt;=k;j++) {
				if(v[i].score[j]==-1) printf(&quot; -&quot;);
				else if(v[i].score[j]==-2) printf(&quot; 0&quot;);
				else printf(&quot; %d&quot;,v[i].score[j]);
			}
			printf(&quot;\n&quot;);
		}
	}
	return 0;
} 
</code></pre>
<h3 id="a1076">A1076</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1010;
bool inq[maxn]={false};
struct node{
	int id;
	int layer;
};
vector&lt;node&gt; adj[maxn];
int BFS(int s,int L){
	int numforward=0;
	queue&lt;node&gt; q;
	node start;
	start.id=s;
	start.layer=0;
	q.push(start);
	inq[start.id]=true;
	while(!q.empty()){
		node now;
		now.id=q.front().id;
		now.layer=q.front().layer;
		q.pop();
		for(int i=0;i&lt;adj[now.id].size();i++){
			node next=adj[now.id][i];
			next.layer=now.layer+1;
			if(inq[next.id]==false&amp;&amp;next.layer&lt;=L){
				q.push(next);
				inq[next.id]=true;
				numforward++;
			}
		}
	}
	return numforward;
}
int main(){
	int n,L,followid,m,k,userid,numforward=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;L);
	for(int i=1;i&lt;=n;i++){
		node user;
		user.id=i;
		scanf(&quot;%d&quot;,&amp;m);
		while(m--){
			scanf(&quot;%d&quot;,&amp;followid);
			adj[followid].push_back(user);
		}
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;userid);
		fill(inq,inq+maxn,false);
		numforward=BFS(userid,L);
		printf(&quot;%d\n&quot;,numforward);
	}
	return 0;
}
</code></pre>
<h3 id="a107720-å¤šä¸ªå­—ç¬¦ä¸²æ‰¾å…¬å…±åç¼€">A1077(20  å¤šä¸ªå­—ç¬¦ä¸²æ‰¾å…¬å…±åç¼€)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	scanf(&quot;%d\n&quot;,&amp;n);
	string ans;
	int minlen;
	for(int i=0;i&lt;n;i++){
		string s;
		getline(cin,s);
		reverse(s.begin(),s.end());
		if(i==0){
			ans=s;
			minlen=ans.length();
		}else{
			int len=s.length();
			minlen=min(minlen,len);
			for(int j=0;j&lt;minlen;j++){
				if(s[j]!=ans[j]) {
					ans=s.substr(0,j);
					break;
				}
			}
		}
	}
	reverse(ans.begin(),ans.end());
	if(ans.size()==0) cout&lt;&lt;&quot;nai&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1078">A1078</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
bool hashtable[100010] = { 0 };
int main() {
	int tsize, n, a;
	scanf(&quot;%d%d&quot;, &amp;tsize, &amp;n);
    while(!isprime(tsize)){
        tsize++;
    }
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a);
		int m = a % tsize;
		if (hashtable[m] == false) {
			hashtable[m] = true;
			if (i == 0) printf(&quot;%d&quot;, m);
			else printf(&quot; %d&quot;, m);
		}
		else {
            int step;
			for (step = 1; step &lt; tsize; step++) {
                m=(a+step*step)%tsize;
				if (hashtable[m] == false) {
					hashtable[m] =true;
					printf(&quot; %d&quot;,m);
					break;
				}
			}
			if (step == tsize) {
				printf(&quot; -&quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107925-æ ‘çš„dfs">A1079(25 æ ‘çš„dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n;
double p,r,ans=0.0;
struct node{
	int data;
	vector&lt;int&gt; child;
}tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].child.size()==0){
		ans+=tree[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++) dfs(tree[index].child[i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int num,root,ischild[100010]={0},temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;num);
		if(num==0){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].data=temp;
		}else{
			for(int j=0;j&lt;num;j++) {
				scanf(&quot;%d&quot;,&amp;temp);
				ischild[temp]=1;
				tree[i].child.push_back(temp);
			}	
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		}
	}
	dfs(root,0);
	printf(&quot;%.1f&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a108030-æ’åº">A1080(30 æ’åº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int ge,gi,sum,rank,id;
	vector&lt;int&gt; choice;
};
bool cmp1(node&amp; a,node&amp; b){
	if(a.sum!=b.sum) return a.sum&gt;b.sum;
	else return a.ge&gt;b.ge;
}
bool cmp2(node&amp; a,node&amp; b){
	return a.id&lt;b.id;
}
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	vector&lt;int&gt; sch_need(m);
	vector&lt;node&gt; stu(n);
	for(int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;sch_need[i]);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;stu[i].ge,&amp;stu[i].gi);
		stu[i].sum=stu[i].ge+stu[i].gi;
		stu[i].id=i;
		stu[i].choice.resize(k);
		for(int j=0;j&lt;k;j++) scanf(&quot;%d&quot;,&amp;stu[i].choice[j]);
	}
	sort(stu.begin(),stu.end(),cmp1);
	vector&lt;node&gt; ans[m];
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;k;j++){
			int temp=stu[i].choice[j];
			if(ans[temp].size()&lt;sch_need[temp]||
			(ans[temp][ans[temp].size()-1].sum==stu[i].sum&amp;&amp;ans[temp][ans[temp].size()-1].ge==stu[i].ge)) {
				ans[temp].push_back(stu[i]);
				break;
			}
		}
	}
	for(int i=0;i&lt;m;i++){
		sort(ans[i].begin(),ans[i].end(),cmp2);
		for(int j=0;j&lt;ans[i].size();j++){
			if(j!=0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,ans[i][j].id);
		}
		printf(&quot;\n&quot;);	
	}
	return 0;
}
</code></pre>
<h3 id="a1081">A1081</h3>
<pre><code>#include&lt;cstdio&gt;
long long gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	long long a2 = 0, b2 = 1,gcdvalue;
	for (int i = 0; i &lt; n; i++) {
		long long a, b;
		scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);
		gcdvalue = gcd(a, b);
		a /= gcdvalue;
		b /= gcdvalue;
		a2 = a * b2 + b * a2;
		b2 = b * b2;
		gcdvalue = gcd(a2, b2);
		a2 /= gcdvalue;
		b2 /= gcdvalue;
	}
	long long integer = a2 / b2;
	a2 = a2 - integer * b2;
	if (integer != 0) {
		printf(&quot;%lld&quot;, integer);
		if (a2 &gt; 0) printf(&quot; %lld/%lld&quot;,a2,b2);
		else if (a2 &lt; 0) printf(&quot; %lld/%lld&quot;, -a2, b2);
	}
	if (integer == 0 &amp;&amp; a2 != 0) printf(&quot;%lld/%lld&quot;, a2, b2);
	if (integer == 0 &amp;&amp; a2 == 0) printf(&quot;0&quot;);
	return 0;
}
</code></pre>
<h3 id="a108225-åˆ†æ®µå¤„ç†å­—ç¬¦ä¸²">A1082(25 åˆ†æ®µå¤„ç†å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n;
	cin&gt;&gt;n;
	int len=n.length();
	int left=0,right=len-1;
	string num[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};
	string wei[5]={&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Yi&quot;};
	if(n[0]=='-') {
		cout&lt;&lt;&quot;Fu&quot;;
		left++;
	}
	while(left+4&lt;=right){
		right-=4;
	}
	while(left&lt;len){
		bool flag=false;
		bool hasprint=false;
		while(left&lt;=right){
			if(left&gt;0&amp;&amp;n[left]=='0') flag=true;
			else{
				if(flag==true){
					cout&lt;&lt;&quot; &quot;&lt;&lt;&quot;ling&quot;;
					flag=false;
				}
				if(left&gt;0) cout&lt;&lt;&quot; &quot;;
				cout&lt;&lt;num[n[left]-'0'];
				hasprint=true;
				if(left!=right) cout&lt;&lt;&quot; &quot;&lt;&lt;wei[right-left-1];
			}
			left++;
		}
		if(right!=len-1&amp;&amp;hasprint==true)	cout&lt;&lt;&quot; &quot;&lt;&lt;wei[(len-1-right)/4+2]; 
		right+=4; 
	}
	return 0;
} 
</code></pre>
<h3 id="a108325-æ’åº">A1083(25 æ’åº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string name,id;
	int grade;
}stu[1000];
bool cmp(node a,node b){return a.grade&gt;b.grade;}
int main(){
	int n,score,g1,g2;
	string name,id;
	vector&lt;node&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].id&gt;&gt;stu[i].grade;
	cin&gt;&gt;g1&gt;&gt;g2;
	for(int i=0;i&lt;n;i++) {
		if(stu[i].grade&gt;=g1&amp;&amp;stu[i].grade&lt;=g2){
			ans.push_back(stu[i]);
		}
	}
	if(ans.size()==0) cout&lt;&lt;&quot;NONE&quot;;
	else{
		sort(ans.begin(),ans.end(),cmp);
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%s %s\n&quot;,ans[i].name.c_str(),ans[i].id.c_str());
	} 
	return 0;
}
</code></pre>
<h3 id="a108420-å­—ç¬¦ä¸²">A1084(20 å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	cin&gt;&gt;s1&gt;&gt;s2;
	for(int i=0;i&lt;s1.length();i++){
		if(s2.find(s1[i])==string::npos&amp;&amp;ans.find(toupper(s1[i]))==string::npos)
		  ans+=toupper(s1[i]); 
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a108525-äºŒåˆ†-twopoints-å¤šè§£æ³•">A1085(25 äºŒåˆ† twopoints å¤šè§£æ³•)</h3>
<pre><code>äºŒåˆ†æ³•
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,p,ans=0;
	cin&gt;&gt;n&gt;&gt;p;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++)  cin&gt;&gt;v[i];
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n;i++){
		int j=upper_bound(v.begin()+i+1,v.begin()+n,(long long)p*v[i])-v.begin();
		ans=max(ans,j-i);
	}
	cout&lt;&lt;ans;
	return 0;
}






two points
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, p,num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num,num + n);
	int count=0,i=0,j=0;
    while(i&lt;n&amp;&amp;j&lt;n){
        while(j&lt;n&amp;&amp;num[j]&lt;=(long long)num[i]*p){
            count=max(count,j-i+1);
            j++;
        }
        i++;
    }
    printf(&quot;%d&quot;,count);
    return 0;
}
</code></pre>
<h3 id="a108625-æ ˆæ¨¡æ‹Ÿä¸­åºå’Œå…ˆåºå»ºæ ‘è¾“å‡ºååº">A1086(25 æ ˆæ¨¡æ‹Ÿä¸­åºå’Œå…ˆåºå»ºæ ‘ï¼Œè¾“å‡ºååº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=31;
int n,pre[maxn],in[maxn],num=0;
struct node{
	int data;
	node*left,*right;
};
node*create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;data=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;right=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
void postorder(node*root){
	if(root==NULL) return;
	postorder(root-&gt;left);
	postorder(root-&gt;right);
	printf(&quot;%d&quot;,root-&gt;data);
	num++;
	if(num&lt;n) printf(&quot; &quot;);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char s[5];
	stack&lt;int&gt; st;
	int temp,preindex=0,inindex=0;
	for(int i=0;i&lt;2*n;i++){
		scanf(&quot;%s&quot;,s);
		if(strcmp(s,&quot;Push&quot;)==0){
			scanf(&quot;%d&quot;,&amp;temp);
			st.push(temp);
			pre[preindex++]=temp;
		}else{
			temp=st.top();
			st.pop();
			in[inindex++]=temp;
		}
	}
	node*root=create(0,n-1,0,n-1);
	postorder(root);
	return 0;
}
</code></pre>
<h3 id="a1087">A1087</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
const int maxn=210;
const int INF=1000000000;
int pre[maxn],num[maxn],d[maxn],w[maxn],weight[maxn],pt[maxn],G[maxn][maxn];
int n,k;
bool vis[maxn];
map&lt;int,string&gt; inttostring;
map&lt;string,int&gt; stringtoint;
void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(w,w+maxn,0);
	fill(pt,pt+maxn,0);
	fill(num,num+maxn,0);
    for(int i=0;i&lt;n;i++) pre[i]=i;
	d[s]=0;
	w[s]=weight[s];
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];	
					num[v]=num[u];
					pt[v]=pt[u]+1;
					pre[v]=u;
				}else if(d[v]==d[u]+G[u][v]){
					num[v]+=num[u];
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
						pt[v]=pt[u]+1;
						pre[v]=u;
					}else if(w[v]==weight[v]+w[u]){
						double avgfun1=w[v]*1.0/pt[v];
						double avgfun2=(weight[v]+w[u])*1.0/(pt[u]+1);
						if(avgfun2&gt;avgfun1){
							pt[v]=pt[u]+1;
							pre[v]=u;
						}
					}
				}
			}
		}
	}
}
void printpath(int v){
	if(v==0){
		cout&lt;&lt;inttostring[v];
		return;
	}
	printpath(pre[v]);
	cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;inttostring[v];
}
int main(){
	string begincity,tempcity,c1,c2;
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;begincity;
	stringtoint[begincity]=0;
	inttostring[0]=begincity;
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=n-1;i++){
		cin&gt;&gt;tempcity&gt;&gt;weight[i];
		stringtoint[tempcity]=i;
		inttostring[i]=tempcity;
	}
	for(int i=0;i&lt;k;i++){
		cin&gt;&gt;c1&gt;&gt;c2;
		int id1=stringtoint[c1];
		int id2=stringtoint[c2];
		cin&gt;&gt;G[id1][id2];
		G[id2][id1]=G[id1][id2];
	}
	dijkst(0);
	int end=stringtoint[&quot;ROM&quot;];
	printf(&quot;%d %d %d %d\n&quot;,num[end],d[end],w[end],w[end]/pt[end]);
    printpath(end);
    return 0;
}
</code></pre>
<h3 id="a1088">A1088</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
ll gcd(ll a, ll b) {
	return b == 0 ? a : gcd(b, a % b);
}
struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction subtract(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down - f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction multi(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction divide(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down;
	result.down = f1.down * f2.up;
	return reduction(result);
}
void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
int main() {
	scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down);
	showresult(a);
	printf(&quot; + &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(add(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; - &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(subtract(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; * &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(multi(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; / &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	if (b.up == 0) printf(&quot;Inf&quot;);
	else showresult(divide(a, b));
	return 0;
}
</code></pre>
<h3 id="a1089-25-æ’å…¥æ’åºå’Œå½’å¹¶æ’åº">A1089  (25 æ’å…¥æ’åºå’Œå½’å¹¶æ’åº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100],b[100],n,j,m;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i];
	for(j=0;j&lt;n-1&amp;&amp;b[j]&lt;=b[j+1];j++);
	for(m=j+1;m&lt;n&amp;&amp;a[m]==b[m];m++);
	if(m==n){
		cout&lt;&lt;&quot;Insertion Sort\n&quot;;
		sort(a,a+j+2);
	}else{
		cout&lt;&lt;&quot;Merge Sort\n&quot;;
		int flag=1,k=1;
		while(flag){
			flag=0;
			for(int i=0;i&lt;n;i++){
				if(a[i]!=b[i]) flag=1;
			}
			k=k*2;
			for(int i=0;i&lt;n/k;i++) sort(a+i*k,a+(i+1)*k);
			sort(a+(n/k)*k,a+n);
		}
	}
	for(int i=0;i&lt;n;i++){
		if(i!=0) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;a[i];
	}
	return 0;
}
</code></pre>
<h3 id="a109025-æ ‘çš„dfsæ±‚æ·±åº¦">A1090(25 æ ‘çš„dfsæ±‚æ·±åº¦)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int maxdepth=-1,num,n;
double p,r,ans=0;
vector&lt;int&gt; tree[100010];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(depth&gt;maxdepth){
			maxdepth=depth;
			num=1;
		}
		else if(depth==maxdepth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int father,root;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;father);
		if(father==-1) root=i;
	    else tree[father].push_back(i);
	}
	dfs(root,0);
	ans=p*pow((1+r/100),maxdepth);
	printf(&quot;%.2f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a109130-ç»å…¸bfsæ±‚çŸ©é˜µä¸­å—çš„ä¸ªæ•°">A1091(30 ç»å…¸BFSæ±‚çŸ©é˜µä¸­å—çš„ä¸ªæ•°)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int x,y,z;
}Node;
int m,n,L,t,ans=0;
bool inq[70][1300][140]={false};
int pix[70][1300][140]={0};
int Z[6]={0,0,0,0,1,-1};
int X[6]={0,0,1,-1,0,0};
int Y[6]={1,-1,0,0,0,0};
bool judge(int z,int y,int x){
	if(x&gt;=n||x&lt;0||y&gt;=m||y&lt;0||z&lt;0||z&gt;=L) return false;
	if(pix[z][y][x]==0||inq[z][y][x]==true) return false;
	return true;
}
int bfs(int z,int y,int x){
	int total=0;
	queue&lt;node&gt; q;
	Node.x=x,Node.y=y,Node.z=z;
	q.push(Node);
	inq[z][y][x]=true;
	while(!q.empty()){
		node Top=q.front();
		q.pop();
		total++;//æ³¨æ„åœ¨å‡ºé˜Ÿçš„æ—¶å€™è®¡æ•° 
		for(int i=0;i&lt;6;i++){
			int newz=Top.z+Z[i];
			int newx=Top.x+X[i];
			int newy=Top.y+Y[i];
			if(judge(newz,newy,newx)){
				Node.x=newx,Node.y=newy,Node.z=newz;
				q.push(Node);
				inq[newz][newy][newx]=true;
			}
		}
	}
	if(total&gt;=t) return total;
	else return 0;
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;m,&amp;n,&amp;L,&amp;t);
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				scanf(&quot;%d&quot;,&amp;pix[i][j][k]);
			}
		}
	}
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				if(inq[i][j][k]==false&amp;&amp;pix[i][j][k]==1) ans+=bfs(i,j,k);
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1092å­—ç¬¦ä¸²-hash">A1092(å­—ç¬¦ä¸² hash)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2;
	cin&gt;&gt;s1&gt;&gt;s2;
	vector&lt;int&gt; v(128,0);
	bool can=true;
	int miss=0;
	for(int i=0;i&lt;s1.length();i++)  v[s1[i]]++;
	for(int i=0;i&lt;s2.length();i++){
	    v[s2[i]]-=1;
	    if(v[s2[i]]&lt;0) {
	    	can=false;
	    	++miss;
		}
	}
	if(can==false) cout&lt;&lt;&quot;No &quot;&lt;&lt;miss;
	else cout&lt;&lt;&quot;Yes &quot;&lt;&lt;s1.length()-s2.length();
	return 0;
}
</code></pre>
<h3 id="a109325-é€»è¾‘é¢˜">A1093(25 é€»è¾‘é¢˜)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	cin&gt;&gt;s;
	long long ans=0;
	int num1[100010]={0},num2[100010]={0};
	for(int i=1;i&lt;s.length();i++){
		if(s[i-1]=='P') num1[i]=num1[i-1]+1;
		else num1[i]=num1[i-1];
	}
	for(int i=s.length()-2;i&gt;=0;i--){
		if(s[i+1]=='T') num2[i]=num2[i+1]+1;
		else num2[i]=num2[i+1];
	}
	for(int i=1;i&lt;s.length()-1;i++){
		if(s[i]=='A') ans+=num1[i]*num2[i];
	}
	cout&lt;&lt;ans%1000000007;
	return 0;
}
</code></pre>
<h3 id="a109425-æ ‘çš„dfs">A1094(25 æ ‘çš„dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1,ansnum=-1,anslevel;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	level[depth]++;
	if(tree[index].size()==0){
		if(maxdepth&lt;depth) maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,1);
	for(int i=1;i&lt;=maxdepth;i++){
		if(level[i]&gt;ansnum){
			ansnum=level[i];
			anslevel=i;
		}
	}
	printf(&quot;%d %d&quot;,ansnum,anslevel);
	return 0;
}
</code></pre>
<h3 id="a109530-æ ¡å›­åœè½¦-æ’åº-ä¸¤è¾†é…å¯¹-æ—¶é—´æŸ¥è¯¢è¾“å‡º">A1095(30 æ ¡å›­åœè½¦ æ’åº  ä¸¤è¾†é…å¯¹  æ—¶é—´æŸ¥è¯¢è¾“å‡º)</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
struct node{
	string id;
	int time,flag=0;
};
bool cmp1(node &amp;a,node &amp;b){
	return a.id!=b.id? a.id&lt;b.id : a.time&lt;b.time;
}
bool cmp2(node &amp;a,node &amp;b){
	return a.time&lt;b.time;
}
int main(){
	int n,m,hh,mm,ss,maxparking=-1,tempindex=0;
	string status;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; record(n),car;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;record[i].id;
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		cin&gt;&gt;status;
		record[i].time=hh*3600+mm*60+ss;
		record[i].flag=(status==&quot;in&quot;)? 1 : -1;
	}
	sort(record.begin(),record.end(),cmp1);
	map&lt;string,int&gt; mp;
	for(int i=1;i&lt;n;i++){
		if(record[i-1].flag==1&amp;&amp;record[i].flag==-1&amp;&amp;record[i-1].id==record[i].id){
			car.push_back(record[i-1]);
			car.push_back(record[i]);
			mp[record[i].id]+=record[i].time-record[i-1].time;
		    if(maxparking&lt;mp[record[i].id]) maxparking=mp[record[i].id];
		}
	}
	sort(car.begin(),car.end(),cmp2);
	vector&lt;int&gt; cnt(n);
	for(int i=0;i&lt;car.size();i++){
		if(i==0) cnt[i]+=car[i].flag;
		else cnt[i]=cnt[i-1]+car[i].flag;
	}
	
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		int query=hh*3600+mm*60+ss;
		int j;
		for(j=tempindex;j&lt;car.size();j++){
			if(query&lt;car[j].time){
				printf(&quot;%d\n&quot;,cnt[j-1]);
				break;
			}else if(j==car.size()-1) printf(&quot;%d\n&quot;,cnt[j]);
		}
		tempindex=j;
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second==maxparking) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;
	}
	printf(&quot;%02d:%02d:%02d&quot;,maxparking/3600,maxparking%3600/60,maxparking%60);
	return 0;
}
</code></pre>
<h3 id="a1096">A1096</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
int main() {
	long long  n;
	scanf(&quot;%lld&quot;, &amp;n);
	long long  sqr = sqrt(n * 1.0);
	long long len=0, first;
	for (long long i = 2; i &lt;= sqr; i++) {
		long long j = i, product = 1 ;
		while (1) {
			product *= j;
			if (n % product != 0) break;
			else {
				if (j - i + 1 &gt; len) {
					len = j - i + 1;
					first = i;
				}
			}
			j++;
		}
	}
	if (len == 0) {
		printf(&quot;1\n&quot;);
		printf(&quot;%lld&quot;, n);
	}
	else {
		printf(&quot;%lld\n&quot;, len);
		for (long long i = first; i &lt; first + len; i++) {
			if (i == first) printf(&quot;%lld&quot;, i);
			else printf(&quot;*%lld&quot;, i);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a109725-é“¾è¡¨åˆ†ç¦»">A1097(25 é“¾è¡¨åˆ†ç¦»)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int address,data,next;
}list[100010];
int main(){
	int begin,n,address;
	scanf(&quot;%d%d&quot;,&amp;begin,&amp;n);
	vector&lt;int&gt; flag(10010,0);
	vector&lt;node&gt; remain,remov;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		if(flag[abs(list[begin].data)]==0) {
			flag[abs(list[begin].data)]=1;
			remain.push_back(list[begin]);
		}else remov.push_back(list[begin]);
		begin=list[begin].next;
	}
	for(int i=0;i&lt;remain.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remain[i].address,remain[i].data,remain[i+1].address);		
	printf(&quot;%05d %d -1\n&quot;,remain[remain.size()-1].address,remain[remain.size()-1].data);
	if(remov.size()!=0){
		for(int i=0;i&lt;remov.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remov[i].address,remov[i].data,remov[i+1].address);		
     	printf(&quot;%05d %d -1&quot;,remov[remov.size()-1].address,remov[remov.size()-1].data);
	}
	return 0;
}
</code></pre>
<h3 id="a109825-åˆ¤æ–­æ’å…¥æ’åºå’Œå †æ’åº">A1098(25 åˆ¤æ–­æ’å…¥æ’åºå’Œå †æ’åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
void downadjust(vector&lt;int&gt;&amp;b,int low,int high){
	int i=low,j=i*2;
	while(j&lt;=high){
		if(j+1&lt;=high&amp;&amp;b[j+1]&gt;b[j]) j=j+1;
		if(b[i]&gt;=b[j]) break;
		swap(b[i],b[j]);
		i=j;
		j=i*2;
	}
}
int main(){
	int n,p,q;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt;a(n+1),b(n+1);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for(p=2;b[p-1]&lt;=b[p]&amp;&amp;p&lt;=n;p++);
	int index=p;
	while(index&lt;=n&amp;&amp;a[index]==b[index]) index++;
	if(index==n+1){
		printf(&quot;Insertion Sort\n&quot;);
		sort(b.begin()+1,b.begin()+p+1);	
	}
	else{
		printf(&quot;Heap Sort\n&quot;);
		for(q=n;b[q]&gt;=b[1]&amp;&amp;q&gt;2;q--);
		swap(b[1],b[q]);
		downadjust(b,1,q-1);
	}
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,b[i]);
	}
	return 0;
} 
</code></pre>
<h3 id="a109930-ä¸­åºéå†å»ºç«‹äºŒå‰æœç´¢æ ‘">A1099(30 ä¸­åºéå†å»ºç«‹äºŒå‰æœç´¢æ ‘)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=101;
struct node{
	int v;
	int left,right;
}Node[maxn];
int n,a[maxn],index=0,num=0;
void inorder(int root){
	if(root==-1) return;
	inorder(Node[root].left);
	Node[root].v=a[index++];
	inorder(Node[root].right);
} 
void bfs(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int temp=q.front();
		q.pop();
		if(num&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,Node[temp].v);
		num++;
		if(Node[temp].left!=-1) q.push(Node[temp].left);
		if(Node[temp].right!=-1) q.push(Node[temp].right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;Node[i].left,&amp;Node[i].right);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(0);
	bfs(0);
	return 0;
} 
</code></pre>
<h3 id="a110020-å­—ç¬¦ä¸²-string-map">A1100(20 å­—ç¬¦ä¸² string map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
string unitdigit[13]={&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,
&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string tendigit[13]= {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,
&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
string numtostr[169];
map&lt;string,int&gt; strtonum;
void init(){
	for(int i=0;i&lt;13;i++){
		numtostr[i]=unitdigit[i];
		strtonum[unitdigit[i]]=i;
		numtostr[i*13]=tendigit[i];
		strtonum[tendigit[i]]=i*13;
	}
	for(int i=1;i&lt;13;i++){
		for(int j=1;j&lt;13;j++){
			string str=tendigit[i]+&quot; &quot;+unitdigit[j];
			numtostr[i*13+j]=str;
			strtonum[str]=i*13+j;
		}
	}
}
int main(){
	init();
	int n,temp;
	scanf(&quot;%d\n&quot;,&amp;n);
	string s;
	while(n--){
		getline(cin,s);
		if(s[0]&gt;='0'&amp;&amp;s[0]&lt;='9'){
			temp=stoi(s);
			cout&lt;&lt;numtostr[temp]&lt;&lt;endl;
		}
		else cout&lt;&lt;strtonum[s]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a110125-é€»è¾‘é¢˜">A1101(25 é€»è¾‘é¢˜)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std; 
int main(){
	int n,a[100010],leftmax=-1,rightmin=0x7fffffff;
	int left[100010],right[100010];
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	left[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i-1]&gt;leftmax) leftmax=a[i-1];
		left[i]=leftmax;
	}
	right[n-1]=a[n-1];
	for(int i=n-2;i&gt;=0;i--){
		if(a[i+1]&lt;rightmin) rightmin=a[i+1];
		right[i]=rightmin;
	}
	for(int i=0;i&lt;n;i++){
		if(a[i]&gt;=left[i]&amp;&amp;a[i]&lt;=right[i]) ans.insert(a[i]);
	}
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(auto it=ans.begin();it!=ans.end();it++){
		if(it!=ans.begin()) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;*it;
	}
	cout&lt;&lt;endl;
	 return 0;
}
</code></pre>
<h3 id="a110225-äºŒå‰æ ‘åè½¬">A1102(25 äºŒå‰æ ‘åè½¬)</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int left,right;
}tree[11];
int n,ischild[11]={0},root,num1=0,num2=0;
void layerorder(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top);
		num1++;
		if(num1&lt;n) printf(&quot; &quot;);
		if(tree[Top].left!=-1) q.push(tree[Top].left);
		if(tree[Top].right!=-1) q.push(tree[Top].right); 
	}
}
void inorder(int root){
	if(root==-1) return;
	inorder(tree[root].left);
	printf(&quot;%d&quot;,root);
	num2++;
	if(num2&lt;n) printf(&quot; &quot;);
	inorder(tree[root].right);
}
void invert(int root){
	if(root==-1) return;
	invert(tree[root].left);
	invert(tree[root].right);
	swap(tree[root].left,tree[root].right);
} 
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char c1,c2;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%*c%c %c&quot;,&amp;c1,&amp;c2);
		if(c1=='-') tree[i].left=-1;
		else {
			ischild[c1-'0']=1;
			tree[i].left=c1-'0';
		}
		if(c2=='-') tree[i].right=-1;
		else {
			ischild[c2-'0']=1;
			tree[i].right=c2-'0';
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		} 
	}
	invert(root);
	layerorder(root);
	printf(&quot;\n&quot;);
	inorder(root);
	return 0;
}
</code></pre>
<h3 id="a110330-dfs-åˆ†è§£å› å¼">A1103(30 DFS åˆ†è§£å› å¼)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
int n,k,p,maxfac=-1;
vector&lt;int&gt; fac,temp,ans; 
void init(){
	int i=0;
	while(pow(i,p)&lt;=n){
		fac.push_back(pow(i,p));
		i++;
	} 
}
void dfs(int index,int nowk,int sum,int facsum){
	if(nowk==k&amp;&amp;sum==n){
		if(facsum&gt;maxfac){
			maxfac=facsum;
			ans=temp;
		}
		return;
	}
	if(nowk&gt;k||sum&gt;n) return;
	if(index&gt;=1){
		temp.push_back(index);
		dfs(index,nowk+1,sum+fac[index],facsum+index);
		temp.pop_back();
		dfs(index-1,nowk,sum,facsum);
	}
}
int main(){
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;p);
	init();
	dfs(fac.size()-1,0,0,0);
	if(maxfac==-1) printf(&quot;Impossible&quot;);
	else{
		printf(&quot;%d = &quot;,n);
		for(int i=0;i&lt;ans.size();i++){
		   if(i&gt;0) printf(&quot; + &quot;);
		   printf(&quot;%d^%d&quot;,ans[i],p);
	   }
	}
	return 0;
}
</code></pre>
<h3 id="a1104">A1104</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn = 100010;
int main() {
	int n;
	double a[maxn],sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lf&quot;, &amp;a[i]);
        sum += a[i] * (n - i + 1) * i;
	}
	printf(&quot;%.2f&quot;, sum);
	return 0;
}
</code></pre>
<h3 id="a1105">A1105</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=100;
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int N,n,m,st=0;
	scanf(&quot;%d&quot;,&amp;N);
	vector&lt;int&gt; a(N);
	for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	n=sqrt(1.0*N);
	while(n&gt;=1){
		if(N%n==0) break;
		n--;
	}
	m=N/n;
	int level=m/2+m%2;
	sort(a.begin(),a.end(),cmp);
	int putm=m,putn=n;
	vector&lt;vector&lt;int&gt; &gt; ans(m, vector&lt;int&gt;(n));
	for(int i=0;i&lt;level;i++){
		for(int j=i;j&lt;n&amp;&amp;st&lt;=N-1;j++) ans[i][j]=a[st++];
		for(int k=i+1;k&lt;=m-2&amp;&amp;st&lt;=N-1;k++) ans[k][n-1]=a[st++];
		for(int x=n-1;x&gt;=i&amp;&amp;st&lt;=N-1;x--) ans[m-1][x]=a[st++];
		for(int t=m-2;t&gt;=i+1&amp;&amp;st&lt;=N-1;t--) ans[t][i]=a[st++];
		n--;
		m--;
	}
	for(int i=0;i&lt;putm;i++){
		for(int j=0;j&lt;putn;j++){
			printf(&quot;%d&quot;,ans[i][j]);
			if(j&lt;putn-1) printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a110625-æ ‘çš„dfs">A1106(25 æ ‘çš„dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n,num=0,mindepth=0x7fffffff;
double p,r,ans=0.0;
vector&lt;int&gt; tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(mindepth&gt;depth){
			mindepth=depth;
			num=1;
		}else if(mindepth==depth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int k,temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].push_back(temp);
		}
	}
	dfs(0,0);
	ans=p*pow((1+r/100),mindepth);
	printf(&quot;%.4f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a110730-ç»å…¸å¹¶æŸ¥é›†">A1107(30 ç»å…¸å¹¶æŸ¥é›†)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
vector&lt;int&gt;father,isroot;
bool cmp(int a,int b){return a&gt;b;}
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
}
void Union(int a,int b){
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA!=faB) father[faA]=faB;
}
int main(){
	int course[1001]={0},n,num,courseid,cnt=0;
	scanf(&quot;%d&quot;,&amp;n);
	father.resize(n+1);
	isroot.resize(n+1,0);
	for(int i=1;i&lt;=n;i++) father[i]=i;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d:&quot;,&amp;num);
		while(num--){
			scanf(&quot;%d&quot;,&amp;courseid);
			if(course[courseid]==0) course[courseid]=i;
			Union(i,findfather(course[courseid])); 
		}
	}
	for(int i=1;i&lt;=n;i++) isroot[findfather(i)]++;
	for(int i=1;i&lt;=n;i++){
		if(isroot[i]!=0) cnt++;
	}
	sort(isroot.begin(),isroot.end(),cmp);
	printf(&quot;%d\n&quot;,cnt);
	for(int i=0;i&lt;cnt;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,isroot[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a1108">A1108</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main() {
	char a[100],b[100];
	int n,cnt=0;
	scanf(&quot;%d&quot;,&amp;n);
	double temp, sum = 0.0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, a);
		sscanf(a, &quot;%lf&quot;, &amp;temp);
		sprintf(b, &quot;%.2f&quot;, temp);
		bool flag = false;
		for (int j = 0; j &lt; strlen(a); j++) {
			if (a[j] != b[j]) flag = true;
		}
		if (flag || temp &lt; -1000 || temp&gt;1000) {
			printf(&quot;ERROR: %s is not a legal number\n&quot;, a);
		}
		else {
			sum += temp;
			cnt++;
		}
	}
	if (cnt == 0) printf(&quot;The average of 0 numbers is Undefined&quot;);
	else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum);
	else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt);
	return 0;
}
</code></pre>
<h3 id="a1109">A1109</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 10010;
struct node {
	int height;
	char name[10];
}person[maxn];
bool cmp(node a, node b) {
	if (a.height != b.height) return a.height &gt; b.height;
	else return strcmp(a.name, b.name) &lt; 0;
}
int main() {
	int n, k, cnt = 0;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; person[i].name;
		cin &gt;&gt; person[i].height;
	}
	int rownum = n / k;
	sort(person, person + n, cmp);
	for (int i = 0; i &lt; k; i++) {
		vector&lt;node&gt; ans(n+1);
		int num;
		if (i == 0)  num = n - (rownum * (k - 1));
		else  num = rownum;
		ans[num / 2 + 1] = person[cnt++];
		for (int j = 1; j &lt;= num / 2; j++) {
			if ((num / 2 + 1 - j) &gt;= 1) ans[num / 2 + 1 - j] = person[cnt++];
			if ((num / 2 + 1 + j) &lt;= num) ans[num / 2 + 1 + j] = person[cnt++];
		}
		for (int j = 1; j &lt;= num; j++) {
			cout &lt;&lt; ans[j].name;
			if (j &lt; num) cout &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
		ans.clear();
	}
	return 0;
}
</code></pre>
<h3 id="a1110">A1110</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	int lchild;
	int rchild;
}a[21];
int ans, maxn = -1;
void dfs(int root, int index) {
	if (index &gt; maxn) {
		maxn = index;
		ans = root;
	}
	if (a[root].lchild != -1) dfs(a[root].lchild, index * 2);
	if (a[root].rchild != -1) dfs(a[root].rchild, index * 2 + 1);
}
int main() {
	int root = 0,n, have[30] = { 0 };
	string c;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; c;
		if (c == &quot;-&quot;) a[i].lchild = -1;
		else {
			a[i].lchild = stoi(c);
			have[a[i].lchild] = 1;
		}
		cin &gt;&gt; c;
		if (c == &quot;-&quot;) a[i].rchild = -1;
		else {
			a[i].rchild = stoi(c);
			have[a[i].rchild] = 1;
		}
	}
	while (have[root] != 0) root++;
	dfs(root, 1);
	if (maxn == n) cout &lt;&lt; &quot;YES &quot; &lt;&lt; ans;
	else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;
	return 0;
}
</code></pre>
<h3 id="a1112">A1112</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	bool surenobroken[256]={false},hasprint[256]={false};
	map&lt;char,bool&gt; broken;
	vector&lt;char&gt; needprint;
	string s;
	int k;
	scanf(&quot;%d&quot;,&amp;k);
	cin&gt;&gt;s;
	int cnt=1;
	char pre='@';
	s=s+'@';
	for(int i=0;i&lt;s.size();i++){
		if(s[i]==pre){
			cnt++;
		}else{
			if(cnt%k!=0) surenobroken[pre]=true;
			cnt=1;
		}
		if(i&lt;s.size()-1) broken[s[i]]=(cnt%k==0);
		pre=s[i];
	}
	for(int i=0;i&lt;s.size()-1;i++){
		if(surenobroken[s[i]]==true) broken[s[i]]=false;
		if(broken[s[i]]==true&amp;&amp;hasprint[s[i]]==false){
			needprint.push_back(s[i]);
			hasprint[s[i]]=true;
		}
	}
	for(int i=0;i&lt;needprint.size();i++) cout&lt;&lt;needprint[i];
	cout&lt;&lt;endl;
    for(int i=0;i&lt;s.length()-1;i++){
    	cout&lt;&lt;s[i];
    	if(broken[s[i]]==true) i=i+k-1;
	}
	return 0;
}
</code></pre>
<h3 id="a1113å°æŠ€å·§æ°´é¢˜">A1113(å°æŠ€å·§ï¼Œæ°´é¢˜)</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt; 
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,sum=0,halfsum=0;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		sum+=v[i];
	}
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n/2;i++) halfsum+=v[i]; 
    printf(&quot;%d %d&quot;,n%2,sum-2*halfsum);
	return 0;
}
</code></pre>
<h3 id="a1114-å¹¶æŸ¥é›†">A1114 å¹¶æŸ¥é›†</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node1 {
	int id, fid, mid,  num, area;
	int cid[10];
}person[100000];
struct node2 {
	int id, members = 0;
	double num = 0, area = 0;
	bool flag = false;
}ans[100000];
bool vis[100000] = { false };
int father[100000];
int findfather(int v) {
	while (v != father[v])
		v = father[v];
	return v;
}
void Union(int a, int b) {
	int fathera = findfather(a);
	int fatherb = findfather(b);
	if (fathera &lt; fatherb) father[fatherb] = fathera;
	else father[fathera] = fatherb;
}
bool cmp(node2 a, node2 b) {
	if (a.area != b.area ) return a.area &gt; b.area;
	else return a.id &lt; b.id;
}
int main() {
	int n, k, id, cnt = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; 10000; i++) father[i] = i;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;person[i].id, &amp;person[i].fid, &amp;person[i].mid, &amp;k);
		vis[person[i].id] = true;
		if (person[i].fid != -1) {
			Union(person[i].id, person[i].fid);
			vis[person[i].fid] = true;
		}

		if (person[i].mid != -1) {
			Union(person[i].id, person[i].mid);
			vis[person[i].mid] = true;
		}
		for (int j = 0; j &lt; k; j++) {
			scanf(&quot;%d&quot;, &amp;person[i].cid[j]);
			Union(person[i].id, person[i].cid[j]);
			vis[person[i].cid[j]] = true;
		}
		scanf(&quot;%d%d&quot;, &amp;person[i].num, &amp;person[i].area);
	}
	for (int i = 0; i &lt; n; i++) {
		id = findfather(person[i].id);
		ans[id].id = id;
		ans[id].num += person[i].num;
		ans[id].area += person[i].area;
		ans[id].flag = true;
	}
	for (int i = 0; i &lt; 10000; i++) {
		if (ans[i].flag) cnt++;
		if (vis[i]) ans[findfather(i)].members++;
	}
	for (int i = 0; i &lt; 10000; i++) {
		if (ans[i].flag) {
			ans[i].num = (double)(ans[i].num * 1.0 / ans[i].members);
			ans[i].area = (double)(ans[i].area * 1.0 / ans[i].members);
		}
	}
	sort(ans, ans + 10000, cmp);
	printf(&quot;%d\n&quot;, cnt);
	for (int i = 0; i &lt; cnt; i++) {
		printf(&quot;%04d %d &quot;, ans[i].id, ans[i].members);
		printf(&quot;%.3f %.3f\n&quot;, ans[i].num, ans[i].area);
	}
	return 0;
}
</code></pre>
<h3 id="a1115äºŒå‰æœç´¢æ ‘å»ºç«‹ä¸dfs">A1115(äºŒå‰æœç´¢æ ‘å»ºç«‹ä¸DFS)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node*lchild,*rchild; 
};
int maxdepth=-1,num[1001]={0},n;
node* create(node*root,int v){
	if(root==NULL){
		root=new node;
		root-&gt;data=v;
		root-&gt;lchild=root-&gt;rchild=NULL;
	}
	else if(root-&gt;data&gt;=v) root-&gt;lchild=create(root-&gt;lchild,v);
	else root-&gt;rchild=create(root-&gt;rchild,v);
	return root;
}
void dfs(node*root,int depth){
	if(root==NULL){
		maxdepth=max(depth,maxdepth);
		return;
	}
	num[depth]++;
	dfs(root-&gt;lchild,depth+1);
	dfs(root-&gt;rchild,depth+1); 
}	
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	node*root=NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		root=create(root,v[i]);
	}
	dfs(root,0);
	printf(&quot;%d + %d = %d&quot;,num[maxdepth-1],num[maxdepth-2],num[maxdepth-1]+num[maxdepth-2]);
	return 0;
}
</code></pre>
<h3 id="a1116">A1116</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(1.0*n);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int id,n,k,rank[maxn],query;
	bool vis[maxn]={false};
	scanf(&quot;%d&quot;,&amp;n);
	fill(rank,rank+maxn,0);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;id);
		rank[id]=i;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;query);
		if(rank[query]==0) printf(&quot;%04d: Are you kidding?\n&quot;,query);
		else{
			if(vis[query]==true) printf(&quot;%04d: Checked\n&quot;,query);
		    else{
		    	vis[query]=true;
		    	if(rank[query]==1) printf(&quot;%04d: Mystery Award\n&quot;,query);
		    	else if(isprime(rank[query])) printf(&quot;%04d: Minion\n&quot;,query);
		    	else printf(&quot;%04d: Chocolate\n&quot;,query);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1117é€»è¾‘é¢˜">A1117(é€»è¾‘é¢˜)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100010]={0},n,j=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n,greater&lt;int&gt;());
    while(j&lt;n&amp;&amp;a[j]&gt;j+1) j++;
	printf(&quot;%d&quot;,j);
	return 0;
}
</code></pre>
<h3 id="a1118-å¹¶æŸ¥é›†">A1118  å¹¶æŸ¥é›†</h3>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
const int maxn = 10010;
int father[maxn], cnt[maxn] = { 0 };
int findfather(int v) {
	if (father[v] == v) return v;
	else {
		int F = findfather(father[v]);
		father[v] = F;
		return F;
	}
}
void Union(int a, int b) {
	int fa = findfather(a);
	int fb = findfather(b);
	if (fa != fb) father[fa] = fb;
}
bool vis[maxn] = { false };
int main() {
	int n, k, temp, id, num = 0, sum = 0,Q;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; maxn; i++) father[i] = i;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;k, &amp;id);
		vis[id] = true;
		for(int j = 0; j &lt; k-1; j++){
			scanf(&quot;%d&quot;, &amp;temp);
			vis[temp] = true;
			Union(id, temp);
		}
	}
	for (int i = 0; i &lt; maxn; i++) {
		if (vis[i]) cnt[findfather(i)]++;
	}
	for (int i = 0; i &lt; maxn; i++) {
		if (cnt[i] != 0) {
			num++;
			sum += cnt[i];
		}
	}
	printf(&quot;%d %d\n&quot;, num, sum);
	scanf(&quot;%d&quot;, &amp;Q);
	for (int i = 0; i &lt; Q; i++){
		int q1, q2;
		scanf(&quot;%d%d&quot;, &amp;q1, &amp;q2);
		if (findfather(q1) != findfather(q2)) printf(&quot;No\n&quot;);
		else printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1119-30-æ ‘çš„å‰åºå’Œååº-æ±‚ä¸­åº">A1119 (30 æ ‘çš„å‰åºå’Œååº æ±‚ä¸­åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; pre, post, in;
bool unique = true;
void getin(int prel, int prer, int postl, int postr) {
	if (prel == prer) {
		in.push_back(pre[prel]);
		return;
	}
	if (pre[prel] == post[postr]) {
		int i = prel + 1;
		while (i &lt;= prer &amp;&amp; pre[i] != post[postr - 1]) i++;
		if (i - prel &gt; 1) getin(prel + 1, i - 1, postl, postl + (i - prel - 1) - 1);
		else unique = false;
		in.push_back(post[postr]);
		getin(i, prer, postl + (i - prel - 1), postr - 1);
	}
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	post.resize(n);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	getin(0, n - 1, 0, n - 1);
	if (unique) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	printf(&quot;%d&quot;, in[0]);
	for (int i = 1; i &lt; in.size(); i++) printf(&quot; %d&quot;, in[i]);
    printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a1120">A1120</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=10010;
int main(){
	int n,sum[maxn]={0};
	string str;
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	bool flag[maxn]={false};
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;str;
		int len=str.size();
		for(int j=0;j&lt;len;j++){
			sum[i]+=(str[j]-'0');
		}
	}
	for(int i=0;i&lt;n;i++) ans.insert(sum[i]);
	printf(&quot;%d\n&quot;,ans.size());
	for(auto it=ans.begin();it!=ans.end();it++) {
		if(it!=ans.begin()) printf(&quot; %d&quot;,*it);
		else printf(&quot;%d&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1121-25-map-setåº”ç”¨">A1121 (25 mapã€setåº”ç”¨)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
bool flag[100000] = { false };
map&lt;int, int&gt;couple;
int main() {
	int n, m, p1, p2;
	set&lt;int&gt; ans;
	vector&lt;int&gt; guests;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%d%d&quot;, &amp;p1, &amp;p2);
		couple[p1] = p2;
		couple[p2] = p1;
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;p1);
		guests.push_back(p1);
		flag[p1] = true;
	}
	for (int i = 0; i &lt; guests.size(); i++) {
		if (couple.count(guests[i])==0||(flag[couple[guests[i]]]==false)&amp;&amp; couple.count(guests[i]) != 0) ans.insert(guests[i]);
	}
	printf(&quot;%d\n&quot;, ans.size());
	for (auto it = ans.begin(); it != ans.end(); it++) {
		if (it != ans.begin()) printf(&quot; &quot;);
		printf(&quot;%05d&quot;, *it);
	}
	return 0;
}
</code></pre>
<h3 id="a112225-å“ˆå¯†é¡¿å›è·¯-set">A1122(25 å“ˆå¯†é¡¿å›è·¯  set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int n, m, g[201][201] = { 0 }, v1, v2;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;v1, &amp;v2);
		g[v1][v2] = 1;
		g[v2][v1] = 1;
	}
	int k, num, temp;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		int flag1 = 1, flag2 = 1;
		scanf(&quot;%d&quot;, &amp;num);
		vector&lt;int&gt; data;
		set&lt;int&gt; path;
		for (int j = 0; j &lt; num; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			data.push_back(temp);
			path.insert(temp);
		}
		if (path.size() != n || data[0] != data[data.size() - 1] || num - 1 != n) flag1 = 0;
		for (int j = 0; j &lt; num - 1; j++) {
			if (g[data[j]][data[j + 1]] != 1) flag2 = 0;
		}
		if (flag1 &amp;&amp; flag2) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a112330-avl-å±‚åºéå†-åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘">A1123(30 AVL ã€å±‚åºéå†ã€åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int data, height;
	node* lchild, * rchild;
};
node* newnode(int v) {
	node* Node = new node;
	Node-&gt;data = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
int getheight(node* root) {
	if (root == NULL) return 0;
	else return root-&gt;height;
}
int getbalance(node* root) {
	return getheight(root-&gt;lchild) - getheight(root-&gt;rchild);
}
void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newnode(v);
		return;
	}
	if (root-&gt;data &gt; v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalance(root) == 2) {
			if (getbalance(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalance(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild, v);
		updateheight(root);
		if (getbalance(root) == -2) {
			if (getbalance(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalance(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
int iscomplete = 1, after = 0;
vector&lt;int&gt; levelorder(node* root) {
	queue&lt;node*&gt; q;
	vector&lt;int&gt; v;
	q.push(root);
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		v.push_back(temp-&gt;data);
		if (temp-&gt;lchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;lchild);
		}
		else after = 1;
		if (temp-&gt;rchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;rchild);
		}
		else after = 1;
	}
	return v;
}
int main() {
	int n, temp;
	scanf(&quot;%d&quot;, &amp;n);
	node* root = NULL;
	vector&lt;int&gt; ans;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;temp);
		insert(root, temp);
	}
	ans = levelorder(root);
	for (int i = 0; i &lt; ans.size(); i++) {
		if (i != 0) printf(&quot; &quot;);
		printf(&quot;%d&quot;, ans[i]);
	}
	printf(&quot;\n&quot;);
	if (iscomplete) printf(&quot;YES&quot;);
	else printf(&quot;NO&quot;);
	return 0;
}
</code></pre>
<h3 id="a1124-20-é€»è¾‘é¢˜">A1124  20 é€»è¾‘é¢˜</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int m,n,s;
	string temp;
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
	vector&lt;string&gt; follower(m+1),ans;
	map&lt;string,bool&gt; exist;
	for (int i = 1; i &lt;= m; i++) {
		cin &gt;&gt; temp;
		follower[i] = temp;
	}
	while (s &lt;= m) {
		if (exist.count(follower[s]) == 0) {
			exist[follower[s]] = true;
			ans.push_back(follower[s]);
			s += n;
		}
		else s += 1;
	}
	if (ans.size() == 0) printf(&quot;Keep going...&quot;);
	else {
		for (int i = 0; i &lt; ans.size(); i++)
			cout &lt;&lt; ans[i] &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a112525-è´ªå¿ƒ-æ’åº">A1125(25 è´ªå¿ƒ æ’åº)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
	vector&lt;int&gt; v;
	int n, temp, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;temp);
		v.push_back(temp);
	}
	sort(v.begin(), v.end());
	ans = v[0];
	for (int i = 1; i &lt; v.size(); i++) ans = (ans + v[i] )/ 2;
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1126">A1126</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 520;
bool vis[maxn] = { false };
vector&lt;vector&lt;int&gt; &gt; g;
int cnt = 0;
void dfs(int index) {
	vis[index] = true;
	cnt++;
	for (int i = 0; i &lt; g[index].size(); i++) {
		if (vis[g[index][i]] == false) {
			dfs(g[index][i]);
		}
	}
}
int main() {
	int n, m, a, b, even = 0, odd = 0;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	g.resize(n + 1);
	for (int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(1);
	for (int i = 1; i &lt;= n; i++) {
		printf(&quot;%d&quot;, g[i].size());
		if (i &lt; n) printf(&quot; &quot;);
		else printf(&quot;\n&quot;);
		if (g[i].size() % 2 == 0) even++;
		else odd++;
	}
	if (cnt == n &amp;&amp; even == n) printf(&quot;Eulerian&quot;);
	else if (cnt == n &amp;&amp; even == n - 2 &amp;&amp; odd == 2) printf(&quot;Semi-Eulerian&quot;);
	else printf(&quot;Non-Eulerian&quot;);
	return 0;
}
</code></pre>
<h3 id="a112730-ä¸­åºååºå»ºæ ‘dfsè¾“å‡ºzå­—å½¢å±‚åºéå†">A1127(30 ä¸­åºååºå»ºæ ‘ï¼Œdfsï¼Œè¾“å‡ºzå­—å½¢å±‚åºéå†)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int v;
	node* lchild, * rchild;
};
vector&lt;int&gt; in, post;
vector&lt;int&gt;ans[31];
node* create(int inl, int inr, int postl, int postr) {
	if (inl &gt; inr) return NULL;
	node* root = new node;
	root-&gt;v = post[postr];
	int i=inl;
	while (in[i] != post[postr]) i++;
	int leafnum = i - inl;
	root-&gt;lchild = create(inl, i - 1, postl, postl + leafnum - 1);
	root-&gt;rchild = create(i + 1, inr, postl + leafnum, postr - 1);
	return root;
}
int maxdepth = -1;
void dfs(node* root,int depth) {
	if (root == NULL) return;
	maxdepth = max(depth, maxdepth);
	ans[depth].push_back(root-&gt;v);
	dfs(root-&gt;lchild, depth + 1);
	dfs(root-&gt;rchild, depth + 1);
}int main() {
	int n;
	scanf_s(&quot;%d&quot;, &amp;n);
	in.resize(n), post.resize(n);
	for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;in[i]);
	for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;post[i]);
	node* root = NULL;
	root = create(0, n - 1, 0, n - 1);
	dfs(root, 0);
	printf(&quot;%d&quot;, ans[0][0]);
	for (int i = 1; i &lt;= maxdepth; i++) {
		if (i % 2 == 1) {
			for (int j = 0; j &lt; ans[i].size(); j++) printf(&quot; %d&quot;, ans[i][j]);
		}
		else {
			for (int j = ans[i].size()-1; j &gt;=0; j--) printf(&quot; %d&quot;, ans[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112820-nçš‡åé—®é¢˜">A1128(20  nçš‡åé—®é¢˜)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
	int k, n;
	cin &gt;&gt; k;
	while (k--) {
		cin &gt;&gt; n;
		vector&lt;int&gt; v(n);
		bool flag = true;
		for (int i = 0; i &lt; n; i++) {
			cin &gt;&gt; v[i];
			for (int j = 0; j &lt; i; j++) {
				if (v[i] == v[j] || abs(v[i] - v[j]) == abs(i - j)){
           flag = false;
           break;
        } 
			}
		}
		if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1129-25-setçš„åº”ç”¨-ç»“æ„ä½“å†…è¿ç®—ç¬¦é‡è½½">A1129 (25 setçš„åº”ç”¨ ç»“æ„ä½“å†…è¿ç®—ç¬¦é‡è½½)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
struct node {
	int id;
	int freq;
	bool operator &lt; (const node&amp; a) const {
		return (freq != a.freq) ? freq &gt; a.freq:id &lt; a.id;
	}
};
int book[50001] = { 0 };
int main() {
	int n, k, id;
	cin &gt;&gt; n &gt;&gt; k;
	set&lt;node&gt; s;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		if (i != 0) {
			cout &lt;&lt; id &lt;&lt; &quot;:&quot;;
			int cnt = 0;
			for (auto it = s.begin(); cnt &lt; k &amp;&amp; it != s.end(); it++) {
				cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;id;
				cnt++;
			}
			cout &lt;&lt; endl;
		}
		auto it = s.find(node{ id,book[id] });
		if (it != s.end())s.erase(it);//å¦‚æœèƒ½æ‰¾åˆ°ï¼Œå°±ç§»é™¤
		book[id]++;
		s.insert(node{ id,book[id] });
	}
	return 0;
}
</code></pre>
<h3 id="a1130dfsäºŒå‰æ ‘-è¾“å‡ºä¸­ç¼€è¡¨è¾¾å¼">A1130(dfsäºŒå‰æ ‘ è¾“å‡ºä¸­ç¼€è¡¨è¾¾å¼)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	string data;
	int l, r;
}tree[25];
string dfs(int root) {
	if (tree[root].l == -1 &amp;&amp; tree[root].r == -1) return tree[root].data;
	else if (tree[root].l == -1 &amp;&amp; tree[root].r != -1) return &quot;(&quot; + tree[root].data + dfs(tree[root].r) + &quot;)&quot;;
	else if (tree[root].l != -1 &amp;&amp; tree[root].r != -1) return &quot;(&quot; + dfs(tree[root].l) + tree[root].data + dfs(tree[root].r) + &quot;)&quot;;
}
int main() {
	int n, have[25] = { 0 }, root = 1;
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; tree[i].data &gt;&gt; tree[i].l &gt;&gt; tree[i].r;
		have[tree[i].l] = 1;
		have[tree[i].r] = 1;
	}
	while (have[root] == 1) root++;
	string ans = dfs(root);
	if (ans[0] == '(') ans = ans.substr(1, ans.length() - 2);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h3 id="a113130-dfs-unordered_mapé‚»æ¥çŸ©é˜µ-éš¾é¢˜">A1131(30 DFS ã€unordered_mapé‚»æ¥çŸ©é˜µã€ éš¾é¢˜  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
vector&lt;vector&lt;int&gt; &gt; v(10000);
int visit[10000] = { 0 }, mincnt, mintransfer, st, ed;
unordered_map&lt;int, int&gt; line;
vector&lt;int&gt; path, temppath;
int transfercnt(vector&lt;int&gt; a) {
	int cnt = -1, preline = 0;
	for (int i = 1; i &lt; a.size(); i++) {
		if (line[a[i - 1] * 10000 + a[i]] != preline) cnt++;
		preline = line[a[i - 1] * 10000 + a[i]];
	}
	return cnt;
}
void dfs(int node, int cnt) {
	if (node == ed &amp;&amp; (cnt &lt; mincnt || (cnt == mincnt &amp;&amp; transfercnt(temppath) &lt; mintransfer))) {
		mincnt = cnt;
		mintransfer = transfercnt(temppath);
		path = temppath;
    return;
	}
	for (int i = 0; i &lt; v[node].size(); i++) {
		if (visit[v[node][i]] == 0) {
			visit[v[node][i]] = 1;
			temppath.push_back(v[node][i]);
			dfs(v[node][i], cnt + 1);
			visit[v[node][i]] = 0;
			temppath.pop_back();
		}
	}
}
int main() {
	int n, m, pre, temp, k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d&quot;, &amp;m, &amp;pre);
		for (int j = 1; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[pre].push_back(temp);
			v[temp].push_back(pre);
			line[pre * 10000 + temp]=line[temp*10000+pre] = i;
			pre = temp;
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	while (k--) {
		mintransfer = mincnt = 1000000000;
		scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);
		temppath.clear();
		temppath.push_back(st);
		visit[st] = 1;
		dfs(st, 0);
		visit[st] = 0;
		printf(&quot;%d\n&quot;, mincnt);
		int preline = 0, pretransfer = st;
		for (int i = 1; i &lt; path.size(); i++) {
			if (line[path[i - 1] * 10000 + path[i]] != preline) {
				if (preline != 0) printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, path[i - 1]);
				preline = line[path[i - 1] * 10000 + path[i]];
				pretransfer = path[i - 1];
			}
		}
		printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, ed);
	}
	return 0;
}
</code></pre>
<h3 id="a113220-å­—ç¬¦ä¸²-æ°´é¢˜">A1132(20 å­—ç¬¦ä¸² æ°´é¢˜)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	string s, s1, s2;
	int n, len;
	cin &gt;&gt; n;
	while (n--) {
		cin &gt;&gt; s;
		len = s.size();
		s1 = s.substr(0, len / 2);
		s2 = s.substr(len / 2, len / 2);
		if (stoi(s1) == 0 || stoi(s2) == 0) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else if (stoi(s) % (stoi(s1) * stoi(s2)) == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1133é“¾è¡¨-é‡æ–°æ’åˆ—">A1133(é“¾è¡¨  é‡æ–°æ’åˆ—)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int id, data, next;
};
vector&lt;node&gt; v, ans;
int main() {
	node a[100010];
	int begin, n, k;
	int id, data, next;
	scanf(&quot;%d%d%d&quot;, &amp;begin, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;id, &amp;data, &amp;next);
		a[id] = { id,data,next };
	}
	for (; begin != -1; begin = a[begin].next) v.push_back(a[begin]);
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &lt; 0) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt;= 0 &amp;&amp; v[i].data &lt;= k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt; k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; ans.size() - 1; i++) {
		printf(&quot;%05d %d %05d\n&quot;, ans[i].id, ans[i].data, ans[i + 1].id);
	}
	printf(&quot;%05d %d -1&quot;, ans[ans.size() - 1].id, ans[ans.size() - 1].data);
	return 0;
}
</code></pre>
<h3 id="a1134å›¾-ç»“ç‚¹ä¸è¾¹çš„é—®é¢˜">A1134(å›¾  ç»“ç‚¹ä¸è¾¹çš„é—®é¢˜)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int n, m, v1, v2, k, nv;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	vector&lt;int&gt; v[10010];
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;v1, &amp;v2);
		v[v1].push_back(i);
		v[v2].push_back(i);
	}
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d&quot;, &amp;nv);
		bool flag[10010] = { false };
		int temp, j;
		for (int j = 0; j &lt; nv; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			for (int x = 0; x &lt; v[temp].size(); x++) flag[v[temp][x]] = true;
		}
		for (j = 0; j &lt; m; j++) {
			if (flag[j] == false) {
				printf(&quot;No\n&quot;);
				break;
			}
		}
		if(j==m) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a113530-åˆ¤æ–­çº¢é»‘æ ‘-é€’å½’åˆ¤æ–­">A1135(30 åˆ¤æ–­çº¢é»‘æ ‘ é€’å½’åˆ¤æ–­)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v;
	node* lchild,*rchild;
};
node*create(node*root,int x){
	if(root==NULL) {
		root=new node;
		root-&gt;v=x;
		root-&gt;lchild=root-&gt;rchild=NULL;
	}
	else if(abs(root-&gt;v)&gt;abs(x)) root-&gt;lchild=create(root-&gt;lchild,x);
	else if(abs(root-&gt;v)&lt;=abs(x)) root-&gt;rchild=create(root-&gt;rchild,x);
	return root;
}
bool judge1(node*root){
	if(root==NULL) return true;
	if(root-&gt;v&lt;0){
		if(root-&gt;lchild!=NULL&amp;&amp;root-&gt;lchild-&gt;v&lt;0) return false;
		if(root-&gt;rchild!=NULL&amp;&amp;root-&gt;rchild-&gt;v&lt;0) return false;
	}
	return judge1(root-&gt;lchild)&amp;&amp;judge1(root-&gt;rchild);
}
int getblacknum(node*root){
	if(root==NULL) return 0;
	int l=getblacknum(root-&gt;lchild);
	int r=getblacknum(root-&gt;rchild);
	return root-&gt;v&gt;0?max(l,r)+1:max(l,r);
}
bool judge2(node*root){
	if(root==NULL) return true;
	int l=getblacknum(root-&gt;lchild);
	int r=getblacknum(root-&gt;rchild);
	if(l!=r) return false;
	return judge2(root-&gt;lchild)&amp;&amp;judge2(root-&gt;rchild);
}
int main(){
	int k,n;
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;n);
		vector&lt;int&gt; tree(n);
		node*root=NULL;
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;tree[i]);
			root=create(root,tree[i]);
		}
		if(tree[0]&gt;0&amp;&amp;judge1(root)&amp;&amp;judge2(root)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1136-20-å›æ–‡ä¸²-å­—ç¬¦ä¸²">A1136 (20 å›æ–‡ä¸² å­—ç¬¦ä¸²)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
int main() {
	int n = 10;
	string origin, ans, ansv,rev;
	cin &gt;&gt; origin;
	rev = origin;
	reverse(rev.begin(), rev.end());
	if (origin == rev) {
		cout &lt;&lt; rev &lt;&lt; &quot; is a palindromic number.&quot;;
		return 0;
	}
	while (n--) {
		rev = origin;
		reverse(rev.begin(), rev.end());
		ans = add(origin, rev);
		ansv = ans;
		reverse(ansv.begin(), ansv.end());
		cout &lt;&lt; origin &lt;&lt; &quot; + &quot; &lt;&lt; rev &lt;&lt; &quot; = &quot; &lt;&lt; ans &lt;&lt; endl;
		if (ansv != ans) origin = ans;
		else {
			cout &lt;&lt; ans &lt;&lt; &quot; is a palindromic number.&quot;;
			return 0;
		}
	}
	cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
	return 0;
}
</code></pre>
<h3 id="a113725-map-æ’åº">A1137(25 map æ’åº)</h3>
<pre><code>#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string s;
	int gp,gm,gf,g; 
};
bool cmp(const node &amp;a,const node &amp;b){
	return a.g!=b.g? a.g&gt;b.g : a.s&lt;b.s;
}
map&lt;string,int&gt; mp;
int main(){
	vector&lt;node&gt;v,ans;
	int p,m,n,score,cnt=0;
	cin&gt;&gt;p&gt;&gt;m&gt;&gt;n;
	string stuid;
	for(int i=0;i&lt;p;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(score&gt;=200){
			v.push_back(node{stuid,score,-1,-1,-1});
			mp[stuid]=cnt++;
		}
	}
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(mp.count(stuid)!=0) v[mp[stuid]].gm=score; 
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(mp.count(stuid)!=0) v[mp[stuid]].gf=v[mp[stuid]].g=score;
		if(v[mp[stuid]].gf&lt;v[mp[stuid]].gm) v[mp[stuid]].g=(int)(v[mp[stuid]].gm*0.4+v[mp[stuid]].gf*0.6+0.5);
	}
	for(int i=0;i&lt;v.size();i++){
		if(v[i].g&gt;=60) ans.push_back(v[i]);
	}
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i&lt;ans.size();i++) 
	    printf(&quot;%s %d %d %d %d\n&quot;,ans[i].s.c_str(),ans[i].gp,ans[i].gm,ans[i].gf,ans[i].g);
	return 0;
}
</code></pre>
<h3 id="a113930-é€»è¾‘é¢˜-unordered_map">A1139(30 é€»è¾‘é¢˜ unordered_map)</h3>
<pre><code>#include&lt;unordered_map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int a,b;
};
bool cmp(const node &amp;i,const node &amp;j){
	return i.a!=j.a? i.a&lt;j.a : i.b&lt;j.b;
}
unordered_map&lt;int ,bool&gt; isfri;
int main(){
	int n,m,k,c,d;
	cin&gt;&gt;n&gt;&gt;m;
	string a,b;
	vector&lt;int&gt; v[10000];
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;a&gt;&gt;b;
		if(a.length()==b.length()) {
			v[abs(stoi(a))].push_back(abs(stoi(b)));
			v[abs(stoi(b))].push_back(abs(stoi(a)));
		}
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
	}
	cin&gt;&gt;k;
	while(k--){
		vector&lt;node&gt; ans;
		cin&gt;&gt;c&gt;&gt;d;
		for(int i=0;i&lt;v[abs(c)].size();i++){
			for(int j=0;j&lt;v[abs(d)].size();j++){
				if(v[abs(c)][i]==abs(d)||v[abs(d)][j]==abs(c)) continue;
				if(isfri[v[abs(c)][i]*10000+v[abs(d)][j]]==true) ans.push_back(node{v[abs(c)][i],v[abs(d)][j]});
			}
		}
		sort(ans.begin(),ans.end(),cmp);
		cout&lt;&lt;ans.size()&lt;&lt;endl;
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %04d\n&quot;,ans[i].a,ans[i].b);
	}
	return 0;
}
</code></pre>
<h3 id="a1140">A1140</h3>
<pre><code>#include&lt;iostream&gt; 
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	int n,j;
	cin&gt;&gt;s&gt;&gt;n;
	for(int x=1;x&lt;n;x++){
       string ans;
       for(int i=0;i&lt;s.length();i=j){
       	for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
       	ans+=s[i]+to_string(j-i);
	   }
	   s=ans;
	}
	cout&lt;&lt;s;
	return 0;
} 
</code></pre>
<h3 id="a1141">A1141</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt; 
#include&lt;map&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	string name;
	double totalscore;
	int num;
}school[maxn];
bool cmp(node a,node b){
	if((int)a.totalscore!=(int)b.totalscore) return (int)a.totalscore&gt;(int)b.totalscore;
	else if(a.num!=b.num) return a.num&lt;b.num;
	else return a.name&lt;b.name;
}
map&lt;string,int&gt; s;
int main(){
	int n,num=0;
	double score;
	string id,schoolname;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;maxn;i++){
		school[i].totalscore=0;
		school[i].num=0;
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;id&gt;&gt;score&gt;&gt;schoolname;
		for(int j=0;j&lt;schoolname.size();j++){
			if(isupper(schoolname[j])) schoolname[j]+=32;
		}
		if(s.count(schoolname)==0){
			s[schoolname]=num;
			school[s[schoolname]].name=schoolname;
			num++;
		}
		if(id[0]=='B') score=score/1.5;
		if(id[0]=='T') score=score*1.5;
		school[s[schoolname]].totalscore+=score;
		school[s[schoolname]].num++;
	}
	cout&lt;&lt;num&lt;&lt;endl;
	sort(school,school+num,cmp);
	int r=1;
	printf(&quot;%d %s %d %d\n&quot;,r,school[0].name.c_str(),(int)school[0].totalscore,school[0].num);
	for(int i=1;i&lt;num;i++){
		if((int)school[i].totalscore!=(int)school[i-1].totalscore) r=i+1;
		printf(&quot;%d %s %d %d\n&quot;,r,school[i].name.c_str(),(int)school[i].totalscore,school[i].num);
	}
	return 0;
}
</code></pre>
<h3 id="a114225-æ— å‘å®Œå…¨å›¾-æœ€å¤§å­å›¾-ä¸¤ç‚¹ç›¸è¿">A1142(25 æ— å‘å®Œå…¨å›¾ æœ€å¤§å­å›¾  ä¸¤ç‚¹ç›¸è¿)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int g[210][210]={0};
	int nv,ne,v1,v2,k,n;
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	for(int i=0;i&lt;ne;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=1;
		g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int hash[nv+1]={0};
		int ismax=1,iscli=1;
		scanf(&quot;%d&quot;,&amp;n);
		vector&lt;int&gt; v(n);
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			hash[v[i]]=1;
		}
		for(int i=0;i&lt;n-1;i++){
			for(int j=i+1;j&lt;n;j++){
				if(g[v[i]][v[j]]==0)
				iscli=0;
				break;
			}
		}
		if(iscli==0) {
			printf(&quot;Not a Clique\n&quot;);
			continue;
		}
		for(int i=1;i&lt;=nv;i++){
			if(hash[i]==0){
				for(int j=0;j&lt;n;j++){
					if(g[v[j]][i]==0) break;
					if(j==n-1) ismax=0;
				}
			}
		}
		if(iscli==1&amp;&amp;ismax==1) printf(&quot;Yes\n&quot;);
		else if(iscli==1&amp;&amp;ismax==0) printf(&quot;Not Maximal\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1143">A1143</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
const int maxn = 10010;
map&lt;int, bool&gt; node;
int main() {
	int m, n, v, u, a;
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	vector&lt;int&gt; pre(n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;pre[i]);
		node[pre[i]] = true;
	}
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		for (int j = 0; j &lt; n; j++) {
			a = pre[j];
			if ((a &gt;= u &amp;&amp; a &lt;= v) || (a &lt;= u &amp;&amp; a &gt;= v)) break;
		}
		if (node.count(u) == 0 &amp;&amp; node.count(v) == 0) printf(&quot;ERROR: %d and %d are not found.\n&quot;, u, v);
		else if (node.count(u) == 0 || node.count(v) == 0) printf(&quot;ERROR: %d is not found.\n&quot;, node.count(u) == 0?u:v);
		else if ((a &lt; u &amp;&amp; a &gt; v) || (a &gt; u &amp;&amp; a &lt; v)) printf(&quot;LCA of %d and %d is %d.\n&quot;, u, v, a);
		else if (a == v || a == u) printf(&quot;%d is an ancestor of %d.\n&quot;, a, a == v ? u : v);
	}
	return 0;
}
</code></pre>
<h3 id="a114525-hash-å¹³æ–¹æ¢æŸ¥">A1145(25 hash å¹³æ–¹æ¢æŸ¥)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x){
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,a;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		int flag=0;
		for(int j=0;j&lt;msize;j++){
			int pos=(a+j*j)%msize;
			if(v[pos]==0){
				flag=1;
				v[pos]=a;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,a);
	}
	int cnt=0,temp;
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//æ³¨æ„è¿™é‡Œçš„&lt;=ï¼Œå› ä¸ºè¦å›åˆ°åˆå§‹çš„ä½ç½®æ‰çŸ¥é“æ˜¯å¦èƒ½æ’å…¥
			cnt++;
			if(v[(temp+j*j)%msize]==temp||v[(temp+j*j)%msize]==0) break;
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
    return 0;
}
</code></pre>
<h3 id="a1144">A1144</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
int main(){
    int n,temp,num=0;
    map&lt;int,int&gt; s;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++) {
        scanf(&quot;%d&quot;,&amp;temp);
        s[temp]++;
    }
    while(++num){
        if(s.count(num)==0){
            printf(&quot;%d&quot;,num);
            break;
        }
    }
    return 0;
}
</code></pre>
<h3 id="a1146åˆ¤æ–­æ˜¯å¦ä¸ºæ‹“æ‰‘æ’åºåºåˆ—">A1146(åˆ¤æ–­æ˜¯å¦ä¸ºæ‹“æ‰‘æ’åºåºåˆ— )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int a, b, flag = 0, in[1010] = { 0 }, n, m, k;
	vector&lt;int&gt; v[1010];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		v[a].push_back(b);
		in[b]++;
	}
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		int judge = 1;
		vector&lt;int&gt; query(in, in + n + 1);
		for (int j = 0; j &lt; n; j++) {
			scanf(&quot;%d&quot;, &amp;a);
			if (query[a] != 0) judge = 0;
			for (int x = 0; x &lt; v[a].size(); x++) query[v[a][x]]--;
		}
    if(judge==1) continue;
		else if (flag == 1 &amp;&amp; judge == 0) printf(&quot; %d&quot;, i);
		else if (flag == 0 &amp;&amp; judge == 0) printf(&quot;%d&quot;, i);
		flag = 1;
	}
	return 0;
}
</code></pre>
<h3 id="a114730-åˆ¤æ–­å¤§é¡¶å †å°é¡¶å †-ååºéå†">A1147(30  åˆ¤æ–­å¤§é¡¶å †å°é¡¶å † ååºéå†)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int m, n, num = 0;
vector&lt;int&gt;v;
void dfs(int index) {//ååºéå†
	if (index &gt; n) return;
	dfs(index * 2);
	dfs(index * 2 + 1);
	printf(&quot;%d&quot;, v[index]);
	if (num &lt; n - 1)printf(&quot; &quot;);
	num++;
}
int main() {
	scanf_s(&quot;%d%d&quot;, &amp;m, &amp;n);
	while (m--) {
		v.resize(n+1);
		bool flagmin = true, flagmax = true;
		for (int i = 1; i &lt;= n; i++) scanf_s(&quot;%d&quot;, &amp;v[i]);
		for (int i = 2; i &lt;= n; i++) {
			if (v[i] &gt;= v[i / 2]) flagmax = false;
			if (v[i] &lt;= v[i / 2]) flagmin = false;
		}
		if (flagmin) printf(&quot;Min Heap\n&quot;);
		else if (flagmax) printf(&quot;Max Heap\n&quot;);
		else if (flagmax == false &amp;&amp; flagmin == false) printf(&quot;Not Heap\n&quot;);
		dfs(1);
		num = 0;
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1148ç‹¼äººæ€-æ‰¾åˆ°ä¸¤ä¸ªç‹¼äºº">A1148(ç‹¼äººæ€ æ‰¾åˆ°ä¸¤ä¸ªç‹¼äºº)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];
	for(int i=1;i&lt;=n;i++){
		for(int j=i+1;j&lt;=n;j++){
			vector&lt;int&gt; lie,a(n+1,1);
			a[i]=a[j]=-1;
			for(int k=1;k&lt;=n;k++){
				if(v[k]*a[abs(v[k])]&lt;0) lie.push_back(k);
			}
			if(lie.size()==2&amp;&amp;(a[lie[0]]+a[lie[1]])==0){
				cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;No Solution&quot;;
	return 0;
}
</code></pre>
<h3 id="a1149">A1149</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
map&lt;int, vector&lt;int&gt; &gt;danger;
int main() {
	int n, m, k, d1, d2;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	vector&lt;int&gt; G(n + 1);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;d1, &amp;d2);
		danger[d1].push_back(d2);
		danger[d2].push_back(d1);
	}
	for (int i = 0; i &lt; m; i++) {
		bool flag = false;
        vector&lt;int&gt; G(n + 1);
		int exist[100000] = { 0 };
		scanf(&quot;%d&quot;, &amp;k);
		for (int j = 0; j &lt; k; j++) {
			scanf(&quot;%d&quot;, &amp;G[j]);
			exist[G[j]] = 1;
		}
		for (int j = 0; j &lt; k; j++) {
			for (int p = 0; p &lt; danger[G[j]].size(); p++) {
				if (exist[danger[G[j]][p]] == 1) flag = true;
			}
		}
		if (flag == false) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115025-åˆ¤æ–­å¾ªç¯å›¾-è¾“å‡ºæœ€å°è·¯å¾„">A1150(25 åˆ¤æ–­å¾ªç¯å›¾ è¾“å‡ºæœ€å°è·¯å¾„)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
int main(){
	int n,m,k,mindis=1000000000,ansid;
	int g[210][210]={0};
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		int v1,v2,d;
		scanf(&quot;%d%d%d&quot;,&amp;v1,&amp;v2,&amp;d);
		g[v1][v2]=d;
		g[v2][v1]=d;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int y=1;y&lt;=k;y++){
		int cnt,flag=1,index,sum=0;
		scanf(&quot;%d&quot;,&amp;cnt);
		set&lt;int&gt;s;
		vector&lt;int&gt; v(cnt);
		for(int i=0;i&lt;cnt;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			s.insert(v[i]);
		} 
		for(int i=0;i&lt;cnt-1;i++){
			if(g[v[i]][v[i+1]]==0) flag=0;
			sum+=g[v[i]][v[i+1]];
		}
		if(flag==0) printf(&quot;Path %d: NA (Not a TS cycle)\n&quot;,y);
		else if(v[0]!=v[cnt-1]||s.size()!=n) printf(&quot;Path %d: %d (Not a TS cycle)\n&quot;,y,sum);
		else if(cnt!=n+1){
			if(sum&lt;mindis){
				mindis=sum;
				ansid=y;
			}
			printf(&quot;Path %d: %d (TS cycle)\n&quot;,y,sum);
		}else{
			if(sum&lt;mindis){
				mindis=sum;
				ansid=y;
			}
			printf(&quot;Path %d: %d (TS simple cycle)\n&quot;,y,sum);
		}
	}
	printf(&quot;Shortest Dist(%d) = %d&quot;,ansid,mindis);
	return 0;
}
</code></pre>
<h3 id="a1151">A1151</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10010;
map&lt;int,int&gt; pos;
vector&lt;int&gt; ins,pre;
void lca(int inl,int inr,int preroot,int a,int b){
	if(inl&gt;inr) return;
	int inroot=pos[pre[preroot]],ain=pos[a],bin=pos[b];
	if(ain&lt;inroot&amp;&amp;bin&lt;inroot) lca(inl,inroot-1,preroot+1,a,b);
	else if((ain&lt;inroot&amp;&amp;bin&gt;inroot)||(ain&gt;inroot&amp;&amp;bin&lt;inroot)){
		printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,ins[inroot]);
	}
	else if(ain&gt;inroot&amp;&amp;bin&gt;inroot) lca(inroot+1,inr,preroot+1+(inroot-inl),a,b);
	else if(ain==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);
	else if(bin==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);
}
int main(){
	int m,n,a,b;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	ins.resize(n + 1), pre.resize(n + 1);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;ins[i]);
		pos[ins[i]]=i;
	}
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,a);
		if(pos.count(b)==0&amp;&amp;pos.count(a)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);
		if(pos.count(a)!=0&amp;&amp;pos.count(b)!=0) lca(1,n,1,a,b);
	}
	return 0;
}
</code></pre>
<h3 id="a115325-æ¨¡æ‹Ÿ-æ’åºå¼•ç”¨ä¼ å‚-vector-unordered_map">A1153(25 æ¨¡æ‹Ÿ æ’åºå¼•ç”¨ä¼ å‚ vector unordered_map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	string info;
	int score;
};
bool cmp(const node&amp; a, const node&amp; b) {
	return a.score != b.score ? a.score &gt; b.score : a.info &lt; b.info;
}
int main() {
	int n, m, type;
	string t;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; v(n);
	for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].info &gt;&gt; v[i].score;
	for (int i = 1; i &lt;= m; i++) {
		vector&lt;node&gt; ans;
		cin &gt;&gt; type &gt;&gt; t;
		printf(&quot;Case %d: %d %s\n&quot;, i, type, t.c_str());
		int sum = 0, cnt = 0;
		if (type == 1) {
			for (int j = 0; j &lt; n; j++) {
				if (t[0] == v[j].info[0]) ans.push_back(v[j]);
			}
		}
		else if (type == 2) {
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(1, 3) == t) {
					cnt++;
					sum += v[j].score;
				}
			}
			if (cnt != 0) printf(&quot;%d %d\n&quot;, cnt, sum);
		}
		else {
			unordered_map&lt;string, int&gt; m;
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(4, 6) == t) m[v[j].info.substr(1, 3)]++;
			}
			for (auto it : m) ans.push_back({ it.first,it.second });
		}
		sort(ans.begin(), ans.end(), cmp);
		for (int j = 0; j &lt; ans.size(); j++) printf(&quot;%s %d\n&quot;, ans[j].info.c_str(), ans[j].score);
		if (((type == 1 || type == 3) &amp;&amp; ans.size() == 0) || (type == 2 &amp;&amp; cnt == 0)) printf(&quot;NA\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115425-å›¾-è¾¹çš„ä¸¤ç«¯ç‚¹çš„åˆ¤æ–­">A1154(25 å›¾  è¾¹çš„ä¸¤ç«¯ç‚¹çš„åˆ¤æ–­  )</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
struct node {
	int v1, v2;
};
int main() {
	int n, m, k;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; g(10010);
	for (int i = 0; i &lt; m; i++) cin &gt;&gt; g[i].v1 &gt;&gt; g[i].v2;
	cin &gt;&gt; k;
	for (int i = 0; i &lt; k; i++) {
		set&lt;int&gt; color; 
		vector&lt;int&gt; e(n);
		bool flag = true;
		for (int j = 0; j &lt; n; j++) {
			cin &gt;&gt; e[j];
			color.insert(e[j]);
		}
		for (int j = 0; j &lt; m; j++) {
			if (e[g[j].v1] == e[g[j].v2]) flag = false;
		}
		if (flag == false) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else cout &lt;&lt; color.size() &lt;&lt; &quot;-coloring&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a115530-å®Œå…¨äºŒå‰æ ‘-åˆ¤æ–­å¤§é¡¶å †å°é¡¶å †-dfs-æ‰“å°è·¯å¾„">A1155(30 å®Œå…¨äºŒå‰æ ‘  åˆ¤æ–­å¤§é¡¶å †å°é¡¶å † dfs  æ‰“å°è·¯å¾„)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;v;
int n, a[1010];
void dfs(int index) {
	if (index * 2 &gt; n &amp;&amp; index * 2 + 1 &gt; n) {
		if (index &lt;= n) {
			for (int i = 0; i &lt; v.size(); i++) {
				if (i != 0) printf(&quot; &quot;);
				printf(&quot;%d&quot;, v[i]);
			}
			printf(&quot;\n&quot;);
		}
	}
	else {
		v.push_back(a[index * 2 + 1]);
		dfs(index * 2 + 1);
		v.pop_back();
		v.push_back(a[index * 2]);
		dfs(index * 2);
		v.pop_back();
	}
}
int main() {
	bool minflag = true, maxflag = true;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	v.push_back(a[1]);
	for (int i = 2; i &lt;= n; i++) {
		if (a[i] &gt;= a[i / 2]) maxflag = false;
		if (a[i] &lt;= a[i / 2]) minflag = false;
	}
	dfs(1);
	if (minflag) printf(&quot;Min Heap&quot;);
	else if (maxflag) printf(&quot;Max Heap&quot;);
	else if (maxflag == false &amp;&amp; minflag == false) printf(&quot;Not Heap&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++(PAT)åˆ·é¢˜ç¬”è®°æ±‡æ€»]]></title>
        <id>https://liuxbo.github.io/post/cshua-ti-bi-ji/</id>
        <link href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">
        </link>
        <updated>2020-05-06T13:20:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-cå­—ç¬¦ä¸²æ•°ç»„çš„0é—®é¢˜">1. c++å­—ç¬¦ä¸²æ•°ç»„çš„\0é—®é¢˜</h3>
<pre><code>#include&lt;stdio.h&gt;
int main() {
	char str1[8] = { 'd','e','d','g','o' };
	char str2[5] = { 'd','e','d','g','o' };
	printf(&quot;%d\n&quot;, sizeof(str1));
	printf(&quot;%d\n&quot;, sizeof(str2));
	return 0;
}
</code></pre>
<p>![](C:\Users\lxb\Pictures\Camera Roll\KG1V`[}F4D7YE5L_NIJ289O.png)</p>
<p>å¯¹äºå­—ç¬¦ä¸²æ•°ç»„ï¼Œå½“å®šä¹‰æ—¶ç›´æ¥å¯¹å…¶èµ‹å€¼ï¼Œæ— è®ºå…ƒç´ æ˜¯å¦å æ»¡æ•°ç»„ï¼Œå…¶å‚¨å­˜çš„å­—ç¬¦ä¸ªæ•°éƒ½æ˜¯æ•°ç»„çš„å…ƒç´ ä¸ªæ•°ï¼Œæœªå æ»¡æ—¶ä¼šè‡ªåŠ¨ç”¨\0è¡¥å…¨</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	puts(str);
	return 0;
}
</code></pre>
<p>è¾“å‡ºä¼šä¹±ç </p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clxb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191205103056228.png" alt="image-20191205103056228" loading="lazy"></figure>
<p>ä½¿ç”¨<code>getchar</code>è¦åœ¨è¾“å…¥çš„æ¯ä¸ªå­—ç¬¦ä¸²åé¢åŠ \0,ä¾‹å¦‚</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	str[5] = '\0';
	puts(str);
	return 0;
}
</code></pre>
<h3 id="2æ•°ç»„ç›¸å…³é—®é¢˜">2.æ•°ç»„ç›¸å…³é—®é¢˜</h3>
<ul>
<li>
<p>åè½¬ä¸€ä¸ªä¸€ç»´æ•°ç»„</p>
<pre><code>#include &lt;cstdio&gt;
int main() {
	int a[5] = { 5,2,3,6,9 };
	for (int i = 0, j = 4; i &lt;= j; i++, j--) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	for(int i=0;i&lt;5;i++)
	printf(&quot;%d&quot;, a[i]);
	return 0;
}
</code></pre>
</li>
<li>
<p>æ‰¾äºŒç»´(æˆ–ä¸‰ç»´)æ•°ç»„ä¸­çš„â€œå—â€(æ¯”å¦‚ç›¸é‚»çš„è‹¥å¹²ä¸ªæ•°ç»„å…ƒç´ 1)</p>
<p>ç”¨BFSï¼Œè¦è®¾ç½®å¢é‡æ•°ç»„ï¼Œ</p>
<p>å¯¹äºä¸€ç»´çš„æƒ…å†µï¼Œå¯ä»¥è®¾ç½®</p>
<pre><code>int X[4]={0,0,1,-1};
int Y[4]={1,-1,0,0};
</code></pre>
<p>ä»¥ä¾¿äºè®¿é—®ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®</p>
<p>å¯¹äºä¸‰ç»´çš„æƒ…å†µï¼Œå¯ä»¥è®¾ç½®</p>
<pre><code>int X[6]={0,0,0,0,1,-1};
int Y[6]={0,0,1,-1,0,0};
int Z[6]={1,-1,0,0,0,0};
</code></pre>
<p>å¯¹åº”å‰åå·¦å³ä¸Šä¸‹6ä¸ªä½ç½®</p>
</li>
</ul>
<h3 id="3å­—ç¬¦ä¸²é—®é¢˜">3.å­—ç¬¦ä¸²é—®é¢˜</h3>
<ul>
<li>
<p><code>scanf (&quot;%s&quot;)</code>è¯†åˆ«ç©ºæ ¼ä½œä¸ºå­—ç¬¦ä¸²ç»“å°¾</p>
<p><code>getchar</code>  <code>putchar</code> ç”¨æ¥è¾“å…¥è¾“å‡ºå•ä¸ªå­—ç¬¦</p>
</li>
<li>
<p><code>cin</code> è¯»å…¥å­—ç¬¦ä¸²æ—¶ï¼Œä»¥ç©ºæ ¼ä¸ºåˆ†éš”ç¬¦ï¼Œå¦‚æœæƒ³è¯»å…¥ä¸€æ•´è¡Œå­—ç¬¦ä¸²ï¼Œç”¨<code>getline(cin,s)</code>ï¼Œæ³¨æ„å‰é¢å¦‚æœè¾“å…¥æ•°å­—nï¼Œä¸€å®šè¦æ³¨æ„<code>scanf(&quot;%d\n&quot;,&amp;n);</code> è¿™æ ·å†™ï¼Œé˜²æ­¢getlineè¯»å…¥é”™è¯¯</p>
</li>
<li>
<p>åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸€æ ·æ—¶å¯ä»¥ç”¨<code>strcmp()==0</code>ï¼Œè¯¥å‡½æ•°å…¶ä¸­ä¸€ä¸ªå‚æ•°å¯ä»¥ä¸ºå­—ç¬¦æ•°ç»„çš„åç§°</p>
</li>
<li>
<p>ä½¿â½¤ <code>stoi()</code> ã€ <code>stod()</code>  å¯ä»¥å°†å­—ç¬¦ä¸² string è½¬åŒ–ä¸ºå¯¹åº”çš„ int å‹ã€ double å‹å˜é‡</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//è¾“å‡º123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//è¾“å‡º123.44
 return 0;
}
</code></pre>
<p><code>stoi</code>å¦‚æœé‡åˆ°çš„æ˜¯â¾®æ³•è¾“â¼Šï¼ˆâ½å¦‚<code>stoi(&quot;123.4&quot;)</code>ï¼Œ123.4ä¸æ˜¯â¼€ä¸ªintå‹å˜é‡ï¼‰ï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„     æ•°å­—ï¼Œç›´åˆ°é‡åˆ°ä¸æ˜¯æ•°å­—ä¸ºâ½Œ (æ‰€ä»¥è¯´å¦‚æœæ˜¯æµ®ç‚¹å‹ï¼Œä¼šæˆªå–å‰â¾¯çš„æ•´æ•°éƒ¨åˆ†) 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯</p>
<p><code>stod</code>å¦‚æœæ˜¯â¾®æ³•è¾“â¼Šï¼š 1.ä¼šâ¾ƒåŠ¨æˆªå–æœ€å‰â¾¯çš„æµ®ç‚¹æ•°ï¼Œç›´åˆ°é‡åˆ°ä¸æ»¡â¾œæµ®ç‚¹æ•°ä¸ºâ½Œ 2.å¦‚æœæœ€å‰â¾¯ä¸æ˜¯æ•°å­—æˆ–è€…â¼©æ•°ç‚¹ï¼Œä¼šè¿â¾æ—¶å‘â½£é”™è¯¯ 3.å¦‚æœæœ€å‰â¾¯æ˜¯â¼©æ•°ç‚¹ï¼Œä¼šâ¾ƒåŠ¨è½¬åŒ–ååœ¨å‰â¾¯è¡¥0</p>
<p>ä¸ä»…æœ‰<code>stoi</code>ã€<code>stod</code>ä¸¤ç§ï¼Œç›¸åº”çš„è¿˜æœ‰ï¼š</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
</li>
<li>
<p><code>to_string()</code>å°†æ•°å€¼è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚è¿”å›å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚å¤´æ–‡ä»¶åŒæ ·ä¸º<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  å¦‚æœæƒ³â½¤<code>printf</code>è¾“å‡ºstringï¼Œéœ€è¦åŠ â¼€ ä¸ª<code>.c_str()</code></p>
</li>
<li>
<p>å­—ç¬¦ä¸²å½¢å¼çš„ä¸¤ä¸ªæ•°å­—ç›¸åŠ </p>
<pre><code>string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
<li>
<p>æ¶‰åŠåˆ°çš„é¢˜ç›®:</p>
<p>A1035ï¼ŒA1077,A1082,A1093,A1061ï¼Œ<strong>A1073</strong>(ç§‘å­¦è®¡æ•°æ³•)ï¼ŒA1077(å…¬å…±åç¼€)ï¼Œ<strong>A1082</strong>,</p>
<p>A1112, A1152, A1140  A1136(å›æ–‡ä¸²ã€å­—ç¬¦ä¸²) ã€ A1132(20 æ°´é¢˜)</p>
</li>
</ul>
<h3 id="4ä¸­åºåºåˆ—å’Œ-ååºæˆ–å…ˆåºæˆ–å±‚åº-æ­é…-ç¡®å®šä¸€æ£µäºŒå‰æ ‘">4.ä¸­åºåºåˆ—å’Œ ååºæˆ–å…ˆåºæˆ–å±‚åº æ­é…ï¼Œ ç¡®å®šä¸€æ£µäºŒå‰æ ‘</h3>
<ul>
<li>
<p>å…ˆç”±ååºåºåˆ—æˆ–å…ˆåºåºåˆ—ç¡®å®šæ ¹èŠ‚ç‚¹</p>
</li>
<li>
<p>åˆ©ç”¨åœ¨å…ˆåºæˆ–ååºåºåˆ—æ‰¾åˆ°çš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œç¡®å®šä¸­åºåºåˆ—ä¸­æ ¹èŠ‚ç‚¹çš„ä½ç½®</p>
</li>
<li>
<p>ç¡®å®šå·¦å­æ ‘ã€å³å­æ ‘çš„ å…ˆåº/ååº  å’Œä¸­åºåºåˆ—ï¼ˆå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„ä¸ªæ•°åªèƒ½åœ¨ä¸­åºåºåˆ—ä¸­å¾—çŸ¥ï¼‰</p>
</li>
<li>
<p>åˆ†åˆ«å‘å·¦å­©å­å’Œå³å­©å­é€’å½’æ„å»º</p>
<p>æ³¨æ„é€’å½’æ—¶åŒºé—´çš„ä¹¦å†™æ ¼å¼</p>
</li>
</ul>
<h3 id="5-æ˜ å°„é—®é¢˜hash-map-æ•£åˆ—">5. æ˜ å°„é—®é¢˜(hash ã€mapã€æ•£åˆ—...)</h3>
<ul>
<li>
<p>ç›´æ¥å¼€æ•°ç»„ï¼Œå°†æ•°ç»„ä¸‹æ ‡ä¸ä¸‹æ ‡å¯¹åº”çš„å†…å®¹ä½œä¸ºæ˜ å°„,ASCIIç è¡¨æœ‰128ä¸ªå­—ç¬¦ï¼Œå¯¹äºä¸€äº›é¢˜ç›®å¯ä»¥ç›´æ¥å¼€<code>hashtable[128]</code>æ•°ç»„ï¼Œå…³äºå…¶ä¸‹æ ‡ï¼Œå¯ä»¥ç”¨ä»¥ä¸‹å‡½æ•°è·å¾—</p>
<pre><code>int change(char c){
    if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';
    if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'+10;
    if(c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'+36;
}
</code></pre>
</li>
<li>
<p>å­—ç¬¦ä¸²hash</p>
<ul>
<li>
<pre><code>for(int i = 0; i &lt; 3; i++)  id = 26 * id + (name[i] - 'A'); //å¤§å†™å­—æ¯å­—ç¬¦ä¸²æ˜ å°„ä¸ºæ•´æ•°
</code></pre>
</li>
</ul>
</li>
<li>
<p>æ¶‰åŠåˆ°çš„é¢˜ç›®</p>
<p>A1084,A1092,A1041,A1050ï¼ŒA1048  <strong>A1129(25 setçš„åº”ç”¨ ç»“æ„ä½“å†…è¿ç®—ç¬¦é‡è½½)</strong></p>
<p>A1145(25 hash å¹³æ–¹æ¢æŸ¥)</p>
</li>
</ul>
<h3 id="6-stlå®¹å™¨">6. <code>STL</code>å®¹å™¨</h3>
<ul>
<li>
<p>vector</p>
<p>å®šä¹‰ä¸€ä¸ªmè¡Œnåˆ—çš„æ•°ç»„ <code>vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n));</code></p>
<pre><code>vector&lt;int&gt; vec1(4,1);              //vec1çš„å†…å®¹ä¸º1,1,1,1
vector&lt;int&gt; vec1{ 1, 2, 3, 4, 5, 6 };       //vec1å†…å®¹1,2ï¼Œ3,4,5,6
</code></pre>
<pre><code>vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //å°†arr[1]~arr[4]èŒƒå›´å†…çš„å…ƒç´ ä½œä¸ºvecçš„åˆå§‹å€¼
</code></pre>
<pre><code>vector&lt;int&gt; vec(arr, arr + 5);   //å°†arræ•°ç»„çš„å…ƒç´ ç”¨äºåˆå§‹åŒ–vecå‘é‡
//è¯´æ˜ï¼šå½“ç„¶ä¸åŒ…æ‹¬arr[4]å…ƒç´ ï¼Œæœ«å°¾æŒ‡é’ˆéƒ½æ˜¯æŒ‡ç»“æŸå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œ
//è¿™ä¸ªä¸»è¦æ˜¯ä¸ºäº†å’Œvec.end()æŒ‡é’ˆç»Ÿä¸€ã€‚
</code></pre>
</li>
<li>
<p>priority_queue</p>
<p><code>priority_queue&lt;int,vector &lt; int &gt; ,greater&lt; int&gt; &gt;</code>è¡¨ç¤ºæ•°å­—è¶Šå°çš„ä¼˜å…ˆçº§è¶Šå¤§ï¼Œä¼˜å…ˆæ”¾åœ¨é˜Ÿé¦–</p>
<p><code>priority_queue&lt;int,vector &lt; int &gt; ,less&lt; int&gt; &gt;</code>è¡¨ç¤ºæ•°å­—è¶Šå¤§çš„ä¼˜å…ˆçº§è¶Šå¤§ï¼Œä¼˜å…ˆæ”¾åœ¨é˜Ÿé¦–ï¼Œ</p>
<p>è¯¥å®¹å™¨åªèƒ½é€šè¿‡top()è®¿é—®é˜Ÿé¦–å…ƒç´ ï¼Œpush()è¿›é˜Ÿï¼Œpop()å‡ºé˜Ÿï¼Œempty()æ£€ç©º</p>
</li>
<li>
<p>å¼‚åŒ</p>
<p>åªæœ‰<code>vector</code>å’Œ<code>string</code>æ”¯æŒ<code>*(it+i)</code>çš„è®¿é—®æ–¹å¼ ,<code>set</code>åªèƒ½é€šè¿‡è¿­ä»£å™¨è®¿é—®(å³*it)ï¼Œ</p>
<p><code>map</code> ã€<code>string</code>å’Œ<code>vector</code>æ”¯æŒä¸‹æ ‡è®¿é—®å’Œè¿­ä»£å™¨è®¿é—®ã€‚</p>
<p>mapä¸setå†…éƒ¨éƒ½ä¼šè‡ªåŠ¨é€’å¢æ’åºï¼Œ(è¿™é‡ŒæŒ‡mapçš„keyï¼‰ï¼Œå¹¶ä¸”setçš„å…ƒç´ å€¼ä¸mapçš„keyåœ¨å…¶å„è‡ªå†…éƒ¨éƒ½æ˜¯å”¯ä¸€çš„ï¼ŒåŒ…æ‹¬æ•°å­—å’Œå­—</p>
</li>
<li>
<p>å¸¸ç”¨å‡½æ•°</p>
<ul>
<li>
<p><code>string</code>  <code>s.begin() s.end()</code>  <code>s.c_str()</code> <code>s.length() s.size()</code> <code>s.substr()</code></p>
</li>
<li>
<p><code>map</code></p>
<p>ä½¿ç”¨countï¼Œè¿”å›çš„æ˜¯è¢«æŸ¥æ‰¾å…ƒç´ çš„ä¸ªæ•°ã€‚å¦‚æœæœ‰ï¼Œè¿”å›1ï¼›å¦åˆ™ï¼Œè¿”å›0ã€‚æ³¨æ„ï¼Œmapä¸­ä¸å­˜åœ¨ç›¸åŒå…ƒç´ ï¼Œæ‰€ä»¥è¿”å›å€¼åªèƒ½æ˜¯1æˆ–0ã€‚count(keyå€¼)</p>
<p>éå†mapä¸­æ‰€æœ‰çš„å…ƒç´ <code>for (auto it : mp)</code>,mpä¸ºmapå®¹å™¨å˜é‡åï¼Œç”¨<code>it.first</code>å’Œ<code>it.second</code>è®¿é—®æ¯ä¸ªkeyå’Œç›¸åº”çš„value</p>
<p>find() erase() size() clear()</p>
</li>
</ul>
</li>
<li>
<p>æ³¨æ„</p>
<p>begin()å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨,æŒ‡å‘å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå…ƒç´ .</p>
<p>end()å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘å­—ç¬¦ä¸²çš„æœ«å°¾(æœ€åä¸€ä¸ªå­—ç¬¦çš„ä¸‹ä¸€ä¸ªä½ç½®).</p>
<p>rbegin()è¿”å›ä¸€ä¸ªé€†å‘è¿­ä»£å™¨ï¼ŒæŒ‡å‘å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå­—ç¬¦ã€‚</p>
<p>rend()å‡½æ•°è¿”å›ä¸€ä¸ªé€†å‘è¿­ä»£å™¨ï¼ŒæŒ‡å‘å­—ç¬¦ä¸²çš„å¼€å¤´ï¼ˆç¬¬ä¸€ä¸ªå­—ç¬¦çš„å‰ä¸€ä¸ªä½ç½®ï¼‰ã€‚</p>
<p>vectoræ•°ç»„å¯ä»¥ç›´æ¥ç”¨==åˆ¤æ–­ä¸¤ä¸ªæ•°ç»„æ˜¯å¦ç›¸åŒ</p>
<p>stringç±»å‹å¯ä»¥ç›´æ¥ç”¨&lt;  æˆ– &gt; æˆ–== ç›´æ¥è¿›è¡Œå­—å…¸åºçš„æ¯”è¾ƒï¼Œè€Œcharæ•°ç»„å¿…é¡»ç”¨strcmpæ¯”è¾ƒ</p>
<p>vectorä½¿ç”¨ä¸‹æ ‡è®¿é—®å‰æ³¨æ„å…ˆresizeä¸€ä¸‹</p>
</li>
</ul>
<p>A1039,A1047,A1063,A1060,A1100,A1054ï¼ŒA1071,A1022 A1120 ,A1149(mapã€vector)</p>
<p>A1121 (25 mapã€setåº”ç”¨)   A1137(25 map æ’åº)    A1139(30 é€»è¾‘é¢˜ unordered_map)</p>
<h3 id="7-è¾“å…¥è¾“å‡ºé—®é¢˜">7. è¾“å…¥è¾“å‡ºé—®é¢˜</h3>
<p><code>scanf</code>ä¸­ ï¼Œ<code>long long</code>å‹ ï¼š<code>scanf(&quot;%lld&quot;,&amp;n)</code> , <code>double</code>å‹ï¼š<code>scanf(&quot;lf&quot;,&amp;n)</code></p>
<p><code>printf</code>ä¸­ï¼Œ<code>long long</code> å‹ï¼š<code>printf(&quot;%lld&quot;,n)</code>   , <code>double</code> å‹ï¼š<code>printf(&quot;%f&quot;,n)</code></p>
<p>è‹¥<code>getline(cin, str);</code>å‰æœ‰<code>scanf(&quot;%d%*c&quot;, &amp;n);</code>è¾“å…¥ï¼Œå¯ä»¥ç”¨%*<em>cå¿½ç•¥ä¸€ä¸ªå­—ç¬¦å‹(æ¯”å¦‚æ¢è¡Œ),æˆ–è€…%</em> *då¿½ç•¥ä¸€ä¸ªæ•°å­—å‹ã€‚ä¹Ÿå¯ä»¥ç”¨getchar()å¸æ”¶æ‰å­—ç¬¦</p>
<p><code>scanf(&quot;%*c%d&quot;,&amp;n);å¯ä»¥å¸æ”¶æ‰ä¸Šä¸€è¡Œæœ«å°¾çš„çš„æ¢è¡Œç¬¦</code></p>
<p>è‹¥è¾“å…¥æ ¼å¼ä¸ºæ•°å­—<code>ç©ºæ ¼</code> å­—ç¬¦<code>ç©ºæ ¼</code> æ•°å­—ï¼Œå¯ä»¥å†™æˆ<code>scanf(&quot;%d %c %d&quot;)</code> ,å› ä¸ºç©ºæ ¼ä¹Ÿç®—å­—ç¬¦ã€‚</p>
<p>æ³¨æ„stringç±»å‹ç”¨printfè¾“å‡ºæ—¶ä¸€å®šè¦ç”¨c_str()è½¬åŒ–ä¸€ä¸‹</p>
<p><code>sscanf(a, &quot;%lf&quot;, &amp;temp);</code> ä»å·¦åˆ°å³ï¼Œå°†å­—ç¬¦æ•°ç»„aä»¥æµ®ç‚¹æ•°çš„å½¢å¼å­˜åˆ°doubleç±»å‹tempä¸­ï¼›</p>
<p><code>sprintf(b, &quot;%.2f&quot;, temp);</code> ä»å³åˆ°å·¦ï¼Œå°†doubleç±»å‹tempä»¥ä¿ç•™ä¸¤ä½å°æ•°çš„å½¢å¼å­˜åˆ°å­—ç¬¦æ•°ç»„bä¸­</p>
<h3 id="8-æå–æ•°ä¸­çš„å…ƒç´ ">8. æå–æ•°ä¸­çš„å…ƒç´ </h3>
<pre><code>while (b != 0) {
		if (b % 10 == db) pb = pb * 10 + db;
		b = b / 10;
	}
æå–bä¸­çš„é‡å¤æ•°å­—ç»„æˆæ–°çš„æ•°å­— b=38633 ï¼Œdbä¸º3ï¼Œæ–°æ•°å­—ä¸º333
</code></pre>
<h3 id="9-å¸¸ç”¨å‡½æ•°">9. å¸¸ç”¨å‡½æ•°</h3>
<ul>
<li>
<p><code>math.h</code>å¤´æ–‡ä»¶å‡½æ•°</p>
<p><code>fabs(double x)</code>  å–ç»å¯¹å€¼ ï¼Œ</p>
<p><code>floor(double x)</code>å’Œ<code>ceil(double x)</code> ï¼Œåˆ†åˆ«ä¸ºå‘ä¸Šå–æ•´å’Œå‘ä¸‹å–æ•´ï¼Œè¿”å›doubleå‹</p>
<p><code>pow(double r,double p)</code> ç”¨äºè¿”å›r^p</p>
<p><code>sqrt(double x)</code> ,è¿”å›ç®—æ•°å¹³æ–¹æ ¹</p>
<p><code>log(double x)</code> ,è¿”å›ä»¥è‡ªç„¶å¯¹æ•°ä¸ºåº•çš„å¯¹æ•°ï¼Œç”¨æ¢åº•å…¬å¼æ±‚å…·ä½“å¯¹æ•°</p>
<p><code>sin(double x)</code> <code>cos(double x)</code> <code>tan(double x)</code></p>
<p><code>asin(double x)</code> <code>acos(double x)</code> <code>atan(double x)</code></p>
<p><code>round(double x)</code> å°†xå››èˆäº”å…¥ï¼Œè¿”å›ä¸ºdoubleå‹</p>
</li>
<li>
<p><code>algorithm</code>å¤´æ–‡ä»¶ä¸‹çš„å‡½æ•°ï¼ŒåŠ <code>using namespace std;</code></p>
<p><code>max(x,y)</code> <code>min(x,y)</code>  <code>abs(x)</code> è¿”å›xçš„ç»å¯¹å€¼ï¼Œxå¿…é¡»ä¸ºæ•´æ•°</p>
<p><code>swap(x,y)</code></p>
<p><code>reverse(it,it2)</code> <code>reverse(a,a+4)</code>  ,å°†æ•°ç»„å…ƒç´ åè½¬</p>
<p><code>next_permutation(a,a+...)</code> ,ç»™å‡ºä¸€ä¸ªåºåˆ—åœ¨å…¨æ’åˆ—ä¸­çš„ä¸‹ä¸€ä¸ªåºåˆ—ï¼Œè¯¥å‡½æ•°åœ¨åˆ°è¾¾å…¨æ’åˆ—çš„æœ€åä¸€ä¸ªæ—¶ä¼šè¿”å›false</p>
<p><code>fill(a,a+4,233)</code> ,èµ‹ç›¸åŒå€¼ï¼Œå¯¹äº<code>G[maxn] [maxn]</code>äºŒç»´æ•°ç»„<code>fill(G[0],G[0]+maxn*maxn,INF);</code></p>
<p><code>sort(é¦–å…ƒç´ åœ°å€ï¼Œå°¾å…ƒç´ åœ°å€çš„ä¸‹ä¸€ä¸ªåœ°å€ï¼Œæ¯”è¾ƒå‡½æ•°ï¼ˆéå¿…å¡«)ï¼‰</code>,æ— æ¯”è¾ƒå‡½æ•°ï¼Œé»˜è®¤é€’å¢æ’åºã€‚</p>
<p><code>sort(a, a+n, greater());</code>  ä»å¤§åˆ°å°æ’åº(è¦ç”¨<code>iostream</code>å¤´æ–‡ä»¶)</p>
<p><code>lower_bound(first,last,val)</code>  <code>upper_bound(first,last,val)</code> ,ç”¨äºæœ‰åºæ•°ç»„æˆ–å®¹å™¨ï¼Œå‰è€…ç”¨æ¥å¯»æ‰¾[first,last)èŒƒå›´å†…ç¬¬ä¸€ä¸ªå€¼å¤§äºç­‰äºvalçš„å…ƒç´ çš„ä½ç½®ï¼Œåè€…å¯»æ‰¾ç¬¬ä¸€ä¸ªå€¼å¤§äºvalçš„å…ƒç´ ä½ç½®.è‹¥æ˜¯æ•°ç»„ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°è¿”å›çš„æ˜¯åœ°å€ï¼Œå¦‚<code>int* right=upper_bound(num, num+n, k)</code>ï¼Œè¿”å›numæ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºkçš„å…ƒç´ æ‰€åœ¨åœ°å€ï¼Œå…¶ä¸‹æ ‡=<code>right-num</code></p>
<p><code>max_element(a, a+len)</code>è¿”å›åºåˆ—ä¸­æœ€å¤§å…ƒç´ åœ°å€ï¼ˆè¿­ä»£å™¨ï¼‰,å¯ç”¨å…¶å‡å»æ•°ç»„é¦–åœ°å€(å³æ•°ç»„å)è·å–å…¶ä¸‹æ ‡,è‹¥è¦è·å–è¯¥å…ƒç´ å€¼ï¼Œ<em><em>ç›´æ¥åœ¨å‰é¢åŠ ä¸€ä¸ª</em>,è¡¨ç¤ºå–åœ°å€å³å¯</em>*</p>
<p><code>min_element(begin, end)</code> è¿”å›åºåˆ—ä¸­æœ€å°å…ƒç´ åœ°å€</p>
</li>
<li>
<p><code>string.h</code> å¤´æ–‡ä»¶(<code>cstring</code>å¤´æ–‡ä»¶)</p>
<p><code>memset(æ•°ç»„å,-1æˆ–0,sizeof(æ•°ç»„å))</code></p>
<p><code>strlen(å­—ç¬¦æ•°ç»„)</code> å¾—åˆ°å­—ç¬¦æ•°ç»„ä¸­ç¬¬ä¸€ä¸ª\0å‰çš„å­—ç¬¦ä¸ªæ•°</p>
<p><code>strcmp(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code>è¿”å›ä¸¤ä¸ªå­—ç¬¦ä¸²å¤§å°æ¯”è¾ƒç»“æœï¼ŒæŒ‰å­—å…¸åºã€‚å­—ç¬¦æ•°ç»„1&lt;2 ,è¿”å›è´Ÿæ•´æ•°;1=2ï¼Œè¿”å›0;1&gt;2ï¼Œè¿”å›æ­£æ•´æ•°</p>
<p><code>strcpy(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code>ï¼ŒæŠŠå­—ç¬¦æ•°ç»„2å¤åˆ¶ç»™å­—ç¬¦æ•°ç»„1ï¼ŒåŒ…æ‹¬\0</p>
<p><code>strcat(å­—ç¬¦æ•°ç»„1ï¼Œå­—ç¬¦æ•°ç»„2)</code> ,æŠŠ2æ¥åœ¨1åé¢</p>
</li>
<li>
<p><code>cctype</code>å¤´æ–‡ä»¶</p>
<p>1.ä¸ä»…ä»…èƒ½åˆ¤æ–­å­—âºŸï¼Œè¿˜èƒ½åˆ¤æ–­æ•°å­—ã€â¼©å†™å­—âºŸã€â¼¤å†™å­—âºŸç­‰</p>
<p><code>isalpha</code>å­—âºŸï¼ˆåŒ…æ‹¬â¼¤å†™ã€â¼©å†™ï¼‰</p>
<p><code>islower</code> ï¼ˆâ¼©å†™å­—âºŸï¼‰</p>
<p><code>isupper</code>ï¼ˆâ¼¤å†™å­—âºŸï¼‰</p>
<p><code>isalnum</code> ï¼ˆå­—âºŸâ¼¤å†™â¼©å†™+æ•°å­—ï¼‰</p>
<p><code>isblank</code>ï¼ˆspaceå’Œ \t ï¼‰</p>
<p><code>isspace</code>ï¼ˆ space ã€ \t ã€ \r ã€ \n ï¼‰</p>
<p><code>isdigit</code>(æ•°å­—)</p>
<p>2 .<code>tolower (char c)</code>å’Œ <code>toupper(char c)</code> å°†æŸä¸ªå­—ç¬¦è½¬ä¸ºâ¼©å†™æˆ–â¼¤å†™</p>
</li>
<li>
<p><code>string</code></p>
<p><code>str.insert(pos,str1)</code> åœ¨åŸå­—ç¬¦ä¸²çš„poså·ä½æ’å…¥ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²str1</p>
<p><code>str.erase(first,last)</code> firstä¸ºéœ€è¦åˆ é™¤çš„åŒºé—´çš„èµ·å§‹è¿­ä»£å™¨ï¼Œlastæ˜¯åŒºé—´æœ«å°¾è¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªåœ°å€</p>
<p><code>str.erase(pos,length)</code> posä¸ºéœ€è¦å¼€å§‹åˆ é™¤çš„èµ·å§‹ä½ç½®ï¼Œlengthæ˜¯åˆ é™¤çš„å­—ç¬¦ä¸ªæ•°</p>
<p><code>str.clear()</code> æ¸…ç©ºstringä¸­çš„æ•°æ®</p>
<p><code>str.substr(pos,len)</code> è¿”å›ä»poså·å¼€å§‹ï¼Œé•¿åº¦æ˜¯len çš„å­ä¸²</p>
<p><code>string::npos</code>æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œå¯ä»¥ä½œä¸ºfindå‡½æ•°åŒ¹é…å¤±è´¥çš„è¿”å›å€¼</p>
<p><code>str.find(str1,pos)</code>  ä»strçš„poså·ä½å¼€å§‹åŒ¹é…str1ï¼Œè¿”å›str1ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®</p>
<p><code>str.find(str1)</code>  ä»strçš„poså·ä½å¼€å§‹åŒ¹é…str1ï¼Œè¿”å›str1ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®</p>
</li>
</ul>
<h3 id="10è¿›åˆ¶è½¬æ¢">10.è¿›åˆ¶è½¬æ¢</h3>
<ul>
<li>åè¿›åˆ¶è½¬åŒ–ä¸ºå…¶ä»–è¿›åˆ¶</li>
</ul>
<pre><code>1.æ•°ç»„å½¢å¼
int z[maxn],num=0;
do{
z[num++]=n%b;
n/=b;
}while(n!=0);
2.æ•°å­—å½¢å¼(å°†åè¿›åˆ¶æ•°aè½¬åŒ–ä¸ºä»»æ„bè¿›åˆ¶æ•°ï¼Œå°†ç»“æœå­˜åœ¨æ•°ç»„ä¸­)
while(a != 0) {
   arr[index++] = a % b;
   a = a / b;
}//æ³¨æ„åœ¨æ•°ç»„ä¸­å­˜å‚¨çš„é¡ºåº(ä¸‹æ ‡ä»0å¼€å§‹)æ˜¯åçš„
3.
void change(int n,int b){
	if(n&gt;0){
		int i=0;
		change(n/b,b);
		a.push_back(n%b);
	}
	else return;
}
</code></pre>
<ul>
<li>
<p>ç»™å®šâ¼€ä¸ªæ•°å€¼å’Œâ¼€ä¸ªè¿›åˆ¶ï¼Œå°†å®ƒè½¬åŒ–ä¸º10è¿›åˆ¶ã€‚è½¬åŒ–è¿‡ç¨‹ä¸­å¯èƒ½äº§â½£æº¢å‡º,æ•°å€¼ä¸­åªæœ‰å°å†™å­—æ¯å’Œæ•°å­—</p>
<pre><code>long long convert(string n, long long radix) {
 long long sum = 0;
 int index = 0, temp = 0;
 for (auto it = n.rbegin(); it != n.rend(); it++) {
   temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
   sum += temp * pow(radix, index++);
 }
 return sum;
}
</code></pre>
</li>
</ul>
<h3 id="11-ascll-ç è¡¨">11. <code>ASCLL</code> ç è¡¨</h3>
<p>A-Zå¯¹åº”åè¿›åˆ¶65-90</p>
<p>a-zå¯¹åº”åè¿›åˆ¶97-122</p>
<h3 id="12å›æ–‡ä¸²">12.å›æ–‡ä¸²</h3>
<pre><code>bool judge(int arr[],int index){//indexä¸ºæ•°ç»„å…ƒç´ ä¸ªæ•°
    for(int i = 0; i &lt;index / 2; i++) {
       if(arr[i] != arr[index-i-1]) {
           return false;
     }
   }
   return true;
}

</code></pre>
<h3 id="13æ•°å­—-å­—ç¬¦æ•°ç»„ç›¸äº’è½¬æ¢">13.æ•°å­—ã€å­—ç¬¦æ•°ç»„ç›¸äº’è½¬æ¢</h3>
<pre><code>1.æ•°å­—å­˜åˆ°æ•°ç»„ä¸­
void to_array(int n,int a[]){
    int j=0;
    while(n){
        a[j++]=n%10;
        n/=10;
    }
}
2.æ•°ç»„å˜ä¸ºæ•°å­—
int exp=0;
for(int i=0;i&lt;len;i++){
    exp=exp*10+(str[i]='0');
}
æˆ–

</code></pre>
<h3 id="14-æ’åº-æ‰¾æœ€å€¼">14 æ’åºã€æ‰¾æœ€å€¼</h3>
<ul>
<li>
<pre><code>int best=0;
for (int j = 0; j &lt; 4; j++) {
	if (a[j] &lt; a[best])
	best = j;
}
æ‰¾å‡ºæ•°ç»„aä¸­æœ€å°å…ƒç´ çš„ä½ç½®
</code></pre>
</li>
<li>
<p>ç»“æ„ä½“å†…é‡è½½è¿ç®—ç¬¦</p>
<p>è¿ç®—ç¬¦é‡è½½çš„æ ¼å¼å¦‚ä¸‹ï¼š</p>
<p>å‡½æ•°ç±»å‹ operator è¿ç®—ç¬¦åç§°ï¼ˆå½¢å‚è¡¨åˆ—ï¼‰{å¯¹è¿ç®—ç¬¦çš„é‡è½½å¤„ç†},ä¾‹å¦‚ï¼š</p>
<pre><code>struct node {
	int id;
	int freq;
	bool operator &lt; (const node&amp; a) const {
		return (freq != a.freq) ? freq &gt; a.freq:id &lt; a.id;
	}
};
</code></pre>
</li>
<li>
<p>ä½¿ç”¨sort()å¯¹charæ•°ç»„æ’åº</p>
<p>æ­£ç¡®æ–¹æ³•ï¼š</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[3][4] = {&quot;wu&quot;,&quot;jia&quot;,&quot;jun&quot;};//äºŒç»´æ•°ç»„ä¿å­˜nä¸ªå­—ç¬¦ä¸² 
bool cmp(int a,int b){
    return strcmp(name[a],name[b]) &lt; 0;
}
int main(){
    int arr[3] = {0,1,2};//ä¸å­—ç¬¦ä¸²æ•°ç»„ä¸‹æ ‡ä¸€ä¸€å¯¹åº” 
    sort(arr,arr+3,cmp);//æ’åˆ—çš„å®é™…æ˜¯æ ‡å· ï¼Œè¿™ä¹ˆåšæ›´å¿« 
    for(int i = 0;i &lt;3 ;i++){
        printf(&quot;%s &quot;,name[arr[i]]);
    }
}
</code></pre>
<p>é”™è¯¯æ–¹æ³•ï¼š</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
char stu[6][6] = { &quot;ahda&quot;,&quot;jwnd&quot;,&quot;djsh&quot;,&quot;yrhw&quot;,&quot;JWJs&quot; };
bool cmp(int a, int  b) { return strcmp(stu[a], stu[b]) &lt; 0; }
int main() {
	sort(stu, stu + 5, cmp);
	for (int i = 0; i &lt; 5; i++)
		printf(&quot;%s&quot;, stu[i]);
	return 0;
}
</code></pre>
</li>
<li>
<pre><code> testee[0].rank=1;
  	for(int k=1;k&lt;total;k++){
  		if(testee[k].grade==testee[k-1].grade) testee[k].rank=testee[k-1].rank;
  		else testee[k].rank=k+1;
  	}
ç¡®ä¿æ’åä¸º 1 1 3 3 4...çš„å½¢å¼
</code></pre>
</li>
<li>
<p>A1062 ,A1075,A1012,A1016,A1025,A1028,A1055,A1075,A1083,A1080,A1095,A1109,A1141(æ³¨æ„1080ä¸­cmpçš„å†™æ³•å’Œä½¿ç”¨)</p>
<p>æ€è·¯ï¼š</p>
<p>å®šä¹‰ç»“æ„ä½“ï¼Œcmpå‡½æ•°ï¼Œåˆå§‹åŒ–ç»“æ„ä½“å†…çš„å˜é‡ï¼Œforå¾ªç¯ä¸­è¾¹è¾“å…¥è¾¹å¤„ç†</p>
<p>æ’åºæ—¶æ³¨æ„æ˜¯å¦èƒ½ç”¨å­¦å·ç­‰ä¿¡æ¯ä½œä¸ºæ•°ç»„ä¸‹æ ‡ï¼Œå› ä¸ºæ’åºåä¸‹æ ‡ä¼šæ”¹å˜ï¼Œæ‰€ä»¥å¯ä»¥åœ¨ç»“æ„ä½“ä¸­è®¾ç½®idå˜é‡</p>
<p>å¹³å‡æ•°ä½œä¸ºæœ€åæˆç»©å¯ä»¥ä¸ç”¨é™¤ï¼Œç›´æ¥ç”¨æ€»å’Œæ¯”è¾ƒ</p>
<p>æœ‰äº›é¢˜è¦æ‰¾å‡ºæœ‰æ•ˆè®°å½•(æ¯”å¦‚å¸¸å‡ºç°çš„é…å¯¹é—®é¢˜)</p>
</li>
<li>
<p>å„ç§æ’åºç®—æ³•</p>
<ul>
<li>
<p>é€‰æ‹©æ’åº</p>
<pre><code>void selectsort(){
    for(int i=0;i&lt;n;i++){
        int k=i;
        for(int j=k;j&lt;n;j++){
            if(A[j]&lt;A[k]){
                k=j;
            }
        }
        int temp=A[K];
        A[k]=A[i];
        A[i]=temp;
    }
}
</code></pre>
</li>
<li>
<p>æ’å…¥æ’åº</p>
<pre><code>void insertSort(){
   for(int i=2;i&lt;=n;i++){
      int temp=a[i],j=i;
      while(j&gt;1&amp;&amp;a[j-1]&gt;temp){
         a[j]=a[j-1];
         j--;
      }
      a[j]=temp;
   }
}
</code></pre>
</li>
<li>
<p>å½’å¹¶æ’åº (æ­¤å¤„ä¸º2è·¯å½’å¹¶) (åˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—æ—¶ï¼Œæ³¨æ„å…¶ä¸­ä¸€ä¸ªæ•°åˆ—å…ˆæ‰«æå®Œçš„æƒ…å†µ)</p>
<pre><code>void merge(int A[],int L1,int R1,int L2,int R2){
//å°†æ•°ç»„Açš„[L1,R1]ä¸[L2,R2]åŒºé—´åˆå¹¶ä¸ºæœ‰åºåŒºé—´(æ­¤å¤„L2=R1+1)
    int i=L1,j=L2,temp[maxn],index=0;
    while(i&lt;=R1&amp;&amp;j&lt;=R2){
    if(A[i]&lt;=A[j]) temp[index++]=A[i++];
    else temp[index++]=A[j++];
    }
    while(i&lt;=R1) temp[index++]=A[i++];
    while(j&lt;=R2) temp[index++]=A[j++];
    for(i=0;i&lt;index;i++) A[L1+i]=temp[i];
}
void mergeSort(int A[],int left,int right){
    if(left&lt;right){
        int mid=(left+right)/2;
        mergeSort(A,left,mid);
        mergeSort(A,mid+1,right);
        merge(A,left,mid,mid+1,right);
    }
}
</code></pre>
</li>
<li>
<p>å¿«æ’(é€’å½’æ³•)</p>
<pre><code>int partition(int A[],int left,int right){
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
<p>å¿«æ’(æ”¹è¿›å)</p>
<p>ç”Ÿæˆéšæœºæ•°éœ€è¦æ·»åŠ stdlib.hä¸time.hå¤´æ–‡ä»¶ï¼Œmianå‡½æ•°å†…å¼€å¤´åŠ ä¸Šsrand((unsigned)time(NULL));</p>
<pre><code>int partition(int A[],int left,int right){//åªæ”¹è¿›è¯¥å‡½æ•°
    int p=(int)(round(1.0*rand()/RAND_MAX*(right-left)+left));
    //ç”Ÿæˆ[left,right]èŒƒå›´å†…çš„éšæœºæ•°
    swap(A[left],A[p]);
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){//è¯¥å‡½æ•°ä¸å˜
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
</li>
<li>
<p>å †æ’åº</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
void createheap() {//å»ºå †
	for (int i = n / 2; i &gt;= 1; i--) {
		downadjust(i, n);
	}
}
void heapsort(){
    createheap();
    for(int i=n;i&gt;1;i--){
        swap(heap[1],heap[i]);
        upadjust(1,i-1);
    }
}
</code></pre>
</li>
<li>
<p>æ‹“æ‰‘æ’åº</p>
<pre><code>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="15-è®¡ç®—æ—¶é•¿">15 è®¡ç®—æ—¶é•¿</h3>
<ul>
<li>
<p>å¯¹å·²çŸ¥çš„èµ·æ­¢æ—¶é—´ï¼Œä¸æ–­å°†èµ·å§‹æ—¶é—´åŠ 1ï¼Œåˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆæ­¢æ—¶é—´</p>
<pre><code>void get_ans(int on, int off, int&amp; time, int&amp; money) {
	temp = rec[on];
  while (temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) {
		time++;
		money += toll[temp.hh];
		temp.mm++;
		if (temp.mm &gt;= 60) {
			temp.mm = 0;
			temp.hh++;
		}
		if (temp.hh &gt;= 24) {
			temp.hh = 0;
			temp.dd++;
		}
	}
}
</code></pre>
</li>
<li>
<p>å¯¹äº<code>hh:mm:ss</code>ç±»å‹çš„æ—¶é—´å¤„ç†ï¼šå¯ä»¥<code>hh * 3600 + mm * 60 + ss</code> è½¬åŒ–æˆç§’ï¼Œæ–¹ä¾¿å¤„ç†</p>
</li>
</ul>
<h3 id="16æ•°æ®ç±»å‹é—®é¢˜">16.æ•°æ®ç±»å‹é—®é¢˜</h3>
<ul>
<li>ä¸”C++æŠŠæ‰€æœ‰â¾®é›¶å€¼è§£é‡Šä¸º true ï¼Œé›¶å€¼è§£ é‡Šä¸º false ï½æ‰€ä»¥ç›´æ¥èµ‹å€¼â¼€ä¸ªæ•°å­—ç»™ <code>bool</code> å˜é‡ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå®ƒä¼šâ¾ƒåŠ¨æ ¹æ® int å€¼æ˜¯ä¸æ˜¯é›¶æ¥å†³å®š ç»™ <code>bool</code> å˜é‡èµ‹å€¼ true è¿˜æ˜¯ false ï½</li>
</ul>
<pre><code>bool flag = true;//flagä¸º1ï¼Œè‹¥æ˜¯flaseåˆ™ä¸º0
bool flag2 = -2; // flag2ä¸ºtrue
bool flag3 = 0; // flag3ä¸ºfalse
</code></pre>
<h3 id="17æ ˆ-é˜Ÿåˆ—-é“¾è¡¨">17.æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨</h3>
<p>åœ¨ä½¿ç”¨æ ˆçš„pop()å’Œtop()å‡½æ•°å‰å¿…é¡»ä½¿ç”¨empty()åˆ¤æ–­æ ˆæ˜¯å¦éç©ºã€‚</p>
<p>æ ˆï¼šA1051</p>
<p>è®°å¾—æ¸…ç©ºæ ˆ</p>
<pre><code>while(!st.empty()){
    st.pop();
}
</code></pre>
<p>é˜Ÿåˆ—ï¼šA1056</p>
<p>é“¾è¡¨ï¼šA1074ï¼ŒA1032ï¼ŒA1052, A1097 A1133(é“¾è¡¨  é‡æ–°æ’åˆ—)</p>
<pre><code>for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;node[address].key,&amp;node[address].next);
		node[address].address=address;
	}
</code></pre>
<p>å½“ç»“ç‚¹çš„åœ°å€æ˜¯æ¯”è¾ƒå°çš„æ•´æ•°(æ¯”å¦‚5ä½æ•°çš„æ•´æ•°),å¯ä»¥ä½¿ç”¨é™æ€é“¾è¡¨ï¼Œæ²¡æœ‰å¿…è¦å»ºç«‹åŠ¨æ€é“¾è¡¨ã€‚</p>
<p>æ³¨æ„åˆå§‹åŒ–ï¼Œæ’é™¤æ— æ•ˆç»“ç‚¹(å¯ä»¥ç»“åˆsortï¼Œcmpä¸­é’ˆå¯¹order)ã€‚ç”¨countè®¡æ•°æœ‰æ•ˆç»“ç‚¹</p>
<p>æŸäº›æƒ…å†µä¸‹çš„æœ€åä¸€ä¸ªç»“ç‚¹è¦ç‰¹æ®Šå¤„ç†(æ¯”å¦‚ä»¤nextä¸º-1)ã€‚</p>
<p>æ³¨æ„é“¾è¡¨ç»“æ„ä½“å…ƒç´ orderçš„ä½¿ç”¨</p>
<h3 id="18è´ªå¿ƒ">18.è´ªå¿ƒ</h3>
<p>A1070 ,<strong>A1033</strong> ,A1037,A1067 A1125(ç®€å•è´ªå¿ƒ æ’åº)</p>
<h3 id="19-äºŒåˆ†">19 äºŒåˆ†</h3>
<p>A1085,A1010,A1044 A1048</p>
<p>æ³¨æ„äºŒåˆ†æ³•çš„å‡ ç§å†™æ³•,ä»¥åŠéä¸¥æ ¼é€’å¢åºåˆ—çš„å¤„ç†,å¯ä»¥ä½¿ç”¨<code>lower_bound</code>å’Œ<code>upper_bouned</code></p>
<ul>
<li>
<p>æŸ¥æ‰¾ç»™å®šçš„æ•°x</p>
<pre><code>int binarySearch(int A[],int left,int right,int x){
    int mid;
    while(left&lt;=right){
        mid=(left+right)/2;
        if(A[mid]==x) return mid;
        else if(A[mid]&gt;x) right=mid-1;
        else left=mid+1;
    }
    return -1;//æŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›-1
}
</code></pre>
</li>
<li>
<p>æ±‚ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„å…ƒç´ çš„ä½ç½®</p>
<pre><code>int lower_bound(int A[],int left,int right,int x){
    int mid;
    while(left&lt;right){
        mid=(left+right)/2;
        if(A[mid]&gt;=x) right=mid;
        else left=mid+1;
    }
    return left;
}
</code></pre>
</li>
<li>
<p>æ±‚ç¬¬ä¸€ä¸ªå¤§äºxçš„å…ƒç´ çš„ä½ç½®</p>
<pre><code>int upper_bound(int A[],int left,int right,int x){
    int mid;
    while(left&lt;right){
        mid=(left+right)/2;
        if(A[mid]&gt;x) right=mid;
        else left=mid+1;
    }
    return left;
}
</code></pre>
</li>
</ul>
<h3 id="20-two-points">20 two points</h3>
<p>A1085,A1089,A1029</p>
<h3 id="21-æ•°å­¦é—®é¢˜">21 æ•°å­¦é—®é¢˜</h3>
<ul>
<li>
<p>æ±‚æœ€å¤§å…¬çº¦æ•°,(æœ€å°å…¬å€æ•°ï¼šaå’Œbçš„æœ€å¤§å…¬çº¦æ•°ä¸ºdï¼Œåˆ™aå’Œbçš„æœ€å°å…¬å€æ•°ä¸ºab/d)</p>
<pre><code>long long gcd(long long a, long long b) {
     return b == 0 ? abs(a) : gcd(b, a %b);
 }
</code></pre>
</li>
<li>
<p>åˆ†æ•°åŒ–ç®€</p>
<pre><code>struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
</code></pre>
</li>
<li>
<p>å››åˆ™è¿ç®—</p>
<pre><code>fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
</code></pre>
</li>
<li>
<p>åˆ†æ•°è¾“å‡º</p>
<pre><code>void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
</code></pre>
</li>
<li>
<p>åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°</p>
<pre><code>bool isprime(int n) {
	if (n &lt;= 1) return false;
    int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}

</code></pre>
</li>
<li>
<p>å»ºç«‹ç´ æ•°è¡¨</p>
<pre><code>
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
</code></pre>
</li>
<li>
<p>å¤§æ•´æ•°è¿ç®—</p>
<pre><code>struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
</code></pre>
</li>
</ul>
<p>A1069,A1049,A1088,A1015,A1078,A1096,A1023,A1024</p>
<h3 id="22å…¥é—¨æ¨¡æ‹Ÿ">22.å…¥é—¨æ¨¡æ‹Ÿ</h3>
<p>A1042(æ´—æ‰‘å…‹ç‰Œ) ï¼ŒA1046(ç¯å½¢ä¸¤ç‚¹é—´è·ç¦») ï¼ŒA1065(ä¸¤æ•°ç›¸åŠ åˆ¤æ–­å¤§å°)ï¼Œ A1002(å¤šé¡¹å¼ç›¸åŠ )ï¼ŒA1009(å¤šé¡¹å¼ç›¸ä¹˜)ï¼ŒA1011ï¼ŒA1006(ç­¾åˆ°ç­¾ç¦») ï¼ŒA1036(æ‰¾æœ€å€¼)ï¼ŒA1031(è¾“å‡ºå›¾å½¢)ï¼ŒA1019(å›æ–‡ä¸²)ï¼ŒA1027(è¿›åˆ¶è½¬æ¢)ï¼ŒA1058(åŠ æ³•è¿›ä½)ï¼ŒA1061(å­—ç¬¦ä¸²é—®é¢˜)ï¼Œ***A1073(ç§‘å­¦è®¡æ•°æ³•)***ï¼ŒA1001(a+b)ï¼ŒA1005,A1035,A1077(å…¬å…±åç¼€)ï¼Œ<strong>A1082(ç”¨æ±‰è¯­è¯»æ•°å­—)</strong></p>
<h3 id="23æŠ€å·§-é€»è¾‘">23.æŠ€å·§ã€é€»è¾‘</h3>
<p>A1093,A1101, A1113 A1117(é€»è¾‘)  A1148(ç‹¼äººæ€ æ‰¾åˆ°ä¸¤ä¸ªç‹¼äºº)</p>
<h3 id="24-dfs-bfs">24 DFS BFS</h3>
<ul>
<li>
<p>DFSç”¨é€’å½’å®ç°ï¼ŒA1103</p>
<pre><code>void DFS(int index, int nowk, int sum, int facsum) {
	if (sum == n &amp;&amp; nowk == k) {
		if (facsum &gt; maxfacsum) {
			ans = temp;//æ›´æ–°æœ€ä¼˜åºåˆ—
			maxfacsum = facsum;
		}
		return;
	}
	if (nowk &gt; k || sum &gt; n) return;
	if (index - 1 &gt;= 0) {
		temp.push_back(index);
		DFS(index, nowk + 1, sum + fac[index], facsum + index);
		temp.pop_back();
		DFS(index - 1, nowk, sum, facsum);
	}
}
</code></pre>
</li>
<li>
<p>BFSç”¨é˜Ÿåˆ—å®ç°    A1091</p>
<pre><code>void BFS(int s){
    queue&lt;int&gt; q;
    q.push(s);
    while(!q.empty()){
        å–å‡ºé˜Ÿé¦–å…ƒç´ top;
        è®¿é—®é˜Ÿé¦–å…ƒç´ top;
        å°†é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿ;
        å°†topçš„ä¸‹ä¸€å±‚ç»“ç‚¹ä¸­æœªæ›¾å…¥é˜Ÿçš„ç»“ç‚¹å…¨éƒ¨å…¥é˜Ÿï¼Œå¹¶è®¾ç½®ä¸ºå·²å…¥é˜Ÿ;
    }
}
</code></pre>
<pre><code>int BFS(int z,int x,int y){
	int total=0;
	Node.x = x;
	Node.y = y;
	Node.z = z;
	inq[z][x][y] = true;
	queue&lt;node&gt; q;
	q.push(Node);
	while (!q.empty()) {
		node topp = q.front();
		q.pop();
		total++;
		int newx, newy, newz;
		for (int i = 0; i &lt; 6; i++) {
			newz = topp.z + Z[i];
			newx = topp.x + X[i];
			newy = topp.y + Y[i];
			if (judge(newz, newx, newy)) {
				Node.x = newx;
				Node.y = newy;
				Node.z = newz;
				q.push(Node);
				inq[Node.z][Node.x][Node.y] = true;
			}
		}
	}
	if (total &gt;= T) return total;
	else return 0;
}
</code></pre>
</li>
</ul>
<h3 id="25-æ ‘">25 æ ‘</h3>
<p>A1020,A1086,A1102 , A1151(äºŒå‰æ ‘LCA)ï¼ŒA1143(äºŒå‰æœç´¢æ ‘LCA) ã€A1119(å‰åºå’Œååºæ±‚ä¸­åº)</p>
<p>A1123(30 AVL ã€å±‚åºéå†ã€åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘) ã€ A1110(åˆ¤æ–­æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘)</p>
<p>A1127(30 ä¸­åºååºå»ºæ ‘ï¼Œdfsï¼Œè¾“å‡ºzå­—å½¢å±‚åºéå†)   A1130(dfsäºŒå‰æ ‘ è¾“å‡ºä¸­ç¼€è¡¨è¾¾å¼)</p>
<p>A1155(30 å®Œå…¨äºŒå‰æ ‘  åˆ¤æ–­å¤§é¡¶å †å°é¡¶å † dfs æ‰“å°è·¯å¾„)    A1147(30  åˆ¤æ–­å¤§é¡¶å †å°é¡¶å † ååºéå†)</p>
<p>A1135(30 åˆ¤æ–­çº¢é»‘æ ‘ é€’å½’åˆ¤æ–­)</p>
<ul>
<li>
<p>äºŒå‰æ ‘</p>
<ul>
<li>
<p>å­˜å‚¨ç»“æ„</p>
<pre><code>struct node{
    typename data;
    node* lchild;
    node* rchild;
}//åŠ¨æ€
struct node{
  typename data;
    int left,right;
</code></pre>
</li>
</ul>
<p>}//é™æ€</p>
<p>//å¯¹äºä¸æ˜¯äºŒå‰æ ‘çš„æ ‘<br>
struct node{<br>
typename data;<br>
vector<int> child;<br>
}</p>
<pre><code>
</code></pre>
</li>
<li>
<p>æ–°å»ºç»“ç‚¹</p>
<pre><code>  node* newNode(int v){
      node* root=new node;
      Node-&gt;data=v;
      Node-&gt;lchild=Node-&gt;rchild=NULL;
      return Node;
  }
</code></pre>
</li>
<li>
<p>ä¸­åºéå†</p>
<pre><code>  void inorder(node* root){
      if(root==NULL) return;
      inorder(root-&gt;lchild);
      printf(&quot;%d&quot;,root-&gt;data);
      inorder(root-&gt;rchild);
  }
</code></pre>
<ul>
<li>
<p>äºŒå‰æ ‘çš„å±‚åºéå†(BFS)</p>
<pre><code>void layerorder(node* root) {
	queue&lt;node*&gt; q;
q.push(root);
	while (!q.empty()) {
	node* now = q.front();
		q.pop();
		printf(&quot;%d&quot;, now-&gt;data);
		if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);
	if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);
	}
}
</code></pre>
</li>
<li>
<p>ç”¨å·²çŸ¥çš„ä¸¤ä¸ªåºåˆ—æ„å»ºå”¯ä¸€äºŒå‰æ ‘</p>
<pre><code>node* create(int postL, int postR, int inL, int inR) {//ååºåŠ ä¸­åº
	if (postL &gt; postR) return NULL;
	node* root = new node;
	root-&gt;data = postorder[postR];
	int k;
	for (int i = inL; i &lt;= inR; i++) {
		if (inorder[i] == root-&gt;data) {
			k = i;
		break;
		}
	}
	int leafnum = k - inL;
	root-&gt;lchild = create(postL, postL + leafnum - 1, inL, k - 1);
	root-&gt;rchild = create(postL + leafnum, postR - 1, k + 1, inR);
	return root;
}

</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
using namespace std;
#define INF 0x3fffffff
typedef struct node{				//ç»“ç‚¹å®šä¹‰ 
	int data;
	struct node *right,*left;
}Node;
vector&lt;int&gt; inor,layor;				//ä¸­åºå’Œå±‚åºåºåˆ— 
unordered_map&lt;int,int&gt; inmp,laymp;	//åºåˆ—ä¸å…¶ä¸‹æ ‡çš„æ˜ å°„ï¼Œï¼ˆå»ºç«‹æ˜ å°„å¯ä»¥å‡å°‘é€’å½’æ—¶å€™æŸ¥æ‰¾åºåˆ—çš„æ¬¡æ•°ï¼‰ 
Node *creat(int il,int ir){			//å»ºæ ‘å‡½æ•° ï¼Œilè¡¨ç¤ºä¸­åºåºåˆ—çš„å·¦ç«¯ï¼Œirä¾¿æ˜¯ä¸­åºåºåˆ—çš„å³ç«¯ 
	if(il&gt;ir) return NULL;			//å¦‚æœæ ‘ä¸­åºåˆ—é•¿åº¦ä¸º0ï¼Œè¡¨ç¤ºåˆ°äº†ç©ºç»“ç‚¹ 
	int min=INF,id;					//minè¡¨ç¤ºä¸­åºåºåˆ—ä¸­çš„å…ƒç´ åœ¨å±‚åºä¸­ä¸‹æ ‡æœ€å°çš„é‚£ä¸ªï¼Œå…¶ä¸­åºçš„ä¸‹æ ‡ 
	for(int i=il;i&lt;=ir;i++){		//éå†ä¸­åºåºåˆ—ï¼Œæ‰¾å‡ºå¯¹åº”å±‚åºä¸­ä¸‹è¾¹æœ€å°çš„å…ƒç´  
		if(laymp[inor[i]]&lt;min){
			min=laymp[inor[i]];
		}
	}
	Node *root=new node;			
	root-&gt;data=layor[min];			//ä¸­åºåºåˆ—ä¸­ å±‚åºä¸­ä¸‹æ ‡æœ€å°çš„ä¾¿æ˜¯æ ¹ 
	id=inmp[root-&gt;data];			//è·å¾—æ ¹åœ¨ä¸­åºçš„ä½ç½®ï¼Œåˆ’åˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘ 
	root-&gt;left=creat(il,id-1);		//é€’å½’å·¦å­æ ‘ 
	root-&gt;right=creat(id+1,ir);		//é€’å½’å³å­æ ‘ 
	return root;					//è¿”å›å½“å‰å­æ ‘çš„æ ¹ 
}
void preorder(Node *root){			//é€’å½’çš„å…ˆåºéå†å‡½æ•° 
	if(root==NULL) return;
	printf(&quot;%d &quot;,root-&gt;data);
	preorder(root-&gt;left);
	preorder(root-&gt;right);
}
int main(void){

	int n;
	cin&gt;&gt;n;
	inor.resize(n); layor.resize(n);//è¯»å…¥å…ƒç´ ä¸ªæ•°å¹¶åˆå§‹åŒ– 
	for(int i=0;i&lt;n;i++){			//è¯»å…¥ä¸­åºåºåˆ—å¹¶å®Œæˆæ˜ å°„ 
		cin&gt;&gt;inor[i];
		inmp[inor[i]]=i;
} 
	for(int i=0;i&lt;n;i++){			//è¯»å…¥å±‚åºåºåˆ—å¹¶å®Œæˆæ˜ å°„ 
	cin&gt;&gt;layor[i];
		laymp[layor[i]]=i;
	} 
	Node *root=creat(0,n-1);		//å»ºæ ‘ 
	preorder(root);					//å…ˆåºéå†ï¼ŒéªŒè¯æ ‘çš„ç»“æ„ 
	return 0;
} 
</code></pre>
</li>
<li>
<p>å‰åºååº æ±‚ä¸­åº</p>
<pre><code>void getin(int prel, int prer, int postl, int postr) {
	if (prel == prer) {
		in.push_back(pre[prel]);
		return;
	}
	if (pre[prel] == post[postr]) {
		int i = prel + 1;
	while (i &lt;= prer &amp;&amp; pre[i] != post[postr - 1]) i++;
		if (i - prel &gt; 1) getin(prel + 1, i - 1, postl, postl + (i - prel - 1) - 1);
	else unique = false;
		in.push_back(post[postr]);
		getin(i, prer, postl + (i - prel - 1), postr - 1);
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>é™æ€äºŒå‰æ ‘(å¦‚æœé¢˜ç›®ä¸­ç›´æ¥ç»™å‡ºç»“ç‚¹åºå·ä¹‹é—´çš„çˆ¶å­å…³ç³»ï¼Œå¯ä»¥ç”¨é™æ€)</p>
<pre><code>struct node{
    typename data;
    int lchild;
    int rchild;
}Node[maxn];
</code></pre>
</li>
<li>
<p>äºŒå‰æ ‘åè½¬(é™æ€)</p>
<pre><code>  void postorder(int root) {//æ³¨æ„æ˜¯ååºéå†
	if (root == -1) return;
  	postorder(Node[root].lchild);
	postorder(Node[root].rchild);
  	swap(Node[root].lchild, Node[root].rchild);
  }
</code></pre>
<ul>
<li>
<p>å®Œå…¨äºŒå‰æ ‘</p>
<p>1.åˆ¤æ–­æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘</p>
<pre><code>int iscomplete = 1, after = 0;
vector&lt;int&gt; levelorder(node* root) {//å±‚åºéå†ä¸­
	queue&lt;node*&gt; q;
	vector&lt;int&gt; v;
	q.push(root);
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		v.push_back(temp-&gt;data);
		if (temp-&gt;lchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;lchild);
		}
	else after = 1;
		if (temp-&gt;rchild != NULL) {
		if (after) iscomplete = 0;
			q.push(temp-&gt;rchild);
	}
		else after = 1;
}
	return v;
}
</code></pre>
<p>2.ç»™å‡ºâ¼€ä¸ªnè¡¨ç¤ºæœ‰nä¸ªç»“ç‚¹ï¼Œè¿™nä¸ªç»“ç‚¹ä¸º0~n-1ï¼Œç»™å‡ºè¿™nä¸ªç»“ç‚¹çš„å·¦å³å­©â¼¦ï¼Œæ±‚é—®è¿™æ£µæ ‘æ˜¯ ä¸æ˜¯å®Œå…¨â¼†å‰æ ‘</p>
<p>åˆ†æï¼šé€’å½’å‡ºæœ€â¼¤çš„ä¸‹æ ‡å€¼ï¼Œå®Œå…¨â¼†å‰æ ‘â¼€å®šæŠŠå‰â¾¯çš„ä¸‹æ ‡å……æ»¡ï¼š æœ€â¼¤çš„ä¸‹æ ‡å€¼ == æœ€â¼¤çš„èŠ‚ç‚¹æ•°ï¼› ä¸å®Œå…¨â¼†å‰æ ‘å‰æ»¡â¼€å®šæœ‰ä½ç½®æ˜¯ç©ºï¼Œä¼šå¾€åæŒ¤ï¼š æœ€â¼¤çš„ä¸‹æ ‡å€¼ &gt; æœ€â¼¤çš„èŠ‚ç‚¹æ•°</p>
<p>3.å®Œå…¨äºŒå‰æœç´¢æ ‘ï¼Œå°†å¾…æ’å…¥æ•°æ®a[]ä»å°åˆ°å¤§æ’åºï¼Œåˆ©ç”¨ä¸­åºå»ºæ ‘ï¼Œå­˜æ”¾åˆ°CBTæ•°ç»„ä¸­ï¼Œä¾æ¬¡è¾“å‡ºCBTæ•°ç»„çš„å…ƒç´ å³ä¸ºå®Œå…¨äºŒå‰æœç´¢æ ‘çš„å±‚åºéå†åºåˆ—</p>
<pre><code>void inorder(int root){
	if(root&gt;n) return;
	inorder(root*2);
	CBT[root]=a[index++];
	inorder(root*2+1);
}
</code></pre>
</li>
<li>
<p>æ³¨æ„ç‚¹</p>
<ul>
<li>å®Œå…¨äºŒå‰æ ‘çš„å­˜å‚¨ä¸­ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹ä¸‹æ ‡ä¸º1ï¼Œåˆ™è¯¥æ ‘ä¸­ä»»ä½•ä¸€ä¸ªç»“ç‚¹iï¼Œå…¶å·¦å­©å­ç¼–å·ä¸º2iï¼Œå³å­©å­ç¼–å·ä¸º2i+1ï¼Œçˆ¶äº²èŠ‚ç‚¹ä¸ºä¸‹å–æ•´(i/2);å¦‚æœæ ¹èŠ‚ç‚¹ä¸‹æ ‡ä¸º0ï¼Œå¯¹æ ‘ä¸­æŸç»“ç‚¹i,çˆ¶äº²ç»“ç‚¹ä¸ºä¸‹å–æ•´((i-1)/2);å·¦å­©å­ä¸º2i+1ï¼Œå³å­©å­ä¸º2i+2</li>
<li>å‡½æ•°å‚æ•°ä¸­ï¼Œå¯¹æŒ‡é’ˆæŒ‡å‘çš„ç»“ç‚¹å†…å®¹è¿›è¡Œä¿®æ”¹æ˜¯ä¸éœ€è¦åŠ å¼•ç”¨çš„ï¼Œã€‚å¦‚æœå‡½æ•°ä¸­éœ€è¦æ–°å»ºç»“ç‚¹ï¼Œå³å¯¹äºŒå‰æ ‘çš„ç»“æ„åšå‡ºä¿®æ”¹ï¼Œå°±éœ€è¦åŠ å¼•ç”¨(å¦‚insertï¼Œ)ï¼Œå¦‚æœæ˜¯ä¿®æ”¹å½“å‰å·²æœ‰ç»“ç‚¹çš„å†…å®¹ï¼Œæˆ–è€…æ˜¯éå†æ ‘ï¼Œå°±ä¸éœ€è¦åŠ å¼•ç”¨ã€‚</li>
<li>æ— è®ºæ˜¯å…ˆåºè¿˜æ˜¯ååºï¼Œéƒ½å¿…é¡»çŸ¥é“ä¸­åºåºåˆ—æ‰èƒ½å”¯ä¸€ç¡®å®šä¸€æ£µæ ‘</li>
<li>å¯¹äºé¢˜ç›®ä¸­ç»™å‡ºå·¦å³å­©å­ç»“ç‚¹ç¼–å·çš„æƒ…å†µï¼Œæ²¡æœ‰è¢«å½“åšå­©å­ç»“ç‚¹çš„ç»“ç‚¹ç¼–å·å³ä¸ºæ ¹ç»“ç‚¹ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªæ•°ç»„æ¥åˆ¤æ–­</li>
</ul>
</li>
</ul>
</li>
<li>
<p>æ™®é€šæ ‘</p>
<p>æ·±åº¦éå†ï¼Œé€’å½’è¾¹ç•Œä¸ºæ— å­©å­ç»“ç‚¹ï¼Œæ ¹èŠ‚ç‚¹æ·±åº¦ä¸º0</p>
<pre><code>void DFS(int index,int depth){
	if(Node[index].child.size()==0){
		ans+=Node[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;Node[index].child.size();i++){
		DFS(Node[index].child[i],depth+1);
	}
}
</code></pre>
<p>å¹¿åº¦éå†</p>
<pre><code>void BFS() {
  	level[1] = 1;
  	queue&lt;int&gt; q;
  	q.push(1);
  	while (!q.empty()) {
  		int now = q.front();
  		q.pop();
  		if (child[now].size() == 0) {
  			hashtable[level[now]]++;
  			maxlevel = max(maxlevel, level[now]);
  		}
  		for (int i = 0; i &lt; child[now].size(); i++) {
  			level[child[now][i]] = level[now] + 1;
  			q.push(child[now][i]);
  		}
  	}
  }`
</code></pre>
<p>äºŒå‰æŸ¥æ‰¾æ ‘BST</p>
<ul>
<li>
<p>å­˜å‚¨ç»“æ„</p>
<pre><code>struct node{
	int data;
	node* lchild;
	node* rchild;
};
</code></pre>
</li>
<li>
<p>æ’å…¥</p>
<pre><code>void insert(node*&amp; root, int x) {
	if (root == NULL) {
		root = new node;
		root-&gt;data = x;
		root-&gt;lchild = NULL;
		root-&gt;rchild = NULL;
		return;
	}
	if (x &lt; root-&gt;data) insert(root-&gt;lchild, x);
	else insert(root-&gt;rchild, x);
}
</code></pre>
</li>
<li>
<p>å®Œå…¨äºŒå‰æŸ¥æ‰¾æ ‘</p>
<p>ç”¨æ•°ç»„å­˜æ”¾å®Œå…¨äºŒå‰æŸ¥æ‰¾æ ‘æ—¶ï¼Œå¯ä»¥å…ˆå°†å¾…æ’å…¥çš„æƒå€¼é€’å¢æ’åˆ—ï¼Œç„¶åç”¨ä¸­åºéå†çš„æ–¹å¼å°†å…¶æ’å…¥åˆ°æ ‘ä¸­ï¼Œå¹¶ä¸”è¦æ³¨æ„ç»“ç‚¹åºå·çš„å…³ç³»</p>
<pre><code>void inorder(int root) {
	if (root &gt; n) return;
	inorder(root * 2);
	CBT[root] = number[index++];
	inorder(root * 2 + 1);
}
</code></pre>
</li>
<li>
<p>æ³¨æ„ç‚¹ï¼šå¯¹äºŒå‰æŸ¥æ‰¾æ ‘è¿›è¡Œä¸­åºéå†ï¼Œå…¶ç»“æœæ˜¯æœ‰åºçš„</p>
</li>
</ul>
</li>
<li>
<p>å¹³è¡¡äºŒå‰æ ‘(AVL)</p>
<p>A1066</p>
<p>ä»»æ„ç»“ç‚¹å·¦å­æ ‘ä¸å³å­æ ‘çš„é«˜åº¦ä¹‹å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1</p>
<p>æŸç»“ç‚¹å·¦å­æ ‘ä¸å³å­æ ‘çš„é«˜åº¦ä¹‹å·®æˆä¸ºè¯¥ç»“ç‚¹çš„å¹³è¡¡å› å­ã€‚</p>
<p>åœ¨å¯¹AVLè¿›è¡Œæ’å…¥æ“ä½œæ—¶ï¼Œåªè¦æŠŠæœ€é è¿‘æ’å…¥ç»“ç‚¹çš„å¤±è¡¡ç»“ç‚¹è°ƒæ•´åˆ°æ­£å¸¸ï¼Œè·¯å¾„ä¸Šçš„æ‰€æœ‰ç»“ç‚¹å°±éƒ½ä¼šå¹³è¡¡ã€‚</p>
<ul>
<li>
<p>å­˜å‚¨ç»“æ„</p>
<pre><code>struct node {
	int data, height;
	node* lchild, * rchild;
};
</code></pre>
</li>
<li>
<p>ç”Ÿæˆä¸€ä¸ªæ–°ç»“ç‚¹</p>
<pre><code>node* newNode(int v) {
	node* Node = new node;
	Node-&gt;v = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
</code></pre>
</li>
<li>
<p>è·å–ç»“ç‚¹rootæ‰€åœ¨å­æ ‘å½“å‰é«˜åº¦</p>
<pre><code>int getheight(node* root) {
    if (root == NULL) return 0;
	return root-&gt;height;
}
</code></pre>
</li>
<li>
<p>æ›´æ–°é«˜åº¦</p>
<pre><code>void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
</code></pre>
</li>
<li>
<p>è®¡ç®—å¹³è¡¡å› å­</p>
<pre><code>int getbalancefactor(node* root) {
	return getheight(root-&gt;lchild) - getheight(root-&gt;rchild);
	//æ³¨æ„æ˜¯å·¦å‡å³
}
</code></pre>
</li>
<li>
<p>å·¦æ—‹</p>
<pre><code>void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>å³æ—‹</p>
<pre><code>void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>å»ºæ ‘</p>
<pre><code>void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newnode(v);
		return;
	}
	if (root-&gt;data &gt; v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalance(root) == 2) {
			if (getbalance(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalance(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild, v);
		updateheight(root);
		if (getbalance(root) == -2) {
			if (getbalance(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalance(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>å †(å®Œå…¨äºŒå‰æ ‘(å¤§é¡¶å †ã€å°é¡¶å †))ï¼Œä¸‹é¢ä»¥å¤§é¡¶å †ä¸ºä¾‹</p>
<ul>
<li>
<p>å‘ä¸‹è°ƒæ•´</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>åˆ é™¤å †é¡¶å…ƒç´ </p>
<pre><code>void deletetop() {
	heap[1] = heap[n--];
	downadjust(1, n);
}
</code></pre>
</li>
<li>
<p>å‘ä¸Šè°ƒæ•´</p>
<pre><code>void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>æ’å…¥å…ƒç´ </p>
<pre><code>void insert(int x) {
	heap[++n] = x;
	upadjust(1, n);
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="26-å¹¶æŸ¥é›†">26 å¹¶æŸ¥é›†</h3>
<p>A1107 A1114 A1118</p>
<ul>
<li>
<p>åˆå§‹åŒ–</p>
<pre><code>for(int i=0;i&lt;N;i++){//åˆå§‹åŒ–ï¼Œåƒä¸‡ä¸è¦å¿˜äº†
    father[i]=i;
}
</code></pre>
</li>
<li>
<p>æ‰¾æ ¹ç»“ç‚¹</p>
<pre><code>int findfather(int x){//æ™®é€šç‰ˆæ‰¾æ ¹èŠ‚ç‚¹
    while(x!=father[x]){
      x=father[x];
    }
    return x;
}

int findfather(int x){//è·¯å¾„å‹ç¼©ç‰ˆæ‰¾æ ¹ç»“ç‚¹(éé€’å½’å†™æ³•)
    int a=x;
    while(x!=father[x]) x=father[x];
    while(a!=father[a]){
        int z=a;
        a=father[a];//aå›æº¯åˆ°å…¶çˆ¶äº²èŠ‚ç‚¹
        father[z]=x;//å°†åŸå…ˆçš„ç»“ç‚¹açš„çˆ¶äº²èŠ‚ç‚¹æ”¹ä¸ºæ ¹èŠ‚ç‚¹
    }
    return x;
}

int findfather(int v){//è·¯å¾„å‹ç¼©ç‰ˆæ‰¾æ ¹ç»“ç‚¹(é€’å½’å†™æ³•)
	if(father[v]==v) return v;
	else{
		int F=findfather(father[v]);
		father[v]=F;//æŠŠè·¯å¾„ä¸Šæ‰€æœ‰ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½å˜ä¸ºæ ¹èŠ‚ç‚¹
		return F;
	}
}
</code></pre>
</li>
<li>
<p>åˆå¹¶ä¸¤ä¸ªé›†åˆ</p>
<pre><code>void union(int a,int b){
    int fatherA=findfather(a);
    int fatherB=findfather(b);
    if(fatherA!=fatherB) father[fatherA]=fatherB;
}
</code></pre>
</li>
</ul>
<h3 id="27-å›¾">27 å›¾</h3>
<p>A1013 A1021, A1034 <strong>A1076</strong> A1003 <strong>A1018</strong> A1030 A1072 A1087ï¼ŒA1126(æ¬§æ‹‰å›¾)  A1134(å›¾  ç»“ç‚¹ä¸è¾¹çš„é—®é¢˜)</p>
<p>A1146(åˆ¤æ–­æ˜¯å¦ä¸ºæ‹“æ‰‘æ’åºåºåˆ— )    A1154(25 å›¾  è¾¹çš„ä¸¤ç«¯ç‚¹çš„åˆ¤æ–­ )    A1142(25 æ— å‘å®Œå…¨å›¾ æœ€å¤§å­å›¾  ä¸¤ç‚¹ç›¸è¿)</p>
<p>A1150(25 åˆ¤æ–­å¾ªç¯å›¾ è¾“å‡ºæœ€å°è·¯å¾„)    A1131(30 DFS ã€unordered_mapé‚»æ¥çŸ©é˜µã€ éš¾é¢˜  )</p>
<ul>
<li>
<p>å­˜å‚¨æ–¹å¼</p>
<p>é‚»æ¥è¡¨æˆ–é‚»æ¥çŸ©é˜µ</p>
<p>G[maxn] [maxn] æˆ–è€…vector&lt; vector <int> &gt; G æˆ–vector<int> G[maxn] ç­‰ç­‰</p>
<pre><code>struct node{
   int id;
   int layer;
}
vector&lt;node&gt; adj[amxn];
</code></pre>
</li>
<li>
<p>æ·±åº¦éå†</p>
<pre><code>void DFS(u) {//è®¿é—®é¡¶ç‚¹uæ‰€åœ¨çš„è¿é€šå—
	vis[u] = true;
	......
	for (ä»uå‡ºå‘èƒ½åˆ°è¾¾çš„æ‰€æœ‰é¡¶ç‚¹v) {
        ......
		if (vis[i] == false) {
			DFS(v);
		}
	}
}
void DFStrave(G) {//éå†å›¾G
	for (Gçš„æ‰€æœ‰é¡¶ç‚¹u) {
		if (vis[u] == false) {
			......
			DFS(u);
		    ......
		}
	}
}
</code></pre>
</li>
<li>
<p>å¹¿åº¦éå†</p>
<pre><code>BFS(u){
   queue q;
   inq[u]=true;
   while(qéç©º){
     å–å‡ºé˜Ÿé¦–å…ƒç´ uè¿›è¡Œè®¿é—®ï¼›
     for(ä»uå‡ºå‘å¯ä»¥åˆ°è¾¾çš„æ‰€æœ‰é¡¶ç‚¹v){
       if(inq[v]==false){
         å°†vå…¥é˜Ÿ;
       inq[v]=true;
       }
     }
}
BFStrave(G){
   for(Gçš„æ‰€æœ‰ç»“ç‚¹u){
      if(inq[u]==false){
         BFS(u);
      }
   }
}
</code></pre>
</li>
<li>
<p>åˆ¤æ–­æ˜¯å¦ä¸ºè¿é€šå›¾çš„ä¸¤ç§æ–¹æ³•</p>
<ul>
<li>
<p>æ·±åº¦æœç´¢è®°å½•è®¿é—®ç»“ç‚¹çš„æ•°é‡ï¼Œå¦‚æœè®°å½•çš„è®¿é—®çš„èŠ‚ç‚¹æ•°ç­‰äºæ€»ç»“ç‚¹æ•°ï¼Œåˆ™ä¸ºè¿é€šå›¾</p>
<pre><code>void dfs(int index) {
 visit[index] = true;
 cnt++;
 for (int i = 0; i &lt; v[index].size(); i++)
 if (visit[v[index][i]] == false)
 dfs(v[index][i]);
}
</code></pre>
</li>
<li>
<p>æ·±åº¦æœç´¢è®°å½•è¿é€šå—æ•°é‡</p>
</li>
</ul>
<pre><code>for(int j=1;j&lt;=n;j++){
	if(vis[j]==false){
		DFS(j);
		block++;
	}
}
</code></pre>
</li>
<li>
<p>æœ€çŸ­è·¯å¾„dijkstra</p>
<ul>
<li>
<p>dijkstraå‡½æ•°å†…é¦–å…ˆè¿›è¡Œåˆå§‹åŒ–</p>
<p>åŒ…æ‹¬fill(vis,vis+maxn,false);//æŸä¸ªç»“ç‚¹æ˜¯å¦è®¿é—®<br>
fill(d,d+maxn,INF);//åˆ°æŸä¸ªç»“ç‚¹çš„æœ€çŸ­è·¯å¾„<br>
fill(w,w+maxn,0);//åˆ°æŸä¸ªç»“ç‚¹è·¯å¾„ä¸Šçš„æ€»ç‚¹æƒ(ä¸€èˆ¬ä¸ºæœ€å¤§å€¼)<br>
fill(pt,pt+maxn,0);//è·¯å¾„ä¸Šçš„ç»“ç‚¹ä¸ªæ•°<br>
fill(num,num+maxn,0);//æœ€çŸ­è·¯å¾„æ¡æ•°ï¼Œ</p>
<p>â€‹     for(int i=0;i&lt;n;i++) pre[i]=i;//æ¯ä¸ªç»“ç‚¹çš„å‰é©±ç»“ç‚¹è®¾ä¸ºå…¶æœ¬èº«</p>
<p>æœ€ååœ¨mainå‡½æ•°ä¸­è¿˜æœ‰å¯¹ä¸´æ¥çŸ©é˜µæˆ–ä¸´æ¥é“¾è¡¨çš„åˆå§‹åŒ–ï¼Œå³è®¾ä¸ºINF</p>
</li>
<li>
<p>è¾“å‡ºè·¯å¾„</p>
<pre><code>void printpath(int v){
	if(v==0){//åˆ°è¾¾èµ·å§‹èŠ‚ç‚¹ï¼Œå¼€å§‹è¾“å‡ºï¼Œå¹¶é€å±‚è¿”å›
		cout&lt;&lt;inttostring[v];
		return;
	}
	printpath(pre[v]);
	cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;inttostring[v];
}
</code></pre>
</li>
<li>
<p>dijkstraç¤ºä¾‹ä»£ç </p>
<pre><code>void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(w,w+maxn,0);
	fill(pt,pt+maxn,0);
	fill(num,num+maxn,0);
    for(int i=0;i&lt;n;i++) pre[i]=i;
	d[s]=0;
	w[s]=weight[s];
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];	
					num[v]=num[u];
					pt[v]=pt[u]+1;
					pre[v]=u;
				}else if(d[v]==d[u]+G[u][v]){
					num[v]+=num[u];
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
						pt[v]=pt[u]+1;
						pre[v]=u;
					}else if(w[v]==weight[v]+w[u]){
						double avgfun1=w[v]*1.0/pt[v];
						double avgfun2=(weight[v]+w[u])*1.0/(pt[u]+1);
						if(avgfun2&gt;avgfun1){
							pt[v]=pt[u]+1;
							pre[v]=u;
						}
					}
				}
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>å“ˆå¯†é¡¿é—®é¢˜</p>
<p>A1122(å“ˆå¯†é¡¿å›è·¯ set)</p>
</li>
<li>
<p>ç¬”è®°</p>
<ul>
<li>
<p>è¿é€šçš„ã€ä¸”è¾¹æ•°ä¸ºN-1çš„å…·æœ‰Nä¸ªç»“ç‚¹çš„å›¾ä¸€å®šæ˜¯æ£µæ ‘ã€‚åœ¨è¿™Nä¸ªç»“ç‚¹ä¸­é€‰æ‹©åˆé€‚çš„æ ¹èŠ‚ç‚¹ï¼Œä½¿æ ‘çš„é«˜åº¦æœ€å¤§çš„åŠæ³•æ˜¯ï¼šå…ˆä»»æ„é€‰æ‹©ä¸€ä¸ªç»“ç‚¹ï¼Œä»è¯¥ç»“ç‚¹å‡ºå‘éå†æ•´ä¸ªæ ‘ï¼Œè·å–èƒ½è¾¾åˆ°çš„æœ€æ·±çš„ç»“ç‚¹(è®°ä¸ºé›†åˆA)ï¼Œç„¶åä»é›†åˆAä¸­ä»»æ„ä¸€ä¸ªç»“ç‚¹å‡ºå‘éå†æ•´ä¸ªæ ‘ï¼Œè·å–èƒ½è¾¾åˆ°çš„æœ€æ·±çš„ç»“ç‚¹(è®°ä¸ºé›†åˆB)ï¼Œé›†åˆAä¸é›†åˆBçš„å¹¶é›†å³ä¸ºæ‰€æ±‚çš„ä½¿æ ‘çš„é«˜åº¦æœ€å¤§çš„æ ¹ç»“ç‚¹ã€‚</p>
</li>
<li>
<p>åˆ é™¤å›¾ä¸­æŸä¸ªé¡¶ç‚¹åŠå…¶ç›¸è¿çš„è¾¹æ—¶ï¼Œä¸ç”¨çœŸçš„åˆ é™¤ï¼Œå¯ä»¥åœ¨DFSè®¿é—®åˆ°è¯¥é¡¶ç‚¹æ—¶è¿”å›å³å¯,å¦‚ä¸‹</p>
<pre><code>void DFS(int v){
	if(v==deletepoint) return;//è®¿é—®åˆ°åˆ é™¤çš„ç»“ç‚¹æ—¶è¿”å›
	vis[v]=true;
	for(int i=0;i&lt;G[v].size();i++){
		if(vis[G[v][i]]==false){
			DFS(G[v][i]);
		}
	}
}
</code></pre>
</li>
<li>
<p>ç»“ç‚¹æ ‡å·ä¸ºå­—ç¬¦ä¸²æ—¶ï¼Œå¯ä»¥ç”¨mapè¿›è¡Œå’Œæ•°å­—é—´çš„è½¬åŒ–</p>
</li>
<li>
<p>å¯¹äºæ¯ä¸ªç»“ç‚¹åªèƒ½è®¿é—®ä¸€æ¬¡çš„æƒ…å†µï¼Œå¯ä»¥ä¼˜å…ˆè€ƒè™‘BFS(A1076)</p>
</li>
<li>
<p>ä¸è®ºæ˜¯DFSã€BFSã€djkstéƒ½è¦å…ˆåˆå§‹åŒ–ä¼ å…¥å‚æ•°(å³èµ·å§‹ç»“ç‚¹)çš„ç›¸å…³ä¿¡æ¯</p>
</li>
<li>
<p>åˆ é™¤å›¾ä¸­æŸä¸ªç‚¹iï¼Œå¯ä»¥è®¾ç½®è¯¥ç»“ç‚¹vis[i]=trueå®ç°â€œåˆ é™¤â€</p>
</li>
</ul>
</li>
</ul>
<h3 id="28-åŠ¨æ€è§„åˆ’">28 åŠ¨æ€è§„åˆ’</h3>
<ul>
<li>
<p>æœ€å¤§è¿ç»­å­åºåˆ—å’Œ  A1007</p>
<p>çŠ¶æ€è½¬ç§»æ–¹ç¨‹:<code>dp[i]=max{a[i],dp[i-1]+a[i]}</code></p>
<p>æ³¨æ„è¾¹ç•Œåˆå§‹æ¡ä»¶</p>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};//sæ•°ç»„è®°å½•æœ€å¤§è¿ç»­å­åºåˆ—çš„èµ·å§‹å…ƒç´ 
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
    dp[0]=a[0];//è¾¹ç•Œåˆå§‹æ¡ä»¶--------------------------------------------------------
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){//é¢˜ç›®è¦æ±‚è¾“å‡ºiï¼Œjæœ€å°çš„åºåˆ—ï¼Œæ‰€ä»¥è¿™é‡Œçš„åˆ¤æ–­æ˜¯&gt;è€Œä¸æ˜¯&gt;=
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
</li>
<li>
<p>æœ€é•¿ä¸ä¸‹é™å­åºåˆ— (LIS) A1045</p>
<p>çŠ¶æ€è½¬ç§»æ–¹ç¨‹:<code>dp[i]=max{1,dp[j]+1}</code></p>
<p>å¦‚æœå­˜åœ¨a[i]ä¹‹å‰çš„å…ƒç´ a[j] (j&lt;i)ï¼Œä½¿å¾—a[j]&lt;=a[i]å¹¶ä¸”dp[j]+1&gt;dp[i],é‚£ä¹ˆå°±æŠŠa[i]è·Ÿåœ¨ä»¥a[j]ä¸ºç»“å°¾çš„LISåé¢ï¼Œå½¢æˆä¸€æ¡æ›´é•¿çš„ä¸ä¸‹é™å­åºåˆ—(ä»¤dp[i]=dp[j]+1)</p>
<p>å¦‚æœa[i]ä¹‹å‰çš„å…ƒç´ éƒ½æ¯”a[i]å¤§ï¼Œé‚£ä¹ˆa[i]å°±åªå¥½è‡ªå·±å½¢æˆä¸€æ¡LISï¼Œé•¿åº¦ä¸º1</p>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;//è¾¹ç•Œåˆå§‹æ¡ä»¶--------------------------------------
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
  	ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
</li>
<li>
<p>æœ€é•¿å…¬å…±å­åºåˆ— A1045</p>
<ul>
<li>ç»å…¸LCSæ¨¡å‹ï¼Œä¸¤ä¸ªåºåˆ—çš„å…ƒç´ åŒ¹é…å¿…é¡»ä¸€ä¸€å¯¹åº”ï¼š</li>
</ul>
<p>â€‹      çŠ¶æ€è½¬ç§»æ–¹ç¨‹:å¦‚æœa[i]==b[j],<code>dp[i] [j]=dp[i-1] [j-1]+1</code>,</p>
<p>â€‹      å¦‚æœa[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
<ul>
<li>
<p>æœ¬é¢˜ä¸­å…è®¸å…¬å…±éƒ¨åˆ†äº§ç”Ÿé‡å¤å…ƒç´ </p>
<p>çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¿®æ”¹ä¸º:</p>
<p>å¦‚æœa[i]==b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}+1</code></p>
<p>å¦‚æœa[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
</li>
</ul>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;//è¾¹ç•Œèµ·å§‹æ¡ä»¶
    for(int i=0;i&lt;L;i++) dp[0][i]=0;//è¾¹ç•Œèµ·å§‹æ¡ä»¶
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;                   
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
</li>
<li>
<p>æœ€é•¿å›æ–‡å­ä¸² A1040</p>
<p>dp[i] [j]è¡¨ç¤ºs[i]è‡³s[j]è¡¨ç¤ºçš„å­ä¸²æ˜¯å¦ä¸ºå›æ–‡å­ä¸²</p>
<p>çŠ¶æ€è½¬ç§»æ–¹ç¨‹: å¦‚æœs[i]==s[j],<code>dp[i] [j]=dp[i+1] [j-1]</code></p>
<p>å¦‚æœs[i]!=s[j], <code>dp[i] [j]=0</code></p>
</li>
</ul>
<p>â€‹       è¾¹ç•Œï¼š<code>dp[i] [i] =1;dp[i] [i+1]=(s[i]==s[i+1])? 1 : 0</code></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){//è¾¹ç•Œåˆå§‹åŒ–
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;//åˆå§‹åŒ–æ—¶æ³¨æ„æœ€é•¿å›æ–‡å­ä¸²çš„é•¿åº¦
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<ul>
<li>
<p>èƒŒåŒ…é—®é¢˜</p>
<ul>
<li>
<p>01èƒŒåŒ… A1068</p>
<p>dp[i] [v]=max{dp[i-1] [v],dp[i-1] [v-w[i]]+c[i]}(1&lt;=i&lt;=n, w[i]&lt;=v&lt;=V)</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="29-åˆ†å—-å®æ—¶æŸ¥è¯¢é—®é¢˜">29 åˆ†å—  (å®æ—¶æŸ¥è¯¢é—®é¢˜)</h3>
<p>A1057</p>
<p>æŸéè´Ÿæ•´æ•°åºåˆ—å…ƒç´ çš„å–å€¼èŒƒå›´ä¸º0åˆ°Nï¼Œåˆ™æ¯å—ä¸­å…ƒç´ ä¸ªæ•°æ˜¯æ ¹å·N(å‘ä¸‹å–æ•´)ï¼Œå—æ•°æ˜¯æ ¹å·N(å‘ä¸Šå–æ•´)</p>
<p>ä¾‹å¦‚æ‰€æœ‰å…ƒç´ éƒ½ä¸è¶…è¿‡100000ï¼Œåˆ™å¯ä»¥å°†åºåˆ—åˆ†ä¸º317å—ï¼Œæ¯å—316ä¸ªå…ƒç´ ï¼Œå¹¶ç”¨table[]æ•°ç»„è®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œç”¨block[]æ•°ç»„è®°å½•æ¯å—ä¸­çš„å…ƒç´ ä¸ªæ•°</p>
<h3 id="30-æ ‘çŠ¶æ•°ç»„bit-å®æ—¶æŸ¥è¯¢">30 æ ‘çŠ¶æ•°ç»„(BIT) (å®æ—¶æŸ¥è¯¢)</h3>
<p><code>#define lowbit(i) ((i) &amp; (-i))</code></p>
<p>C[i]çš„è¦†ç›–é•¿åº¦æ˜¯<code>lowbit(i)</code>,æ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡å¿…é¡»ä»1å¼€å§‹</p>
<pre><code>int getsum(int x)//è¿”å›å‰xä¸ªæ•´æ•°ä¹‹å’Œ{
   int sum=0;
   for(int i=x;i&gt;0;i-=lowbit(i)){
      sum+=c[i];
   }
   return sum;
}
</code></pre>
<pre><code>void update(int x,int v){
   for(int i=x;i&lt;=N;i+=lowbit(i)){
      c[i]+=v;
   }
}
</code></pre>
<h3 id="31-å¯æ€•æ¨¡æ‹Ÿ">31 å¯æ€•æ¨¡æ‹Ÿ</h3>
<p>A1017(25 )   A1153( 25 æ¨¡æ‹Ÿ æ’åºå¼•ç”¨ä¼ å‚ vector unordered_map)</p>
<p>A1014(30 æ¨¡æ‹Ÿ  éš¾é¢˜)</p>
<h3 id="32-nçš‡å">32 nçš‡å</h3>
<p>A1128(20)</p>
<h3 id="33å †">33.å †</h3>
<p>å †æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå¯ä»¥ç”¨heap[1]~heap[n]æ•°ç»„å­˜å‚¨ï¼Œ</p>
<ul>
<li>
<p>å †æ’åº</p>
<pre><code>//å¤§é¡¶å †ä¸ºä¾‹
void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
void createheap() {//å»ºå †
	for (int i = n / 2; i &gt;= 1; i--) {
		downadjust(i, n);
	}
}
void heapsort(){
    createheap();
    for(int i=n;i&gt;1;i--){
        swap(heap[1],heap[i]);
        upadjust(1,i-1);
    }
}
</code></pre>
</li>
<li>
<p>åˆ é™¤å †é¡¶å…ƒç´ </p>
<pre><code>void deleteTop(){
    heap[1]=heap[n--];//ç”¨æœ€åä¸€ä¸ªå…ƒç´ è¦†ç›–å †é¡¶å…ƒç´ ï¼Œå¹¶è®©å…ƒç´ ä¸ªæ•°å‡ä¸€
    downadjust(1,n);
}
</code></pre>
</li>
<li>
<p>åœ¨å †çš„æœ€åæ’å…¥æ–°å…ƒç´ </p>
<pre><code>void upadjust(int low, int high) {//
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
void insert(int x){
    heap[++n]=x;
    upadjust(1,n);
}
</code></pre>
</li>
</ul>
<h1 id="æ³¨æ„">æ³¨æ„</h1>
<p>1.= ä¸ ==</p>
<p>2.å˜é‡åˆå§‹åŒ–èµ‹å€¼æ—¶æœ‰æ—¶å¿…é¡»èµ‹å€¼ä¸º0æˆ–1</p>
<p>3.æ³¨æ„å…¨å±€å˜é‡ä¸å±€éƒ¨å˜é‡</p>
<p>4.<code>s1[i]-'0'</code>ï¼Œå­—ç¬¦æ•°ç»„å˜ä¸ºæ•´å‹æ•°å­—</p>
<p>5.<code>s1[i]&gt;='0' &amp;&amp; s1[1]&lt;='9'</code>ï¼Œå­—ç¬¦æ•°ç»„ä¸­å¯»æ‰¾0åˆ°9ä¹‹é—´çš„æ•°å­—</p>
<p>6.æ³¨æ„è¾“å‡ºç»“æœä¸º0æ—¶çš„ç‰¹æ®Šæƒ…å†µï¼Œéšè—çš„æµ‹è¯•ç‚¹ç­‰</p>
<p>7.æ®µé”™è¯¯å¾ˆå¯èƒ½æ˜¯æ•°ç»„è¶Šç•Œï¼Œå¯èƒ½æ˜¯å®šä¹‰çš„æ•°ç»„é•¿åº¦ä¸ç¬¦åˆé¢˜ç›®é™åˆ¶çš„æœ€å¤§èŒƒå›´</p>
<p>8.æ³¨æ„if å’Œelse if çš„æ­é…ä½¿ç”¨ï¼Œ æ³¨æ„å‡½æ•°ä¼ å…¥å€¼node* root ï¼Œä¸‹é¢å¯¹åº”root=new node,è€Œä¸æ˜¯node*root=new node,è¾“å‡ºæ ¼å¼<code>printf(&quot;\n&quot;)</code>,<code>printf(&quot; &quot;)</code>æ˜¯å¦æ­£ç¡®</p>
<p>9.å¦‚æœæƒ³è¦åœ¨ Dev-Cpp â¾¥â¾¯ä½¿â½¤C++11, åœ¨èœå•æ ä¸­â¼¯å…·-ç¼–è¯‘é€‰é¡¹-ç¼–è¯‘å™¨-ç¼–è¯‘æ—¶åŠ â¼Š -std=c++11 è¿™å¥å‘½ä»¤å³å¯</p>
<p>11.æœ‰æ—¶å¹¶ä¸ä¸€å®šçœŸçš„è¦å®ç°å‡ºæ­£ç¡®çš„ç®—æ³•ï¼Œæœ€åä¸ç®¡ç”¨ä»€ä¹ˆæ–¹å¼ï¼Œåªè¦èƒ½è¾“å‡ºæ­£ç¡®çš„æ ¼å¼å°±å¥½</p>
<p>12.æ³¨æ„è®¾ç½®boolå‹çš„å˜é‡ç”¨äºåˆ¤æ–­</p>
<p>13.æ³¨æ„è¾“å…¥çš„ä¾‹å­ä¸­å¯èƒ½æœ‰æ— æ•ˆçš„æ•°æ®ï¼Œè¦æ‰¾å‡ºæœ‰æ•ˆçš„æ•°æ®è¿›è¡Œå¤„ç†</p>
<p>14.<code>cmp</code>ä¸­å†™æŒ‰å­—æ¯å¤§å°æ’åºï¼Œæ³¨æ„å†™æˆ<code>strcmp()&lt;0</code>......çš„å½¢å¼</p>
<p>15.çœ‹é¢˜ç›®ä¸­çš„æ•°æ®æ˜¯æ•´æ•°è¿˜æ˜¯æµ®ç‚¹æ•°ï¼Œæ³¨æ„é¢˜ç›®ä¸­æ•°æ®çš„ä¿ç•™ä½æ•°</p>
<p>16.æ³¨æ„æ˜¯ä½¿ç”¨whileè¿˜æ˜¯ifï¼Œä¸è¦å¿˜äº†breakæˆ–continueï¼Œæ³¨æ„åŒºåˆ†æ˜¯ç”¨breakè¿˜æ˜¯continue</p>
<p>17.<code>long long k=(long long)p*num[i]</code>;    è‹¥æ–°å£°æ˜çš„å˜é‡ä¸ºlong long å‹ï¼Œå³è¾¹ä¸ºintä¹˜intå‹ï¼Œæœ€å¥½åœ¨å³è¾¹å¸¦ä¸Šå¼ºåˆ¶è½¬æ¢(long long)ï¼Œå…¶ä»–æƒ…å†µä¹Ÿè¿™æ ·å§....</p>
<p>18.æ³¨æ„æ˜¯å¤šä¸ªifå¹¶åˆ— è¿˜æ˜¯ifä¸else ifç»“åˆä½¿ç”¨</p>
<p>19.intä¸Šé™ä¸º<code>0x7fffffff</code>, å³2^31 -1,å¯ä»¥ç”¨<code>const int INF=0x7fffffff</code>,ä¹Ÿå¯ä»¥å†™æˆ<code>(1&lt;&lt;31)-1</code></p>
<p>â€‹     intä¸‹é™ä¸º-2^31ã€‚const double eps=1e-8(å³10çš„-8æ¬¡æ–¹ï¼Œæ³¨æ„æ˜¯æ•°å­—1ä¸æ˜¯å­—æ¯l)ï¼Œconst double     INF=1e12(å³10^12)</p>
<p>20.å­—ç¬¦æ•°ç»„å˜ä¸ºæ•°å­—æ—¶è¦æ³¨æ„å‡'0',<code>res.d[i] = str[res.len - 1 - i]-'0'</code></p>
<p>21.å‡½æ•°çš„å‚æ•°å‰æœ‰æ—¶éœ€è¦åŠ å¼•ç”¨&amp;</p>
<p>22.æ“ä½œæ”¾åœ¨èŠ±æ‹¬å·å†…è¿˜æ˜¯èŠ±æ‹¬å·å¤–ï¼Œæ³¨æ„æ¡ä»¶çš„åˆ¤æ–­</p>
<p>23.æ³¨æ„DFSçš„ä¸‹ä¸€å±‚è¿›è¡ŒDFSæ—¶ï¼Œè¦å†™DFS(i,height+1)  ä¸è¦å†™height++</p>
<p>24.æ¶‰åŠåˆ°æ’åºé—®é¢˜æ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨setæˆ–mapå†…éƒ¨è‡ªåŠ¨æ’åºçš„å®¹å™¨ï¼Œä¹Ÿå¯ä»¥å…ˆæŠŠé¢˜ç›®ä¸­ç»™å‡ºçš„æ•°æ®å…ˆæ’åºå†å¤„ç†</p>
<p>25.æäº¤æ—¶å‡ºç°â€œè¿è¡Œæ—¶å‘ç”Ÿé”™è¯¯â€çš„æƒ…å†µï¼Œä¸€èˆ¬æ˜¯å¼€çš„æ•°ç»„å¤ªå°ï¼Œæ²¡æœ‰è¾¾åˆ°é¢˜ç›®è¦æ±‚çš„æœ€å¤§å€¼</p>
<p>26.ä¸è¦å¿˜äº†ä¸€äº›ç®—æ³•çš„åˆå§‹åŒ–ï¼Œæ¯”å¦‚ä½¿ç”¨å¹¶æŸ¥é›†åƒä¸‡ä¸è¦å¿˜äº†åˆå§‹åŒ–<code>father[i]=i</code></p>
<p>27ä¸€äº›é¢˜ç›®å¤„ç†çš„æ˜¯äº”ä½æ•°çš„æ ¼å¼ï¼Œ(æ¯”å¦‚idå·)ï¼Œæ‰€ä»¥è¾“å‡ºæ—¶æ³¨æ„<code>printf(&quot;%05d&quot;)</code></p>
<p>28.å››èˆäº”å…¥ä¸ºæ•´æ•°<code>int(v[temp].gm * 0.4 + v[temp].gf * 0.6 + 0.5);</code></p>
<p>â€‹      <strong>åœ¨æœ€ååŠ ä¸Š0.5å¹¶å¼ºåˆ¶è½¬æ¢ä¸ºintå‹å³ä¸ºå››èˆäº”å…¥</strong></p>
<p>29.A1139é‚»æ¥çŸ©é˜µçš„å·§å¦™å†™æ³•</p>
<pre><code>unordered_map&lt;int ,bool&gt; isfri;
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
10000ä¸ºè¶…è¿‡æœ€å¤§èŒƒå›´çš„æ•´æ•°
</code></pre>
<p>30.é¢˜ç›®ä¸­æ•°æ®é‡å¤§çš„æ—¶å€™æœ€å¥½ä¸ç”¨<code>cin</code>å’Œ<code>cout</code></p>
<p>31.æ•°æ®é‡å¤§æ—¶sortçš„cmpå‡½æ•°å¯ä»¥ç”¨å¼•ç”¨ä¼ å€¼ï¼Œä»¥é˜²è¶…æ—¶</p>
<p>æ¯”å¦‚</p>
<pre><code>bool cmp2(node&amp; a,node&amp; b){
	return a.id&lt;b.id;
}
</code></pre>
<p>32.é¢˜ç›®ä¸­åŒæ—¶æœ‰intå‹å’Œæµ®ç‚¹å‹æ ¼å¼çš„æ•°æ®ï¼Œæœ€å¥½ç»Ÿä¸€å®šä¹‰æˆæµ®ç‚¹å‹</p>
<ol start="33">
<li>æŸä¸ªæµ‹è¯•ç‚¹ä¸è¿‡æœ‰å¯èƒ½æ˜¯æ•°æ®ç±»å‹æœ‰é—®é¢˜ï¼Œæ¯”å¦‚éœ€è¦å¼ºåˆ¶ç±»å‹è½¬æ¢ç­‰ç­‰ï¼Œæ¢æˆæ•°æ®è¡¨ç¤ºèŒƒå›´æ›´å¤§çš„64ä½æ•°æ®ç±»å‹</li>
</ol>
<ul>
<li>
<p>å±‚åºéå†ä¸­é˜Ÿåˆ—é‡Œå­˜æ”¾çš„æ˜¯ç»“ç‚¹çš„åœ°å€ï¼ŒåŠ¨æ€çš„å°±æ˜¯node*ç±»å‹ï¼Œé™æ€çš„å°±æ˜¯root(intå‹)ç»“ç‚¹ç¼–å·</p>
</li>
<li>
<p>å°†å›¾å½“åšæ ‘å»å¤„ç†æ—¶ï¼Œæ³¨æ„æ— å‘å›¾æ˜¯åŒå‘çš„ï¼Œå¯èƒ½ä¼šå›æº¯å·²ç»è®¿é—®çš„ç»“ç‚¹ï¼Œè¦æ³¨æ„é¿å…</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://liuxbo.github.io/post/hello-gridea/</id>
        <link href="https://liuxbo.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>