<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://liuxbo.github.io</id>
    <title>lxb&apos;blog</title>
    <updated>2020-12-02T00:54:53.547Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://liuxbo.github.io"/>
    <link rel="self" href="https://liuxbo.github.io/atom.xml"/>
    <subtitle>菜鸡成长之路</subtitle>
    <logo>https://liuxbo.github.io/images/avatar.png</logo>
    <icon>https://liuxbo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, lxb&apos;blog</rights>
    <entry>
        <title type="html"><![CDATA[PAT2019春、秋、冬，2020春、秋真题]]></title>
        <id>https://liuxbo.github.io/post/2019-nian-pat-chun-qiu-dong-zhen-ti/</id>
        <link href="https://liuxbo.github.io/post/2019-nian-pat-chun-qiu-dong-zhen-ti/">
        </link>
        <updated>2020-07-19T13:39:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="115620-sexy-primes-素数">1156(20 Sexy Primes  素数)</h3>
<p>题目描述：</p>
<p>Sexy primes are pairs of primes of the form (p, p+6), so-named since “sex” is the Latin word for “six”. (Quoted from http://mathworld.wolfram.com/SexyPrimes.html)</p>
<p>Now given an integer, you are supposed to tell if it is a sexy prime.</p>
<p>Input Specification:<br>
Each input file contains one test case. Each case gives a positive integer N (≤10^8).</p>
<p>Output Specification:<br>
For each case, print in a line Yes if N is a sexy prime, then print in the next line the other sexy prime paired with N (if the answer is not unique, output the smaller number). Or if N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N.</p>
<pre><code>Sample Input 1:
47
Sample Output 1:
Yes
41
Sample Input 2:
21
Sample Output 2:
No
23
</code></pre>
<p>————————————————</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x) {
	if(x&lt;=1) return false;
	int sqr=sqrt(1.0*x);
	for(int i=2; i&lt;=sqr; i++) {
		if(x%i==0) return false;
	}
	return true;
}
bool sexprime(int x) {
	if(((isprime(x)&amp;&amp;isprime(x+6)))||((isprime(x))&amp;&amp;isprime(x-6)))
		return true;
	return false;
}
int main() {
	int n;
	cin&gt;&gt;n;
	if(sexprime(n)) cout&lt;&lt;&quot;Yes\n&quot;&lt;&lt;n-6;
	else {
		cout&lt;&lt;&quot;No\n&quot;;
		while(!sexprime(n)) n++;
		cout&lt;&lt;n;
	}
	return 0;
}
</code></pre>
<h3 id="115725-anniversary-unordered_mapset">1157(25 Anniversary unordered_map/set)</h3>
<p>题目描述:</p>
<p>Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association （校友会） has gathered the ID’s of all her alumni. Now your job is to write a program to count the number of alumni<br>
among all the people who come to the celebration.</p>
<p>Input Specification:<br>
Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer NNN (≤105).<br>
Then NNN lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X. It is guaranteed that all the ID’s are distinct.<br>
The next part gives the information of all the people who come to the celebration.<br>
Again given in the first line is a positive integer MMM(≤105). Then MMM lines follow, each contains an ID number of a guest. It is guaranteed that all the ID’s are distinct.</p>
<p>Output Specification:<br>
First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus – notice that the 7th - 14th digits of the ID gives one’s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.</p>
<pre><code>Sample Input:
5
372928196906118710
610481197806202213
440684198612150417
13072819571002001X
150702193604190912
6
530125197901260019
150702193604190912
220221196701020034
610481197806202213
440684198612150417
370205198709275042

Sample Output:
3
150702193604190912
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
int main() {
	int n,m,cnt=0;
	cin&gt;&gt;n;
	getchar();//注意 
	string s,oldest=&quot;999999999999999999&quot;;
	unordered_map&lt;string,bool&gt; mp;
	for(int i=0; i&lt;n; i+7+) {
		cin&gt;&gt;s;
		if(s.substr(6,8)&lt;oldest.substr(6,8)) oldest=s;
		mp[s]=true;
	}
	cin&gt;&gt;m;
	while(m--) {
		cin&gt;&gt;s;
		if(mp[s]==true) cnt++;
	}
	if(cnt!=0) cout&lt;&lt;cnt&lt;&lt;endl&lt;&lt;oldest;
    return 0;
}
</code></pre>
<h3 id="115825-电信诈骗-并查集-图">1158(25 电信诈骗 并查集 图)</h3>
<p>题目描述:</p>
<p>Telefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.</p>
<p>A person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes.</p>
<p>Input Specification:<br>
Each input file contains one test case. For each case, the first line gives 3 positive integers K (≤500, the threshold（阈值） of the amount of short phone calls), N (≤10^3, the number of different phone numbers), and M (≤10^5, the number of phone call records). Then M lines of one day's records are given, each in the format:</p>
<pre><code>caller receiver duration
</code></pre>
<p>where caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day.</p>
<p>Output Specification:<br>
Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>If no one is detected, output None instead.</p>
<pre><code>Sample Input 1:

5 15 31
1 4 2
1 5 2
1 5 4
1 7 5
1 8 3
1 9 1
1 6 5
1 15 2
1 15 5
3 2 2
3 5 15
3 13 1
3 12 1
3 14 1
3 10 2
3 11 5
5 2 1
5 3 10
5 1 1
5 7 2
5 6 1
5 13 4
5 15 1
11 10 5
12 14 1
6 1 1
6 9 2
6 10 5
6 11 2
6 12 1
6 13 1

Sample Output 1:
3 5
6

Sample Input 2:
5 7 8
1 2 1
1 3 1
1 4 1
1 5 1
1 6 1
1 7 1
2 1 1
3 1 1

Sample Output 2:
None
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
#include&lt;map&gt;
using namespace std;
const int maxn=1001;
int k,n,m,father[maxn],g[maxn][maxn],gangnum=0;
int findfather(int x){
	while(x!=father[x]) x=father[x];
	return x;
}
void Union(int a,int b) {
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA&gt;faB) father[faA]=faB;
	else if(faA&lt;faB) father[faB]=faA;
}
int main() {
	for(int i=1; i&lt;=maxn; i++) father[i]=i;
	scanf(&quot;%d%d%d&quot;,&amp;k,&amp;n,&amp;m);
	vector&lt;int&gt; gang[n+1],susp;
	int v1,v2,time;
	fill(g[0],g[0]+maxn*maxn,0);
	for(int i=0; i&lt;m; i++) {
		scanf(&quot;%d%d%d&quot;,&amp;v1,&amp;v2,&amp;time);
		g[v1][v2]=time;
	}
	for(int i=1;i&lt;=n;i++){
		int total=0,cnt=0;
		for(int j=1;j&lt;=n;j++){
			if(g[i][j]&gt;0&amp;&amp;g[i][j]&lt;=5){
				total++;
				if(g[j][i]&gt;0) cnt++;
			}
		}
		if((double)(cnt*1.0/total)&lt;=0.2&amp;&amp;total&gt;k) susp.push_back(i);
	}
	for(int i=0;i&lt;susp.size();i++){
		for(int j=0;j&lt;susp.size();j++){
			if(g[susp[i]][susp[j]]&gt;0&amp;&amp;g[susp[j]][susp[i]]&gt;0) Union(susp[i],susp[j]);
		}
	}
	for(int i=0;i&lt;susp.size();i++){
		gang[findfather(susp[i])].push_back(susp[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(gang[i].size()!=0){
			for(int j=0;j&lt;gang[i].size();j++){
				if(j&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,gang[i][j]);
			}
			gangnum++;
			printf(&quot;\n&quot;);
		}
	}
	if(gangnum==0) printf(&quot;None&quot;);
	return 0;
}
</code></pre>
<h3 id="115930-map-sscanf-中序后序建树加树的综合性考察">1159(30 map、sscanf、中序后序建树加树的综合性考察)</h3>
<p>题目描述:</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p>
<p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p>
<pre><code>A is the root
A and B are siblings
A is the parent of B
A is the left child of B
A is the right child of B
A and B are on the same level
It is a full tree
</code></pre>
<p>Note:</p>
<ul>
<li>
<p>Two nodes are on the same level, means that they have the same depth.</p>
</li>
<li>
<p>A full binary tree is a tree in which every node other than the<br>
leaves has two children.</p>
</li>
</ul>
<p><strong>Input Specification:</strong><br>
Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 103 and are separated by a space.</p>
<p>Then another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree.</p>
<p><strong>Output Specification:</strong><br>
For each statement, print in a line Yes if it is correct, or No if not.</p>
<p><strong>Sample Input:</strong></p>
<pre><code>9
16 7 11 32 28 2 23 8 15
16 23 7 32 11 2 28 15 8
7
15 is the root
8 and 2 are siblings
32 is the parent of 11
23 is the left child of 16
28 is the right child of 2
7 and 11 are on the same level
It is a full tree
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>Yes
No
Yes
No
Yes
Yes
Yes
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	int v,level;
	node*parent,*lc,*rc;
	node(int val,int lev) : v(val),parent(NULL),lc(NULL),rc(NULL),level(lev) {}  //构造函数 
};
unordered_map&lt;int,node*&gt; mp;//妙啊
vector&lt;int&gt; in,post;
node*root=NULL;
bool isfull=true;
node*create(int postl,int postr,int inl,int inr,int level) {
	if(postl&gt;postr) return NULL;
	node*root=new node(post[postr],level);
	int k=inl;
	while(k&lt;=inr&amp;&amp;in[k]!=root-&gt;v) k++;
	int leftnum=k-inl;
	root-&gt;lc=create(postl,postl+leftnum-1,inl,k-1,level+1);
	root-&gt;rc=create(postl+leftnum,postr-1,k+1,inr,level+1);
	if(root-&gt;lc!=NULL) root-&gt;lc-&gt;parent=root;
	if(root-&gt;rc!=NULL) root-&gt;rc-&gt;parent=root;
	if((root-&gt;lc==NULL&amp;&amp;root-&gt;rc!=NULL)||(root-&gt;lc!=NULL&amp;&amp;root-&gt;rc==NULL)) isfull=false;
	mp[root-&gt;v]=root;
	return root;
}
bool judge(string s) {
	int a,b;
	if(s.find(&quot;root&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the root&quot;,&amp;a);
		return a==root-&gt;v;
	} else if(s.find(&quot;siblings&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d and %d are siblings&quot;,&amp;a,&amp;b);
		return mp[a]-&gt;parent==mp[b]-&gt;parent;
	} else if(s.find(&quot;parent&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the parent of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;parent==mp[a];
	} else if(s.find(&quot;left&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the left child of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;lc==mp[a]; //注意在判断时一定要判断地址是否相等， 不要判断数值，因为可能会有空地址 
	} else if(s.find(&quot;right&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the right child of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;rc==mp[a];
	}else if(s.find(&quot;on&quot;)!=string::npos){
		sscanf(s.c_str(),&quot;%d and %d are on the same level&quot;,&amp;a,&amp;b);
		return mp[a]-&gt;level==mp[b]-&gt;level;
	}else return isfull;
}
int main(){
	int n,m;
	string s;
	cin&gt;&gt;n;
	in.resize(n),post.reserve(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i];
	root=create(0,n-1,0,n-1,0);
	cin&gt;&gt;m;
	getchar();//注意 
	while(m--){
		getline(cin,s);
		if(judge(s)) cout&lt;&lt;&quot;Yes\n&quot;;
		else cout&lt;&lt;&quot;No\n&quot;;
	}
	return 0;
}
</code></pre>
<h3 id="1160-20-forever-dfs回溯剪枝">1160 (20 Forever dfs+回溯剪枝)</h3>
<p>题目描述:</p>
<p>&quot;Forever number&quot; is a positive integer <em>A</em> with <em>K</em> digits, satisfying the following constrains:</p>
<ul>
<li>the sum of all the digits of <em>A</em> is <em>m</em>;</li>
<li>the sum of all the digits of <em>A</em>+1 is <em>n</em>; and</li>
<li>the greatest common divisor of <em>m</em> and <em>n</em> is a prime number which is greater than 2.</li>
</ul>
<p>Now you are supposed to find these forever numbers.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤5). Then <em>N</em> lines follow, each gives a pair of <em>K</em> (3&lt;<em>K</em>&lt;10) and <em>m</em> (1&lt;<em>m</em>&lt;90), of which the meanings are given in the problem description.</p>
<p>Output Specification:</p>
<p>For each pair of <em>K</em> and <em>m</em>, first print in a line <code>Case X</code>, where <code>X</code> is the case index (starts from 1). Then print <em>n</em> and <em>A</em> in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of <em>n</em>. If still not unique, output in the ascending order of <em>A</em>. If there is no solution, output <code>No Solution</code>.</p>
<p><strong>Sample Input:</strong></p>
<pre><code>2
6 45
7 80
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>Case 1
10 189999
10 279999
10 369999
10 459999
10 549999
10 639999
10 729999
10 819999
10 909999
Case 2
No Solution
</code></pre>
<pre><code>方法一:dfs
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int n, A;	//n A+1各个位数之和 A求的数
};
int n,m,N,k;
vector&lt;node&gt; ans;
bool cmp(node a,node b) {	//按照n递增排序，n相同按照A递增排序
	if(a.n != b.n) return a.n &lt; b.n;
	else return a.A &lt; b.A;
}
bool isPrime(int x) {	//判断是不是大于3的素数
	if(x &lt;= 2) return false;
	for(int i = 2; i * i&lt;= x; i++)
		if(x % i == 0) return false;
	return true;
}
int gcd(int a,int b) {	//求最大公约数
	return b == 0 ? a : gcd(b,a%b);
}
int digit_sum(int A) {	//各个位数之和
	int sum = 0;
	while(A) {
		sum += A%10;
		A/=10;
	}
	return sum;
}
void DFS(int A, int sum, int rest_K) {	//A目标数 sum当前位数和 rest_k剩余k位
	if(rest_K == 0) {	//递归边界
		if(sum == m) {
			int n = digit_sum(A + 1);
			if(isPrime(gcd(m, n)))
				ans.push_back({n, A});
		}
	} else if(rest_K &gt; 0) {
		for(int i = 0; i &lt;= 9; i++) {
			//如果当前位为i，即时剩余的rest_k - 1位全部取9也无法达到m，则剪枝
			//当前位数和sum，当前位取i，已经超过了m也剪枝
			if(sum + i + (rest_K-1)*9 &gt;= m &amp;&amp; sum + i &lt;= m)
				DFS(A*10 + i, sum+i, rest_K-1);
		}
	}
}
int main() {
	scanf(&quot;%d&quot;,&amp;N);	//样例数
	for(int x = 1; x &lt;= N; x++) {
		ans.clear();
		printf(&quot;Case %d\n&quot;,x);
		scanf(&quot;%d%d&quot;,&amp;k,&amp;m);	//k A的位数， m A各位数之和
		for(int i = 1; i &lt;= 9; i++)	//i是最高位的数的取值
			DFS(i, i, k-1);
		if(ans.empty()) {
			printf(&quot;No Solution\n&quot;);
			continue;
		}
		sort(ans.begin(), ans.end(), cmp);
		for(int i = 0; i &lt; ans.size(); i++) {
			printf(&quot;%d %d\n&quot;,ans[i].n, ans[i].A);
		}
	}
	return 0;
}

方法二:数学规律
按照尾数为99的数枚举，加一不进位的话，这两个数的各位之和相差的是1，无论如何也不会有不小于三的最小公约数
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
using namespace std;
int k, n,m,a,b,c,d,num;
bool f=false;
struct node {
	int n,a;
};
int gcd(int a,int b) {
	return b==0?a:gcd(b,a%b);
}
bool isPrime(int n) {
	if(n&lt;=2)return false;
	int sq=(int)sqrt(n);
	for(int j=2; j&lt;=sq; j++) {
		if(n%j==0)return false;
	}
	return true;
}
int sum(int n) {
	return n==0? 0: n%10 + sum(n/10);
}
bool cmp(node &amp;a,node &amp;b) {
	if(a.n!=b.n)return a.n&lt;b.n;
	return a.a&lt;b.a;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++) {
		scanf(&quot;%d %d&quot;,&amp;k,&amp;m);
		printf(&quot;Case %d\n&quot;,i+1);
		a=(int)pow(10,k-3);//-3
		b=a*10;
		vector&lt;node&gt; v;
		for(int x=a; x&lt;b; x++) {
			c=x*100+99;
			d=sum(c+1);
			if(sum(c)==m &amp;&amp; isPrime(gcd(d,m))) {
				v.push_back({d,c});
			}
		}
		if(v.size()==0) printf(&quot;No Solution\n&quot;);
		else {
			sort(v.begin(),v.end(),cmp);
			for(auto it:v) {
				printf(&quot;%d %d\n&quot;,it.n,it.a);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="116125-合并链表">1161(25 合并链表)</h3>
<p><strong>Merging Linked Lists</strong> (25分)</p>
<p>题目描述:</p>
<p>Merging Linked Lists (25分)</p>
<p>Given two singly linked lists <em>L</em>1=<em>a</em>1→<em>a</em>2→⋯→<em>a**n</em>−1→<em>a**n</em> and <em>L</em>2=<em>b</em>1→<em>b</em>2→⋯→<em>b**m</em>−1→<em>b**m</em>. If <em>n</em>≥2<em>m</em>, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like <em>a</em>1→<em>a</em>2→<em>b**m</em>→<em>a</em>3→<em>a</em>4→<em>b**m</em>−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of <em>L</em>1 and <em>L</em>2, plus a positive <em>N</em> (≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than 105, and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p>
<p>Output Specification:</p>
<p>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong></p>
<pre><code class="language-in">00100 01000 7
02233 2 34891
00100 6 00001
34891 3 10086
01000 1 02233
00033 5 -1
10086 4 00033
00001 7 -1
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code class="language-out">01000 1 02233
02233 2 00001
00001 7 34891
34891 3 10086
10086 4 00100
00100 6 00033
00033 5 -1
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node {
	int address,data,next;
} list[maxn];
int main() {
	int n,st1,st2;
	vector&lt;node&gt; v1,v2,v;
	scanf(&quot;%d%d%d&quot;,&amp;st1,&amp;st2,&amp;n);
	for(int i=0; i&lt;n; i++) {
		int addrs;
		scanf(&quot;%d&quot;,&amp;addrs);
		list[addrs].address=addrs;
		scanf(&quot;%d%d&quot;,&amp;list[addrs].data,&amp;list[addrs].next);
	}
	while(st1!=-1) {
		v1.push_back(list[st1]);
		st1=list[st1].next;
	}
	while(st2!=-1) {
		v2.push_back(list[st2]);
		st2=list[st2].next;
	}
	int len1=v1.size(),len2=v2.size(),index=0;
	if(len1&gt;len2) {
		reverse(v2.begin(),v2.end());
		for(int i=0; i&lt;=len1; i++) {
			if(i!=0&amp;&amp;i%2==0&amp;&amp;index&lt;len2) {
				v.push_back(v2[index++]);
			}
			if(i&lt;len1) v.push_back(v1[i]);
		}
	} else {
		reverse(v1.begin(),v1.end());
		for(int i=0; i&lt;=len2; i++) {
			if(i!=0&amp;&amp;i%2==0&amp;&amp;index&lt;len1) {
				v.push_back(v1[index++]);
			}
			if(i&lt;len2) v.push_back(v2[i]);
		}
	}
	for(int i=0;i&lt;v.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,v[i].address,v[i].data,v[i+1].address);
	printf(&quot;%05d %d -1&quot;,v[v.size()-1].address,v[v.size()-1].data);
	return 0;
}
</code></pre>
<h3 id="116225-输出树的后缀表达式">1162(25 输出树的后缀表达式)</h3>
<p><strong>Postfix Expression</strong>(25分)</p>
<p>Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <em>i</em>-th line corresponds to the <em>i</em>-th node) in the format:</p>
<pre><code>data left_child right_child
</code></pre>
<p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clxb%5CPictures%5C%E6%A0%91.png" alt="https://images.ptausercontent.com/4d1c4a98-33cc-45ff-820f-c548845681ba.JPG" loading="lazy"></figure>
<p>Output Specification:</p>
<p>For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.</p>
<p><strong>Sample Input 1:</strong></p>
<pre><code class="language-in">8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
</code></pre>
<p><strong>Sample Output 1:</strong></p>
<pre><code class="language-out">(((a)(b)+)((c)(-(d))*)*)
</code></pre>
<p><strong>Sample Input 2:</strong></p>
<pre><code class="language-in">8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
</code></pre>
<p><strong>Sample Output 2:</strong></p>
<pre><code class="language-out">(((a)(2.35)*)(-((str)(871)%))+)
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	string data;
	int lc,rc;
} v[21];
string ans;
void postorder(int index) {
	bool flag=false;
	if((v[index].rc!=-1&amp;&amp;v[index].lc!=-1)||(v[index].lc==-1&amp;&amp;v[index].rc!=-1)||(v[index].lc==-1&amp;&amp;v[index].rc==-1)) {
		flag=true;
		ans+=&quot;(&quot;;
	}
	if(v[index].lc==-1&amp;&amp;v[index].rc!=-1) {
		ans+=v[index].data;
		postorder(v[index].rc);
	} else {
		if(v[index].lc!=-1)postorder(v[index].lc);
		if(v[index].rc!=-1)postorder(v[index].rc);
		ans+=v[index].data;
	}
	if(flag) ans+=&quot;)&quot;;
}
int main() {
	int n,root=1,notroot[21]= {0};
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; i++) {
		cin&gt;&gt;v[i].data&gt;&gt;v[i].lc&gt;&gt;v[i].rc;
		if(v[i].lc!=-1) notroot[v[i].lc]=1;
		if(v[i].rc!=-1) notroot[v[i].rc]=1;
	}
	while(notroot[root]==1) root++;
	postorder(root);
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="116330-判断dijkst的合法路径">1163(30 判断dijkst的合法路径)</h3>
<p>Dijkstra Sequence (30分)</p>
<p>Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p>
<p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra's algorithm.</p>
<p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N**v</em> (≤103) and <em>N**e</em> (≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <em>N**v</em>.</p>
<p>Then <em>N**e</em> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p>
<p>Finally the number of queries, <em>K</em>, is given as a positive integer no larger than 100, followed by <em>K</em> lines of sequences, each contains a permutationof the <em>N**v</em> vertices. It is assumed that the first vertex is the source for each sequence.</p>
<p>All the inputs in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each of the <em>K</em> sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p>
<p><strong>Sample Input:</strong></p>
<pre><code class="language-in">5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code class="language-out">Yes
Yes
Yes
No
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1001;
const int INF=0x7fffffff;
int g[maxn][maxn],d[maxn],nv,ne,k,index;
bool vis[maxn];
vector&lt;int&gt; path;
bool judge(int s) {
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=1; i&lt;=nv; i++) {
		int u=-1,MIN=INF;
		for(int j=1; j&lt;=nv; j++) {
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN) {
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return true;
		if(d[path[index]]==MIN&amp;&amp;vis[path[index]]==false) {
			u=path[index];
			index++;
			vis[u]=true;
		} else return false;
		for(int v=1; v&lt;=nv; v++) {
			if(vis[v]==false&amp;&amp;g[u][v]!=INF) {
				if(d[v]&gt;d[u]+g[u][v]) d[v]=d[u]+g[u][v];
			}
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	fill(g[0],g[0]+maxn*maxn,INF);
	for(int i=0; i&lt;ne; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		scanf(&quot;%d&quot;,&amp;g[v1][v2]);
		g[v2][v1]=g[v1][v2];
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--) {
		path.clear();
		path.resize(nv);
		for(int i=0; i&lt;nv; i++) scanf(&quot;%d&quot;,&amp;path[i]);
		index=0;
		if(judge(path[index])) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="116420-图形输出-逻辑题-注意用stringgetchar吸收换行符">1164(20 图形输出 逻辑题 注意用string，getchar吸收换行符)</h3>
<p>7-1 Good in C (20分)</p>
<p>When your interviewer asks you to write &quot;Hello World&quot; using C, can you do as the following figure shows?</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of <code>C</code>'s and <code>.</code>'s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.</p>
<p>It is guaranteed that there is at least one word given.</p>
<p>Output Specification:</p>
<p>For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.</p>
<p>Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.</p>
<p>Sample Input:</p>
<pre><code class="language-in">..C..
.C.C.
C...C
CCCCC
C...C
C...C
C...C
CCCC.
C...C
C...C
CCCC.
C...C
C...C
CCCC.
.CCC.
C...C
C....
C....
C....
C...C
.CCC.
CCCC.
C...C
C...C
C...C
C...C
C...C
CCCC.
CCCCC
C....
C....
CCCC.
C....
C....
CCCCC
CCCCC
C....
C....
CCCC.
C....
C....
C....
CCCC.
C...C
C....
C.CCC
C...C
C...C
CCCC.
C...C
C...C
C...C
CCCCC
C...C
C...C
C...C
CCCCC
..C..
..C..
..C..
..C..
..C..
CCCCC
CCCCC
....C
....C
....C
....C
C...C
.CCC.
C...C
C..C.
C.C..
CC...
C.C..
C..C.
C...C
C....
C....
C....
C....
C....
C....
CCCCC
C...C
C...C
CC.CC
C.C.C
C...C
C...C
C...C
C...C
C...C
CC..C
C.C.C
C..CC
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.CCC.
CCCC.
C...C
C...C
CCCC.
C....
C....
C....
.CCC.
C...C
C...C
C...C
C.C.C
C..CC
.CCC.
CCCC.
C...C
CCCC.
CC...
C.C..
C..C.
C...C
.CCC.
C...C
C....
.CCC.
....C
C...C
.CCC.
CCCCC
..C..
..C..
..C..
..C..
..C..
..C..
C...C
C...C
C...C
C...C
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.C.C.
..C..
C...C
C...C
C...C
C.C.C
CC.CC
C...C
C...C
C...C
C...C
.C.C.
..C..
.C.C.
C...C
C...C
C...C
C...C
.C.C.
..C..
..C..
..C..
..C..
CCCCC
....C
...C.
..C..
.C...
C....
CCCCC
HELLO~WORLD!
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">C...C CCCCC C.... C.... .CCC.
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
CCCCC CCCC. C.... C.... C...C
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
C...C CCCCC CCCCC CCCCC .CCC.

C...C .CCC. CCCC. C.... CCCC.
C...C C...C C...C C.... C...C
C...C C...C CCCC. C.... C...C
C.C.C C...C CC... C.... C...C
CC.CC C...C C.C.. C.... C...C
C...C C...C C..C. C.... C...C
C...C .CCC. C...C CCCCC CCCC.
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;vector&gt;
using namespace std;
string a[30][10],str;
vector&lt;int&gt; word;
int main() {
	for(int i=0; i&lt;26; i++) {
		for(int j=0; j&lt;7; j++) {
			cin&gt;&gt;a[i][j];
		}
	}
	getchar();//因为cin会把换行符留在缓冲区，所以这里要将换行符忽略掉
	getline(cin,str);
	bool flag=false;
	for(int i=0; i&lt;str.size(); i++) {
		if(isupper(str[i]) &amp;&amp; i==str.size()-1)
			word.push_back(str[i]-'A');
		if(isupper(str[i]) &amp;&amp; i!=str.size()-1) {
			word.push_back(str[i]-'A');
		} else {
			if(word.size()==0) cout&lt;&lt;&quot;&quot;;
			else {
				if(flag) cout&lt;&lt;endl&lt;&lt;endl;
				for(int k=0; k&lt;7; k++) {
					for(int j=0; j&lt;word.size(); j++) {
						if(j!=0) cout&lt;&lt;&quot; &quot;;
						cout&lt;&lt;a[word[j]][k];
						flag=true;
					}
					if(k!=6)cout&lt;&lt;endl;
				}
				word.clear();
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="116525-链表分段拼接">1165(25 链表分段拼接)</h3>
<p>Given a singly linked list <em>L</em>. Let us consider every <em>K</em> nodes as a <strong>block</strong> (if there are less than <em>K</em> nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in <em>L</em>. For example, given <em>L</em> as 1→2→3→4→5→6→7→8 and <em>K</em> as 3, your output must be 7→8→4→5→6→1→2→3.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p>Output Specification:</p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p>Sample Input:</p>
<pre><code class="language-in">00100 8 3
71120 7 88666
00000 4 99999
00100 1 12309
68237 6 71120
33218 3 00000
99999 5 68237
88666 8 -1
12309 2 33218
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">71120 7 88666
88666 8 00000
00000 4 99999
99999 5 68237
68237 6 00100
00100 1 12309
12309 2 33218
33218 3 -1
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int addrs,data,next;
}list[100000];
int main(){
	int st,n,k,cnt,len;
	scanf(&quot;%d%d%d&quot;,&amp;st,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		int addrs;
		scanf(&quot;%d&quot;,&amp;addrs);
		list[addrs].addrs=addrs;
		scanf(&quot;%d%d&quot;,&amp;list[addrs].data,&amp;list[addrs].next);
	}
	vector&lt;node&gt; v;
	while(st!=-1){
		v.push_back(list[st]);
		st=list[st].next;
	}
	if(v.size()%k==0) cnt=v.size()/k;
	else cnt=v.size()/k+1;
	int pos;
	for(int i=0;i&lt;cnt;i++){
		int j,x;
		if(i==0) j=v.size()-(cnt-1)*k;
		else j=k;
		if(i==0) pos=v.size()-j;
		for(x=pos;x&lt;pos+j-1;x++) printf(&quot;%05d %d %05d\n&quot;,v[x].addrs,v[x].data,v[x+1].addrs);
		pos-=k;
		if(pos&lt;0) printf(&quot;%05d %d -1\n&quot;,v[x].addrs,v[x].data);
		else printf(&quot;%05d %d %05d\n&quot;,v[x].addrs,v[x].data,v[pos].addrs);
	}
	return 0;
}
</code></pre>
<h3 id="116625-图">1166(25 图)</h3>
<p>7-3 Summit (25分)</p>
<p>A <strong>summit</strong> (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone.</p>
<p>Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N.</p>
<p>Then there is another positive integer K (≤ 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (≤ N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each of the K areas, print in a line your advice in the following format:</p>
<ul>
<li>if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print <code>Area X is OK.</code>.</li>
<li>if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print <code>Area X may invite more people, such as H.</code> where <code>H</code> is the smallest index of the head who may be invited.</li>
<li>if in this area the arrangement is not an ideal one, then print <code>Area X needs help.</code> so the host can provide some special service to help the heads get to know each other.</li>
</ul>
<p>Here <code>X</code> is the index of an area, starting from 1 to <code>K</code>.</p>
<p>Sample Input:</p>
<pre><code class="language-in">8 10
5 6
7 8
6 4
3 6
4 5
2 3
8 2
2 7
5 3
3 4
6
4 5 4 3 6
3 2 8 7
2 2 3
1 1
2 4 6
3 3 2 1
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">Area 1 is OK.
Area 2 is OK.
Area 3 is OK.
Area 4 is OK.
Area 5 may invite more people, such as 3.
Area 6 needs help.
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=205;
int main() {
	int n,m,g[maxn][maxn],k,num,vis[maxn];
	fill(g[0],g[0]+maxn*maxn,0);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0; i&lt;m; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int i=1; i&lt;=k; i++) {
		fill(vis,vis+maxn,false);
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		int flag=1;
		for(int j=0; j&lt;num; j++) {
			scanf(&quot;%d&quot;,&amp;v[j]);
			vis[v[j]]=true;
		}
		for(int j=0; j&lt;num-1; j++) {
			for(int x=j+1; x&lt;num; x++) {
				if(flag==0) break;
				if(g[v[j]][v[x]]!=1) {
					flag=0;
					break;
				}
			}
		}
		if(flag==0) {
			printf(&quot;Area %d needs help.\n&quot;,i);
			continue;
		} else {
			for(int j=1; j&lt;=n; j++) {
				if(vis[j]==false) {
					int x;
					for(x=0; x&lt;v.size(); x++) {
						if(g[v[x]][j]==0) break;
					}
					if(x==v.size()) {
						printf(&quot;Area %d may invite more people, such as %d.\n&quot;,i,j);
						flag=0;
						break;
					}
				}
			}
			if(flag==1) printf(&quot;Area %d is OK.\n&quot;,i);
		}
	}
	return 0;
}
</code></pre>
<h3 id="116730-用中序遍历序列建立堆树">1167(30 用中序遍历序列建立“堆”树)</h3>
<p>7-4 Cartesian Tree (30分)</p>
<p>A <strong>Cartesian tree</strong> is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.</p>
<figure data-type="image" tabindex="2"><img src="https://images.ptausercontent.com/6a99f68a-6578-46e0-9232-fbf0adf3691f.jpg" alt="CTree.jpg" loading="lazy"></figure>
<p>Your job is to output the level-order traversal sequence of the min-heap Cartesian tree.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts from giving a positive integer <em>N</em> (≤30), and then <em>N</em> distinct numbers in the next line, separated by a space. All the numbers are in the range of <strong>int</strong>.</p>
<p>Output Specification:</p>
<p>For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
8 15 3 4 1 5 12 10 18 6
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">1 3 5 8 4 6 15 10 12 18
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int v;
	node*lc,*rc;
};
int n,v[31],num=0;
node*create(int inl,int inr) {
	if((inl&gt;inr)||inl&lt;0||inr&gt;=n) return NULL;
	node*root=new node;
	int *addrs=min_element(v+inl,v+inl+(inr-inl+1));
	int index=addrs-v;
	root-&gt;lc=create(inl,index-1);
	root-&gt;v=v[index];
	root-&gt;rc=create(index+1,inr);
	return root;
}
void levelorder(node*root) {
	queue&lt;node*&gt;q;
	q.push(root);
	while(!q.empty()) {
		node*t=q.front();
		q.pop();
		if(num!=0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,t-&gt;v);
		num++;
		if(t-&gt;lc!=NULL) q.push(t-&gt;lc);
		if(t-&gt;rc!=NULL) q.push(t-&gt;rc);
	}
}
int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;v[i]);
	node*root=create(0,n-1);
	levelorder(root);
	return 0;
}
</code></pre>
<h3 id="1168-prime-day">1168  Prime Day</h3>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5Clxb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200829143952987.png" alt="image-20200829143952987" loading="lazy"></figure>
<p>The above picture is from Sina Weibo, showing May 23rd, 2019 as a very cool “Prime Day”. That is, not only that the corresponding number of the date 20190523 is a prime, but all its sub-strings ended at the last digit 3 are prime numbers.</p>
<p>Now your job is to tell if a given date is a Prime Day.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, a date between January 1st, 0001 and December 31st, 9999 is given, in the format yyyymmdd.</p>
<p><strong>Output Specification:</strong></p>
<p>For each given date, output in the decreasing order of the length of the substrings, each occupies a line. In each line, print the string first, followed by a space, then Yes if it is a prime number, or No if not. If this date is a Prime Day, print in the last line All Prime!.</p>
<p><strong>Sample Input 1:</strong></p>
<p>20190523</p>
<p><strong>Sample Output 1:</strong></p>
<pre><code>20190523 Yes
0190523 Yes
190523 Yes
90523 Yes
0523 Yes
523 Yes
23 Yes
3 Yes
All Prime!
Sample Input 2:
20191231
Sample Output 2:
20191231 Yes
0191231 Yes
191231 Yes
91231 No
1231 Yes
231 No
31 Yes
1 No
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt; 
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	string s;
	cin&gt;&gt;s;
	int flag=1;
	while(s.length()&gt;0){
		int t=stoi(s);
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
		if(isprime(t)) printf(&quot;Yes\n&quot;);
		else {
			flag=0;
			printf(&quot;No\n&quot;);
		}
		s.erase(s.begin());
	}
	if(flag) printf(&quot;All Prime!&quot;);
	return 0; 
}
</code></pre>
<h3 id="1169-the-judger">1169 The Judger</h3>
<p>A game of numbers has the following rules: at the beginning, two distinct positive integers are given by the judge. Then each player in turn must give a number to the judge. The number must be the difference of two numbers that are previously given, and must not be duplicated to any of the existed numbers. The game will run for several rounds. The one who gives a duplicate number or even a wrong number will be kicked out.</p>
<p>Your job is to write a judger program to judge the players' numbers and to determine the final winners.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two distinct positive integers to begin with. Both numbers are in [1,10^5 ].</p>
<p>In the second line, two numbers are given: N (2≤N≤10), the number of players, and M (2≤M≤10^3), the number of rounds.</p>
<p>Then N lines follow, each contains M positive integers. The i-th line corresponds to the i-th player (i=1,⋯,N). The game is to start from the 1st player giving his/her 1st number, followed by everybody else giving their 1st numbers in the 1st round; then everyone give their 2nd numbers in the 2nd round, and so on so forth.</p>
<p>Output Specification:</p>
<p>If the i-th player is kicked out in the k-th round, print in a line Round #k: i is out.. The rest of the numbers given by the one who is out of the game will be ignored. If more than one player is out in the same round, print them in increasing order of their indices. When the game is over, print in the last line Winner(s): W1 W2 ... Wn, where W1 ... Wn are the indices of the winners in increasing order. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. If there is no winner, print No winner. instead.</p>
<p>Sample Input 1:</p>
<pre><code>101 42
4 5
59 34 67 9 7
17 9 8 50 7
25 92 43 26 37
76 51 1 41 40
</code></pre>
<p>Sample Output 1:</p>
<pre><code>Round #4: 1 is out.
Round #5: 3 is out.
Winner(s): 2 4
</code></pre>
<p>Sample Input 2:</p>
<pre><code>42 101
4 5
59 34 67 9 7
17 9 18 50 49
25 92 58 1 39
102 32 2 6 41
</code></pre>
<p>Sample Output 2:</p>
<pre><code>Round #1: 4 is out.
Round #3: 2 is out.
Round #4: 1 is out.
Round #5: 3 is out.
No winner.
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n1,n2,n,m,isout[12]= {0},v[12][1005]= {0},exist[200010]= {0};
	vector&lt;int&gt; win,ex;
	scanf(&quot;%d%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n,&amp;m);
	for(int i=1; i&lt;=n; i++) {
		for(int j=1; j&lt;=m; j++) {
			scanf(&quot;%d&quot;,&amp;v[i][j]);
		}
	}
	ex.push_back(n1);
	ex.push_back(n2);
	exist[n1]=1;
	exist[n2]=1;
	for(int j=1; j&lt;=m; j++) {
		for(int i=1; i&lt;=n; i++) {
			int flag=0;
			if(isout[i]==1) continue;
			if(exist[v[i][j]]==1) {
				isout[i]=1;
				printf(&quot;Round #%d: %d is out.\n&quot;,j,i);
				continue;
			}
			for(int k=0; k&lt;ex.size(); k++) {
				if(exist[v[i][j]+ex[k]]==1) {
					flag=1;
					break;
				}
			}
			if(flag==0) {
				isout[i]=1;
				printf(&quot;Round #%d: %d is out.\n&quot;,j,i);
				continue;
			}
			exist[v[i][j]]=1;
			ex.push_back(v[i][j]);
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		if(isout[i]==0) win.push_back(i);
	}
	if(win.size()==0) printf(&quot;No winner.\n&quot;);
	else{
		printf(&quot;Winner(s):&quot;);
		for(int i=0;i&lt;win.size();i++) printf(&quot; %d&quot;,win[i]);
	}
	return 0;
}
</code></pre>
<h3 id="1170-safari-park">1170 Safari Park</h3>
<p>A safari park（野生动物园）has K species of animals, and is divided into N regions. The managers hope to spread the animals to all the regions, but not the same animals in the two neighboring regions. Of course, they also realize that this is an NP complete problem, you are not expected to solve it. Instead, they have designed several distribution plans. Your job is to write a program to help them tell if a plan is feasible.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives 3 integers: N (0&lt;N≤500), the number of regions; R (≥0), the number of neighboring relations, and K (0&lt;K≤N), the number of species of animals. The regions and the species are both indexed from 1 to N.</p>
<p>Then R lines follow, each gives the indices of a pair of neighboring regions, separated by a space.</p>
<p>Finally there is a positive M (≤20) followed by M lines of distribution plans. Each plan gives N indices of species in a line (the i-th index is the animal in the i-th rigion), separated by spaces. It is guaranteed that any pair of neighboring regions must be different, and there is no duplicated neighboring relations.</p>
<p>Output Specification:</p>
<p>For each plan, print in a line Yes if no animals in the two neighboring regions are the same, or No otherwise. However, if the number of species given in a plan is not K, you must print Error: Too many species. or Error: Too few species. according to the case.</p>
<p>Sample Input:</p>
<pre><code>6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
5
1 2 3 3 1 2
1 2 3 4 5 6
4 5 6 6 4 5
2 3 4 2 3 4
2 2 2 2 2 2
</code></pre>
<p>Sample Output:</p>
<pre><code>Yes
Error: Too many species.
Yes
No
Error: Too few species.
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n,r,k,m;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;r,&amp;k);
	vector&lt;int&gt; v[r];
	for(int i=0; i&lt;r; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[i].push_back(v1);
		v[i].push_back(v2);
	}
	scanf(&quot;%d&quot;,&amp;m);
	for(int i=0; i&lt;m; i++) {
		int g[510],flag=1;
		set&lt;int&gt;s;
		for(int j=1; j&lt;=n; j++) {
			scanf(&quot;%d&quot;,&amp;g[j]);
			s.insert(g[j]);
		}
		if(s.size()&gt;k) {
			printf(&quot;Error: Too many species.\n&quot;);
			continue;
		} else if(s.size()&lt;k) {
			printf(&quot;Error: Too few species.\n&quot;);
			continue;
		}
		for(int j=0; j&lt;r; j++) {
			if(g[v[j][0]]==g[v[j][1]]) {
				flag=0;
				printf(&quot;No\n&quot;);
				break;
			}
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="1171-replacement-selection">1171 <strong>Replacement Selection</strong></h3>
<p>When the input is much too large to fit into memory, we have to do <strong>external sorting</strong> instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called <strong>runs</strong>) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.</p>
<p><strong>Replacement Selection</strong> sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.</p>
<p>For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the <strong>first run</strong>. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.</p>
<p>Your job is to implement this replacement selection algorithm.</p>
<p>Input Specification:</p>
<p>Each input file contains several test cases. The first line gives two positive integers <em>N</em> (≤105) and <em>M</em> (&lt;<em>N</em>/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then <em>N</em> numbers are given in the next line, all in the range of <strong>int</strong>. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">13 3
81 94 11 96 12 99 17 35 28 58 41 75 15
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">11 81 94 96 99
12 17 28 35 41 58 75
15
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v;
	for(int i=0; i&lt;n; i++) {
		int temp;
		scanf(&quot;%d&quot;,&amp;temp);
		v.push_back(temp);
	}
	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
	int index=0,count=0,TOP;
	vector&lt;int&gt;temp,ans;
	while(index&lt;m) q.push(v[index++]);
	while(count!=n) {
		TOP=q.top();
		ans.push_back(TOP);
		q.pop();
		count++;
		if(index&lt;n) {
			if(v[index]&gt;TOP) q.push(v[index++]);
			else temp.push_back(v[index++]);
		}
		if(q.empty()) {
			for(int i=0; i&lt;ans.size(); i++) {
				if(i&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,ans[i]);
			}
			printf(&quot;\n&quot;);
			ans.clear();
			for (int i = 0; i &lt; temp.size(); i++)//v的数全都放到q里
				q.push(temp[i]);
			temp.clear();
		}

	}
	return 0;
}
</code></pre>
<h3 id="1172-2020-秋季panda-and-pp-milk20">1172 2020 秋季<strong>Panda and PP Milk</strong>（20）</h3>
<figure data-type="image" tabindex="4"><img src="https://images.ptausercontent.com/6049de68-39dd-4707-b952-a73f5049153c.jpg" alt="panda.jpg" loading="lazy"></figure>
<p>PP milk （盆盆奶）is Pandas' favorite. They would line up to enjoy it as show in the picture. On the other hand, they could drink in peace only if they believe that the amount of PP milk is fairly distributed, that is, fatter panda can have more milk, and the ones with equal weight may have the same amount. Since they are lined up, each panda can only compare with its neighbor(s), and if it thinks this is unfair, the panda would fight with its neighbor.</p>
<p>Given that the minimum amount of milk a panda must drink is 200 ml. It is only when another bowl of milk is at least 100 ml more than its own that a panda can sense the difference.</p>
<p>Now given the weights of a line of pandas, your job is to help the breeder（饲养员）to decide the minimum total amount of milk that he/she must prepare, provided that the pandas are lined up in the given order.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, first a positive integer <em>n</em> (≤104) is given as the number of pandas. Then in the next line, <em>n</em> positive integers are given as the weights (in kg) of the pandas, each no more than 200. the numbers are separated by spaces.</p>
<p>Output Specification:</p>
<p>For each test case, print in a line the minimum total amount of milk that the breeder must prepare, to make sure that all the pandas can drink in peace.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
180 160 100 150 145 142 138 138 138 140
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">3000
</code></pre>
<p>Hint:</p>
<p>The distribution of milk is the following:</p>
<pre><code>400 300 200 500 400 300 200 200 200 300
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int  n,ans=0;
	cin&gt;&gt;n;
	vector&lt;int&gt; v,num,num1;
	v.resize(n),num.resize(n),num1.resize(n);
	for(int i=0; i&lt;n; i++) cin&gt;&gt;v[i];
	num[0]=200;
	for(int i=1; i&lt;n; i++) {
		if(v[i]&gt;v[i-1]) num[i]=num[i-1]+100;
		else num[i]=200;
	}
	num1[n-1]=200;
	ans+=num[n-1];
	for(int i=n-2; i&gt;=0; i--) {
		if(v[i]&gt;v[i+1]) 	num1[i]=num1[i+1]+100;
		else	num1[i]=200;
		if(num[i]&gt;num1[i]) ans+=num[i];
		else ans+=num1[i];
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="1173-7-2-how-many-ways-to-buy-a-piece-of-land-25分">1173 <strong>7-2</strong> <strong>How Many Ways to Buy a Piece of Land</strong>  (25分)</h3>
<p>The land is for sale in CyberCity, and is divided into several pieces. Here it is assumed that each piece of land has exactly two neighboring pieces, except the first and the last that have only one. One can buy several contiguous（连续的） pieces at a time. Now given the list of prices of the land pieces, your job is to tell a customer in how many different ways that he/she can buy with a certain amount of money.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case first gives in a line two positive integers: <em>N</em> (≤104), the number of pieces of the land (hence the land pieces are numbered from 1 to <em>N</em> in order), and <em>M</em> (≤109), the amount of money that your customer has.</p>
<p>Then in the next line, <em>N</em> positive integers are given, where the <em>i</em>-th one is the price of the <em>i</em>-th piece of the land.</p>
<p>It is guaranteed that the total price of the land is no more than 109.</p>
<p>Output Specification:</p>
<p>For each test case, print the number of different ways that your customer can buy. Notice that the pieces must be contiguous.</p>
<p>Sample Input:</p>
<pre><code class="language-in">5 85
38 42 15 24 9
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">11
</code></pre>
<p>Hint:</p>
<p>The 11 different ways are:</p>
<pre><code>38
42
15
24
9
38 42
42 15
42 15 24
15 24
15 24 9
24 9
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int n,mon,ans=0;
	cin&gt;&gt;n&gt;&gt;mon;
	vector&lt;int&gt; sum(n+1,0);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=i;j&lt;=n;j++){
			if(sum[j]-sum[i-1]&lt;=mon) ans++;
			else break;
		}
	}
	cout&lt;&lt;ans;
}
</code></pre>
<h3 id="1174-left-view-of-binary-tree-25分">1174 <strong>Left-View of Binary Tree</strong> (25分)</h3>
<p>The <strong>left-view</strong> of a binary tree is a list of nodes obtained by looking at the tree from left hand side and from top down. For example, given a tree shown by the figure, its left-view is { 1, 2, 3, 4, 5 }</p>
<figure data-type="image" tabindex="5"><img src="https://images.ptausercontent.com/d995df0a-31ea-4659-9f26-7bcd03ee23da.JPG" alt="fig.JPG" loading="lazy"></figure>
<p>Given the inorder and preorder traversal sequences of a binary tree, you are supposed to output its left-view.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20), which is the total number of nodes in the tree. Then given in the following 2 lines are the inorder and preorder traversal sequences of the tree, respectively. All the keys in the tree are distinct positive integers in the range of <strong>int</strong>.</p>
<p>Output Specification:</p>
<p>For each case, print in a line the left-view of the tree. All the numbers in a line are separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">8
2 3 1 5 4 7 8 6
1 2 3 6 7 4 5 8
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">1 2 3 4 5
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,maxdepth=-1;
vector&lt;int&gt; level[22];
struct node{
	int v;
	node *lc,*rc;
};
vector&lt;int&gt; in,pre;
void dfs(node *root,int depth){
	if(root==NULL) {
		if(depth&gt;maxdepth) maxdepth=depth;
		return;
	}
	level[depth].push_back(root-&gt;v);
	dfs(root-&gt;lc,depth+1);
	dfs(root-&gt;rc,depth+1);
}
node* create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node *root=new node;
	root-&gt;v=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;lc=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;rc=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
int main(){
	cin&gt;&gt;n;
	in.resize(n);
	pre.resize(n);
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;in[i];
	}
	for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];
	node*root=create(0,n-1,0,n-1);
	dfs(root,1);
	for(int i=1;i&lt;maxdepth;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,level[i][0]);
	}
	return 0;
}
</code></pre>
<h3 id="1175-professional-ability-test-30分">1175  <strong>Professional Ability Test</strong> (30分)</h3>
<p>Professional Ability Test (PAT) consists of several series of subject tests. Each test is divided into several levels. Level A is a <strong>prerequisite (前置要求)</strong> of Level B if one must pass Level A with a score no less than <em>S</em> in order to be qualified to take Level B. At the mean time, one who passes Level A with a score no less than <em>S</em> will receive a voucher（代金券）of <em>D</em> yuans (Chinese dollar) for taking Level B.</p>
<p>At the moment, this PAT is only in design and hence people would make up different plans. A plan is <strong>NOT</strong> consistent if there exists some test T so that T is a prerequisite of itself. Your job is to test each plan and tell if it is a consistent one, and at the mean time, find the easiest way (with minimum total <em>S</em>) to obtain the certificate of any subject test. If the easiest way is not unique, find the one that one can win the maximum total value of vouchers.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (≤1000) and <em>M</em>, being the total numbers of tests and prerequisite relations, respectively. Then <em>M</em> lines follow, each describes a prerequisite relation in the following format:</p>
<pre><code>T1 T2 S D
</code></pre>
<p>where <code>T1</code> and <code>T2</code> are the indices (from 0 to <em>N</em>−1) of the two distinct tests; <code>S</code> is the minimum score (in the range (0, 100]) required to pass <code>T1</code> in order to be qualified to take <code>T2</code>; and <code>D</code> is the value of the voucher (in the range (0, 500]) one can receive if one passes <code>T1</code> with a score no less than <code>S</code> and plan to take <code>T2</code>. It is guaranteed that at most one pair of <code>S</code> and <code>D</code> are defined for a prerequisite relation.</p>
<p>Then another positive integer <em>K</em> (≤<em>N</em>) is given, followed by <em>K</em> queries of tests. All the numbers in a line are separated by spaces.</p>
<p>Output Specification:</p>
<p>Print in the first line <code>Okay.</code> if the whole plan is consistent, or <code>Impossible.</code> if not.</p>
<p>If the plan is consistent, for each query of test <code>T</code>, print in a line the easiest way to obtain the certificate of this test, in the format:</p>
<pre><code>T0-&gt;T1-&gt;...-&gt;T
</code></pre>
<p>However, if <code>T</code> is the first level of some subject test (with no prerequisite), print <code>You may take test T directly.</code> instead.</p>
<p>If the plan is impossible, for each query of test <code>T</code>, check if one can take it directly or not. If the answer is yes, print in a line <code>You may take test T directly.</code>; or print <code>Error.</code> instead.</p>
<p>Sample Input 1:</p>
<pre><code class="language-in">8 15
0 1 50 50
1 2 20 20
3 4 90 90
3 7 90 80
4 5 20 20
7 5 10 10
5 6 10 10
0 4 80 60
3 1 50 45
1 4 30 20
1 5 50 20
2 4 10 10
7 2 10 30
2 5 30 20
2 6 40 60
8
0 1 2 3 4 5 6 7
</code></pre>
<p>Sample Output 1:</p>
<pre><code class="language-out">Okay.
You may take test 0 directly.
0-&gt;1
0-&gt;1-&gt;2
You may take test 3 directly.
0-&gt;1-&gt;2-&gt;4
0-&gt;1-&gt;2-&gt;4-&gt;5
0-&gt;1-&gt;2-&gt;6
3-&gt;7
</code></pre>
<p>Sample Input 2:</p>
<pre><code class="language-in">4 5
0 1 1 10
1 2 2 10
3 0 4 10
3 2 5 10
2 0 3 10
2
3 1
</code></pre>
<p>Sample Output 2:</p>
<pre><code class="language-out">Impossible.
You may take test 3 directly.
Error.
</code></pre>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数学问题]]></title>
        <id>https://liuxbo.github.io/post/shu-xue-wen-ti/</id>
        <link href="https://liuxbo.github.io/post/shu-xue-wen-ti/">
        </link>
        <updated>2020-05-07T13:15:56.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>求最大公约数,(最小公倍数：a和b的最大公约数为d，则a和b的最小公倍数为ab/d)</p>
<pre><code>long long gcd(long long a, long long b) {
     return b == 0 ? abs(a) : gcd(b, a %b);
 }
</code></pre>
</li>
<li>
<p>分数化简</p>
<pre><code>struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
</code></pre>
</li>
<li>
<p>四则运算</p>
<pre><code>fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
</code></pre>
</li>
<li>
<p>分数输出</p>
<pre><code>void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
</code></pre>
</li>
<li>
<p>判断是否为素数</p>
<pre><code>bool isprime(int n) {
	if (n &lt;= 1) return false;
    int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}

</code></pre>
</li>
<li>
<p>建立素数表</p>
<pre><code>
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
</code></pre>
</li>
<li>
<p>大整数运算</p>
<pre><code>struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++刷题常用函数]]></title>
        <id>https://liuxbo.github.io/post/cshua-ti-chang-yong-han-shu/</id>
        <link href="https://liuxbo.github.io/post/cshua-ti-chang-yong-han-shu/">
        </link>
        <updated>2020-05-07T13:13:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><code>math.h</code>头文件函数</p>
<p><code>fabs(double x)</code>  取绝对值 ，</p>
<p><code>floor(double x)</code>和<code>ceil(double x)</code> ，分别为向上取整和向下取整，返回double型</p>
<p><code>pow(double r,double p)</code> 用于返回r^p</p>
<p><code>sqrt(double x)</code> ,返回算数平方根</p>
<p><code>log(double x)</code> ,返回以自然对数为底的对数，用换底公式求具体对数</p>
<p><code>sin(double x)</code> <code>cos(double x)</code> <code>tan(double x)</code></p>
<p><code>asin(double x)</code> <code>acos(double x)</code> <code>atan(double x)</code></p>
<p><code>round(double x)</code> 将x四舍五入，返回为double型</p>
</li>
<li>
<p><code>algorithm</code>头文件下的函数，加<code>using namespace std;</code></p>
<p><code>max(x,y)</code> <code>min(x,y)</code>  <code>abs(x)</code> 返回x的绝对值，x必须为整数</p>
<p><code>swap(x,y)</code></p>
<p><code>reverse(it,it2)</code> <code>reverse(a,a+4)</code>  ,将数组元素反转</p>
<p><code>next_permutation(a,a+...)</code> ,给出一个序列在全排列中的下一个序列，该函数在到达全排列的最后一个时会返回false</p>
<p><code>fill(a,a+4,233)</code> ,赋相同值，对于<code>G[maxn] [maxn]</code>二维数组<code>fill(G[0],G[0]+maxn*maxn,INF);</code></p>
<p><code>sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填)）</code>,无比较函数，默认递增排序。</p>
<p><code>sort(a, a+n, greater());</code>  从大到小排序(要用<code>iostream</code>头文件)</p>
<p><code>lower_bound(first,last,val)</code>  <code>upper_bound(first,last,val)</code> ,用于有序数组或容器，前者用来寻找[first,last)范围内第一个值大于等于val的元素的位置，后者寻找第一个值大于val的元素位置.若是数组，这两个函数返回的是地址，如<code>int* right=upper_bound(num, num+n, k)</code>，返回num数组中第一个大于k的元素所在地址，其下标=<code>right-num</code></p>
<p><code>max_element(a, a+len)</code>返回序列中最大元素地址（迭代器）,可用其减去数组首地址(即数组名)获取其下标,若要获取该元素值，直接在前面加一个*,表示取地址即可</p>
<p><code>min_element(begin, end)</code> 返回序列中最小元素地址</p>
</li>
<li>
<p><code>string.h</code> 头文件(<code>cstring</code>头文件)</p>
<p><code>memset(数组名,-1或0,sizeof(数组名))</code></p>
<p><code>strlen(字符数组)</code> 得到字符数组中第一个\0前的字符个数</p>
<p><code>strcmp(字符数组1，字符数组2)</code>返回两个字符串大小比较结果，按字典序。字符数组1&lt;2 ,返回负整数;1=2，返回0;1&gt;2，返回正整数</p>
<p><code>strcpy(字符数组1，字符数组2)</code>，把字符数组2复制给字符数组1，包括\0</p>
<p><code>strcat(字符数组1，字符数组2)</code> ,把2接在1后面</p>
</li>
<li>
<p><code>cctype</code>头文件</p>
<p>1.不仅仅能判断字⺟，还能判断数字、⼩写字⺟、⼤写字⺟等</p>
<p><code>isalpha</code>字⺟（包括⼤写、⼩写）</p>
<p><code>islower</code> （⼩写字⺟）</p>
<p><code>isupper</code>（⼤写字⺟）</p>
<p><code>isalnum</code> （字⺟⼤写⼩写+数字）</p>
<p><code>isblank</code>（space和 \t ）</p>
<p><code>isspace</code>（ space 、 \t 、 \r 、 \n ）</p>
<p><code>isdigit</code>(数字)</p>
<p>2 .<code>tolower (char c)</code>和 <code>toupper(char c)</code> 将某个字符转为⼩写或⼤写</p>
<ul>
<li>使⽤ <code>stoi()</code> 、 <code>stod()</code>  可以将字符串 string 转化为对应的 int 型、 double 型变量</li>
</ul>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//输出123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//输出123.44
 return 0;
}
</code></pre>
</li>
</ul>
<p>3.<code>stoi</code>如果遇到的是⾮法输⼊（⽐如<code>stoi(&quot;123.4&quot;)</code>，123.4不是⼀个int型变量）： 1.会⾃动截取最前⾯的     数字，直到遇到不是数字为⽌ (所以说如果是浮点型，会截取前⾯的整数部分) 2.如果最前⾯不是数字，会运⾏时发⽣错误</p>
<p><code>stod</code>如果是⾮法输⼊： 1.会⾃动截取最前⾯的浮点数，直到遇到不满⾜浮点数为⽌ 2.如果最前⾯不是数字或者⼩数点，会运⾏时发⽣错误 3.如果最前⾯是⼩数点，会⾃动转化后在前⾯补0</p>
<p>不仅有<code>stoi</code>、<code>stod</code>两种，相应的还有：</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
<ul>
<li>
<p><code>to_string()</code>将数值转化为字符串。返回对应的字符串。头文件同样为<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  如果想⽤<code>printf</code>输出string，需要加⼀ 个<code>.c_str()</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串相关]]></title>
        <id>https://liuxbo.github.io/post/zi-fu-chuan-xiang-guan/</id>
        <link href="https://liuxbo.github.io/post/zi-fu-chuan-xiang-guan/">
        </link>
        <updated>2020-05-07T11:31:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><code>scanf (&quot;%s&quot;)</code>识别空格作为字符串结尾</p>
<p><code>getchar</code>  <code>putchar</code> 用来输入输出单个字符</p>
<p><code>gets</code> <code>puts</code> 用来输入输出一行字符串，<code>gets</code> 识别换行符\n作为输入结束  ，gets现在已经不支持了</p>
</li>
<li>
<p><code>cin</code> 读入字符串时，以空格为分隔符，如果想读入一整行字符串，用<code>getline(cin,s)</code>，注意前面如果输入数字n，一定要注意<code>scanf(&quot;%d\n&quot;,&amp;n);</code> 这样写，防止getline读入错误</p>
</li>
<li>
<p>判断两个字符串是否一样时可以用<code>strcmp()==0</code>，该函数其中一个参数可以为字符数组的名称</p>
</li>
<li>
<p>使⽤ <code>stoi()</code> 、 <code>stod()</code>  可以将字符串 string 转化为对应的 int 型、 double 型变量</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//输出123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//输出123.44
 return 0;
}
</code></pre>
<p><code>stoi</code>如果遇到的是⾮法输⼊（⽐如<code>stoi(&quot;123.4&quot;)</code>，123.4不是⼀个int型变量）： 1.会⾃动截取最前⾯的     数字，直到遇到不是数字为⽌ (所以说如果是浮点型，会截取前⾯的整数部分) 2.如果最前⾯不是数字，会运⾏时发⽣错误</p>
<p><code>stod</code>如果是⾮法输⼊： 1.会⾃动截取最前⾯的浮点数，直到遇到不满⾜浮点数为⽌ 2.如果最前⾯不是数字或者⼩数点，会运⾏时发⽣错误 3.如果最前⾯是⼩数点，会⾃动转化后在前⾯补0</p>
<p>不仅有<code>stoi</code>、<code>stod</code>两种，相应的还有：</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
</li>
<li>
<p><code>to_string()</code>将数值转化为字符串。返回对应的字符串。头文件同样为<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  如果想⽤<code>printf</code>输出string，需要加⼀ 个<code>.c_str()</code></p>
</li>
<li>
<p>字符串形式的两个数字相加</p>
<pre><code>string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[疫情]]></title>
        <id>https://liuxbo.github.io/post/yi-qing/</id>
        <link href="https://liuxbo.github.io/post/yi-qing/">
        </link>
        <updated>2020-05-06T13:24:14.000Z</updated>
        <content type="html"><![CDATA[<p>规划已久的学习计划被一场突如其来的疫情打乱。起初大家不以为意，没想到后来传播速度如此之快，到现在发展到中国境外许多国家也出现了大量确诊病例...<br>
​ 奋斗在一线的医务人员、公安民警等各方面力量日日夜夜为打赢这场战斗而坚守，自发请战，医生护士们剪去长发，穿着密不透风的防护服连续长时间工作，汗如雨下，感谢这些美丽的女汉子们。每天都有英雄倒在防疫一线，令人悲痛不已， 同样每天也有患者走出医院，重获健康，让我们看到这场战役的希望。在此对奋斗在一线的人们致以崇高的敬意。<br>
​ 一方有难，八方支援，国难当头，我们更多地看到了人性的真实，有贪生怕死、临阵逃跑的某些官员，有无私奉献，无偿提供帮助的外卖小哥、私家车司机、理发师、酒店老板，有向医务人员吐口水、不戴口罩、骂骂咧咧的无知群众，有及时捐款援助的企业家、明星，有坚守岗位、不幸离世的医生护士、民警辅警、村官干部...... 。2月7日凌晨，湖北武汉市眼科李文亮医生去世，悲痛难以言表。当时同胡明医生一起来支援前线的战友如今却躺在ICU，多么令人心酸......，希望大家都能平安的看到疫情结束的那一天。<br>
​ 宅在家的我们该怎样充实地度过呢。大家有的厨艺见长，有的可以在家好好陪陪亲人，有的趁此机会专心学习，比如我，学会了和面、包饺子、烙饼、做凉皮、蒸蛋糕😂等好多技能，并且可以在家陪伴父母这么长时间，也是不错的一段时光。安逸归安逸，身在大三的我们也万不能停下前进的脚步，前几日教育部一位专家说的话我认为很有道理，话说的少了，思考的就多了，这是难得的在浮躁喧哗中突然获取平静的日子，我们可以停下脚步，思考并规划一下自己的奋斗计划，多学知识，多掌握些技能，所谓技多不压身，准备四六级、考研、面试、出国等。<br>
​ 静待花开。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PAT考试大纲]]></title>
        <id>https://liuxbo.github.io/post/pat-kao-shi-da-gang/</id>
        <link href="https://liuxbo.github.io/post/pat-kao-shi-da-gang/">
        </link>
        <updated>2020-05-06T13:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>考试大纲<br>
乙级</p>
<p>考生应具备以下基本能力：</p>
<ol>
<li>基本的C/C++的代码设计能力，以及相关开发环境的基本调试技巧；</li>
<li>理解并掌握最基本的数据存储结构，即：数组、链表；</li>
<li>理解并熟练编程实现与基本数据结构相关的基础算法，包括递归、排序、查找等；</li>
<li>能够分析算法的时间复杂度、空间复杂度和算法稳定性；</li>
<li>具备问题抽象和建模的初步能力，并能够用所学方法解决实际问题。</li>
</ol>
<p>甲级（Advanced Level）</p>
<p>在达到乙级要求的基础上，还要求：</p>
<ol>
<li>具有充分的英文阅读理解能力；</li>
<li>理解并掌握基础数据结构，包括：线性表、树、图；</li>
<li>理解并熟练编程实现经典高级算法，包括哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等；</li>
<li>具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解。。</li>
</ol>
<p>顶级（Top Level）</p>
<p>在达到甲级要求的基础上，还要求：<br>
1· 对高级、复杂数据结构掌握其用法并能够熟练使用，如后缀数组、树状数组、线段树、Treap、静态KDTree等；<br>
2· 能够利用经典算法思想解决较难的算法问题，如动态规划、计算几何、图论高级应用（包括最大流/最小割，强连通分支、最近公共祖先、最小生成树、欧拉序列）等，并灵活运用；<br>
3· 能够解决复杂的模拟问题，编写并调试代码量较大的程序；<br>
4· 具有缜密的科学思维，考虑问题周全，能够正确应对复杂问题的边界情况。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA的使用]]></title>
        <id>https://liuxbo.github.io/post/idea-de-shi-yong/</id>
        <link href="https://liuxbo.github.io/post/idea-de-shi-yong/">
        </link>
        <updated>2020-05-06T13:22:10.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>构成</p>
<p>文件从大到小依次是project-&gt;module-&gt;package，</p>
</li>
</ul>
<p>​       自己的代码放在src文件下</p>
<p>​       package的命名一般由数字、小数点 、小写字母构成(例如 cn.itcast.day04.demo01 每个小数点前都是一个文</p>
<p>​       件夹，包含小数点后的文件，是一组层级文件)</p>
<ul>
<li>设置和操作</li>
</ul>
<p>​       导入一个模块：file-&gt;project Structure-&gt;import module</p>
<p>​       settings-&gt;keymap-&gt;Mainmenu-&gt;code-&gt;completion-&gt;basic(将其改为Alt+/) ，用于代码提示快捷输入。</p>
<ul>
<li>
<p>常用快捷键</p>
<p><code>Alt+/</code>，快捷输入 ； <code>Alt+Enter</code>，导入包，自动修正代码； <code>Ctrl+Y</code> 删除光标所在行；</p>
<p><code>Ctrl+D</code> 复制光标所在行的内容，插入光标位置下面 ；  <code>Ctrl+Alt+L</code> 格式化代码 ；</p>
<p><code>Ctrl+/</code>单行注释 ； <code>Ctrl+Shift+/</code>选中代码注释，多行注释，再按取消注释 ；</p>
<p><code>Alt+Ins</code>自动生成代码，toString，get，set等方法 ；<code>Alt+Shift+上下箭头</code> 移动当前代码行</p>
<p><code>n.fori</code> 快速生成n次循环for语句</p>
<p>psvm快捷生成<code>public static void main(String[], args)</code></p>
<p>sout快速输出</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PAT题解]]></title>
        <id>https://liuxbo.github.io/post/pat-ti-jie/</id>
        <link href="https://liuxbo.github.io/post/pat-ti-jie/">
        </link>
        <updated>2020-05-06T13:21:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="a100120-两数相加">A1001(20  两数相加)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	int a,b;
	cin&gt;&gt;a&gt;&gt;b;
	string s=to_string(a+b);
	int len=s.length();
	for(int i=0;i&lt;len;i++){
		cout&lt;&lt;s[i];
		if(s[i]=='-') continue;
		if((i+1)%3==len%3&amp;&amp;i!=len-1) cout&lt;&lt;&quot;,&quot;;
	}
	return 0;
}
</code></pre>
<h3 id="a1002多项式求和">A1002(多项式求和)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=1001;
int count1,count2;
double coe[maxn]={},a;
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
	while(count1--){
		int i;
	    scanf(&quot;%d%lf&quot;,&amp;i,&amp;a);
		coe[i]=coe[i]+a;
	}
	scanf(&quot;%d&quot;,&amp;count2);
	while(count2--){
        int k;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		coe[k]=coe[k]+a;
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0) printf(&quot; %d %.1f&quot;,k,coe[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a100325-dijkstra-点权-边权">A1003(25 Dijkstra、点权、边权)</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=510;
const int INF=0x7fffffff;
int n,m,c1,c2,weight[maxn],g[maxn][maxn],d[maxn],w[maxn],num[maxn]={0};
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(vis,vis+maxn,false);
	fill(w,w+maxn,0);
	d[s]=0;
	num[s]=1;
	w[s]=weight[s];
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int j=0;j&lt;n;j++){
			if(g[u][j]!=INF&amp;&amp;vis[j]==false){
				if(d[u]+g[u][j]&lt;d[j]){
					d[j]=d[u]+g[u][j];
					num[j]=num[u];
				    w[j]=w[u]+weight[j];
				}else if(d[u]+g[u][j]==d[j]){
					num[j]+=num[u];
					if(w[u]+weight[j]&gt;w[j]) w[j]=w[u]+weight[j];
				}
			}
		}
	}
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i];
	fill(g[0],g[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int v1,v2,t;
		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;t;
		g[v1][v2]=g[v2][v1]=t;
	}
	dijkst(c1);
	printf(&quot;%d %d&quot;,num[c2],w[c2]);
	return 0;
}
</code></pre>
<h3 id="a1004">A1004</h3>
<pre><code>1.DFS法
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		level[depth]++;
		if(depth&gt;maxdepth)	maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		while(k--){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,0);
	for(int i=0;i&lt;=maxdepth;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,level[i]);
	}
	return 0;
}

2.BFS法
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int hashtable[maxn] = { 0 };
vector&lt;int&gt; child[maxn];
int n, m, level[maxn] = { 0 },maxlevel=0;
void BFS() {
	level[1] = 1;
	queue&lt;int&gt; q;
	q.push(1);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		if (child[now].size() == 0) {
			hashtable[level[now]]++;
			maxlevel = max(maxlevel, level[now]);
		}
		for (int i = 0; i &lt; child[now].size(); i++) {
			level[child[now][i]] = level[now] + 1;
			q.push(child[now][i]);
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int father,num,temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father, &amp;num);
		while (num--) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[father].push_back(temp);
		}
	}
	BFS();
	for (int i = 1; i &lt;= maxlevel; i++) {
		printf(&quot;%d&quot;, hashtable[i]);
		if (i &lt; maxlevel) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a100520-字符串">A1005(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n,spell[10]={&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;};
	cin&gt;&gt;n;
	int sum=0;
	for(int i=0;i&lt;n.size();i++) sum+=(n[i]-'0');
	string ans=to_string(sum);
	cout&lt;&lt;spell[ans[0]-'0'];
	for(int i=1;i&lt;ans.size();i++) cout&lt;&lt;&quot; &quot;&lt;&lt;spell[ans[i]-'0'];
	return 0;
}
</code></pre>
<h3 id="a1006">A1006</h3>
<pre><code>#include&lt;cstdio&gt; 

struct person {
	char id[16];
	int hh, mm, ss;
}temp,first,last;
bool great(person node1, person node2) {
	if (node1.hh != node2.hh) return node1.hh &gt; node2.hh;
	if (node2.mm != node2.mm) return node1.mm &gt; node2.mm;
	return node1.ss &gt; node2.ss;
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	first.hh = 24, first.mm = 60, first.ss = 60;
	last.hh = 0, last.mm = 0, last.ss = 0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %d:%d:%d&quot;, temp.id, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, first) == false)  first = temp;
		scanf(&quot;%d:%d:%d&quot;, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, last))   last = temp;
	}
	printf(&quot;%s %s&quot;, first.id, last.id);
	return 0;
}
</code></pre>
<h3 id="a1007">A1007</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
	dp[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
<h3 id="a100820-水题">A1008(20 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,ans=0;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1,0);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;v[i];
		if(v[i]&gt;v[i-1]) ans+=(v[i]-v[i-1])*6;
		else ans+=(v[i-1]-v[i])*4;
		ans+=5;
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1009-多项式相乘">A1009 多项式相乘</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=2001;
int count1,count2;
struct poly{
	int exp;
	double coef;
}coe[1001];
double result[maxn];
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
for(int i =0;i&lt;count1;i++){
	scanf(&quot;%d%lf&quot;,&amp;coe[i].exp,&amp;coe[i].coef);
    }
	scanf(&quot;%d&quot;,&amp;count2);
for(int i=0;i&lt;count2;i++){
	int k;
	double a;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		for(int i=0;i&lt;count1;i++){
			result[k+coe[i].exp]+=(a*coe[i].coef);
		}
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0) printf(&quot; %d %.1f&quot;,k,result[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a101025-二分">A1010(25 二分)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
long long convert(string n,long long radix){
	long long sum=0,index=0,temp;
	for(auto it=n.rbegin();it!=n.rend();it++){
		temp=isdigit(*it)? (*it)-'0' : (*it)-'a'+10;
		sum+=temp*pow(radix,index++);
	}
	return sum;
}
long long findradix(string n,long long num){
	char it=*max_element(n.begin(),n.end());
	long long low=(isdigit(it)? (it)-'0' : (it)-'a'+10)+1;
	long long high=max(low,num);
	while(low&lt;=high){
		long long mid=(low+high)/2;
		long long temp=convert(n,mid);
		if(temp&lt;0||temp&gt;num) high=mid-1;//小于0的情况是进制太大导致溢出 
		else if(temp==num) return mid;
		else low=mid+1;
	}
	return -1;
}
int main(){
	string n1,n2;
	long long tag,radix,ans;
	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;tag&gt;&gt;radix;
	ans=tag==1?findradix(n2,convert(n1,radix)) : findradix(n1,convert(n2,radix));
	if(ans==-1) cout&lt;&lt;&quot;Impossible&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1011">A1011</h3>
<pre><code>#include&lt;cstdio&gt; 
char s[4] = &quot;WTL&quot;;
double a,res=1;
int main() {
	for (int i = 0; i &lt; 3; i++) {
		int imax;
		double temp = 0;
		for (int i = 0; i &lt; 3; i++) {
			scanf_s(&quot;%lf&quot;, &amp;a);
			if (a &gt; temp) {
				temp = a;
				imax = i;
			}
		}
		res *= temp;
		printf(&quot;%c &quot;, s[imax]);
	}
	printf(&quot;%.2f&quot;, (res * 0.65 - 1) * 2);
	return 0;
}
</code></pre>
<h3 id="a101225-条件排序">A1012(25 条件排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
struct node{
	int id;
	int score[4];
}stu[2000];
int now,rk[1000000][4];
bool cmp(node a,node b){
	return a.score[now]&gt;b.score[now];
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	map&lt;int,bool&gt; mp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;stu[i].id,&amp;stu[i].score[1],&amp;stu[i].score[2],&amp;stu[i].score[3]);
		stu[i].score[0]=(int)((stu[i].score[1]+stu[i].score[2]+stu[i].score[3])*1.0/3+0.5);
		mp[stu[i].id]=true;
	}
	for(now=0;now&lt;=3;now++){
		sort(stu,stu+n,cmp);
		rk[stu[0].id][now]=1;
		for(int i=1;i&lt;n;i++){
			if(stu[i].score[now]==stu[i-1].score[now]) rk[stu[i].id][now]=rk[stu[i-1].id][now];
			else rk[stu[i].id][now]=i+1;
		}
	}
	char course[4]={'A','C','M','E'};
	for(int i=0;i&lt;m;i++){
		int query,bestrank=9999,index=0;
		scanf(&quot;%d&quot;,&amp;query);
		if(mp.count(query)==0){
			printf(&quot;N/A\n&quot;);
			continue;
		}
		for(int j=0;j&lt;4;j++){
			if(rk[query][j]&lt;bestrank){
				bestrank=rk[query][j];
				index=j;
			}
		}
		printf(&quot;%d %c\n&quot;,rk[query][index],course[index]);
	}
	return 0;
}
</code></pre>
<h3 id="a101325-图的dfs遍历计算连通块个数">A1013(25 图的dfs遍历，计算连通块个数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int n,m,k,G[maxn][maxn],cnt=0;
bool vis[maxn];
void dfs(int v){
	vis[v]=true;
	for(int i=1;i&lt;=n;i++){
		if(G[v][i]==1&amp;&amp;vis[i]==false) dfs(i);
	}
}
int main(){
	int a,b;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		G[a][b]=G[b][a]=1;
	}
	while(k--){
		int cnt=0;
		fill(vis,vis+maxn,false);
		scanf(&quot;%d&quot;,&amp;a);
		vis[a]=true;
		for(int i=1;i&lt;=n;i++){
			if(vis[i]==false){
				dfs(i);
				cnt++;
			}
		}
		printf(&quot;%d\n&quot;,cnt-1);//需要添加的路径为连通块个数减1 
	}
	return 0;
}
</code></pre>
<h3 id="a101430-模拟-难题">A1014(30 模拟  难题)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node {
	int poptime, endtime;
	queue&lt;int&gt; q;
};
int main() {
	int n, m, k, Q, index = 1, query;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;Q);
	vector&lt;int&gt; time(k + 1), ans(k + 1);
	for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;time[i]);
	vector&lt;node&gt;window(n + 1);
	vector&lt;bool&gt;sorry(k + 1, false);
	for (int i = 1; i &lt;= m; i++) {
		for (int j = 1; j &lt;= n; j++) {
			if (index &lt;= k) {
				window[j].q.push(time[index]);
				if (window[j].endtime &gt;= 540) sorry[index] = true;
				window[j].endtime += time[index];
				if (i == 1) window[j].poptime = window[j].endtime;
				ans[index] = window[j].endtime;
				index++;
			}
		}
	}
	while (index &lt;= k) {
		int minpoptime = window[1].poptime, tempwindow = 1;
		for (int i = 2; i &lt;= n; i++) {
			if (window[i].poptime &lt; minpoptime) {
				minpoptime = window[i].poptime;
				tempwindow = i;
			}
		}
		window[tempwindow].q.pop();
		window[tempwindow].poptime += window[tempwindow].q.front();
		window[tempwindow].q.push(time[index]);
		if (window[tempwindow].endtime &gt;= 540) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		ans[index] = window[tempwindow].endtime;
		index++;
	}
	while (Q--) {
		scanf(&quot;%d&quot;, &amp;query);
		if (sorry[query] == true) printf(&quot;Sorry\n&quot;);
		else printf(&quot;%02d:%02d\n&quot;, (ans[query] + 480) / 60, (ans[query] + 480) % 60);
	}
	return 0;
}
</code></pre>
<h3 id="a101520-进制转化与素数判断">A1015(20 进制转化与素数判断)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int change(int n,int b){
	vector&lt;int&gt; v;
	int ans=0;
	while(n!=0){
		v.push_back(n%b);
		n/=b;
	}
	for(int i=v.size()-1;i&gt;=0;i--) ans+=v[i]*pow(b,v.size()-1-i);
	return ans;
}
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int n,b;
	while(1){
		scanf(&quot;%d&quot;,&amp;n);
		if(n&lt;0) return 0;
		scanf(&quot;%d&quot;,&amp;b);
		if(isprime(n)&amp;&amp;isprime(change(n,b))) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
}
</code></pre>
<h3 id="a101625-排序-处理多条通话时间记录">A1016(25 排序 处理多条通话时间记录)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt; 
using namespace std;
struct node{
	string name;
	int status,time,month,day,hour,minute;
};
bool cmp(node a,node b){
	return a.name!=b.name? a.name&lt;b.name : a.time&lt;b.time;
}
double billfromzero(node a,int *rate){
	double total=a.minute*rate[a.hour]+a.day*60*rate[24];
	for(int i=0;i&lt;a.hour;i++) total+=60*rate[i];
	return total/100.0;
}
 int main(){
 	int n,rate[25]={0};
 	for(int i=0;i&lt;24;i++){
 		scanf(&quot;%d&quot;,&amp;rate[i]);
 		rate[24]+=rate[i];
	 }
	 cin&gt;&gt;n;
	 vector&lt;node&gt; v(n);
	 for(int i=0;i&lt;n;i++){
	 	cin&gt;&gt;v[i].name;
	 	scanf(&quot;%d:%d:%d:%d&quot;,&amp;v[i].month,&amp;v[i].day,&amp;v[i].hour,&amp;v[i].minute);
	 	v[i].time=v[i].day*24*60+v[i].hour*60+v[i].minute;
	 	string temp;
	 	cin&gt;&gt;temp;
	 	v[i].status=(temp==&quot;on-line&quot;)? 1 : 0 ;
	 } 
	 sort(v.begin(),v.end(),cmp);
	 map&lt;string,vector&lt;node&gt; &gt;mp;
	 for(int i=1;i&lt;n;i++){
	 	if(v[i].name==v[i-1].name&amp;&amp;v[i-1].status==1&amp;&amp;v[i].status==0){
	 		mp[v[i-1].name].push_back(v[i-1]);
	 		mp[v[i].name].push_back(v[i]);
		 }
	 }
	 for(auto it:mp){
	 	cout&lt;&lt; it.first;
	 	vector&lt;node&gt; temp=it.second;
	 	printf(&quot; %02d\n&quot;,temp[0].month);
	 	double total=0.0;
	 	for(int i=1;i&lt;temp.size();i+=2){
	 		double t=billfromzero(temp[i],rate)-billfromzero(temp[i-1],rate);
	 		printf(&quot;%02d:%02d:%02d&quot;,temp[i-1].day,temp[i-1].hour,temp[i-1].minute);
			printf(&quot; %02d:%02d:%02d %d&quot;,temp[i].day,temp[i].hour,temp[i].minute,temp[i].time-temp[i-1].time);
			printf(&quot; $%.2f\n&quot;,t);
			total+=t;
		 }
		 printf(&quot;Total amount: $%.2f\n&quot;,total);
	 } 
	 return 0;
 }
</code></pre>
<h3 id="a1017-25-模拟-时间处理-排序">A1017 （25 模拟 ，时间处理、排序、）</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int cometime,servetime;
}; 
bool cmp(node a,node b){
	return a.cometime&lt;b.cometime;
}
int main(){
	int n,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	double ans=0.0;
	node temp;
	vector&lt;node&gt; v;
	for(int i=0;i&lt;n;i++){
		int hh,mm,ss,serve;
		scanf(&quot;%d:%d:%d %d&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;serve);
		temp.cometime=hh*3600+mm*60+ss;
		temp.servetime=serve*60;
		if(temp.cometime&gt;61200) continue;
		v.push_back(temp);
	}
	sort(v.begin(),v.end(),cmp);
	vector&lt;int&gt; window(k,28800);
	for(int i=0;i&lt;v.size();i++){
		int minend=window[0],index=0;
		for(int j=1;j&lt;k;j++){
			if(window[j]&lt;minend){
				minend=window[j];
				index=j;
			}
		}
		if(v[i].cometime&gt;window[index]) window[index]=v[i].cometime+v[i].servetime;
		else if(v[i].cometime&lt;=window[index]){
			ans+=(window[index]-v[i].cometime);
			window[index]+=v[i].servetime; 
		}
	}
	if(v.size()==0) printf(&quot;0.0&quot;);
	else printf(&quot;%.1f&quot;,(ans/60.0)/v.size());
	return 0;
}
</code></pre>
<h3 id="a101830-dijkstdfs">A1018(30 dijkst+dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=520;
const int INF=0x7fffffff;
int cmax,n,sp,m,minneed=INF,minremain=INF;
int weight[maxn],G[maxn][maxn],d[maxn];
bool vis[maxn]={false};
vector&lt;int&gt;pre[maxn];
vector&lt;int&gt;temp,path;
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;=n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;=n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int j=0;j&lt;=n;j++){
			if(G[u][j]!=INF&amp;&amp;vis[j]==false){
				if(G[u][j]+d[u]&lt;d[j]){
					d[j]=G[u][j]+d[u];
					pre[j].clear();
					pre[j].push_back(u);
				}else if(G[u][j]+d[u]==d[j]) pre[j].push_back(u);
			}
		}
	}
}
void dfs(int s){
	if(s==0){
		temp.push_back(s);//注意 
		int need=0,remain=0;
		for(int i=temp.size()-1;i&gt;=0;i--){
			if(weight[temp[i]]&gt;0) remain+=weight[temp[i]];
			if(weight[temp[i]]&lt;0){
				if(abs(weight[temp[i]])&gt;remain){
					need+=abs(weight[temp[i]])-remain;
				    remain=0;
				}else remain-=abs(weight[temp[i]]);
			}
		}
		if(need&lt;minneed){
			minneed=need;
			minremain=remain;//注意
			path=temp;
		}else if(need==minneed&amp;&amp;remain&lt;minremain){
			minremain=remain;
			path=temp;
		}
		temp.pop_back();//注意
		return;
	}
	temp.push_back(s);
	for(int i=0;i&lt;pre[s].size();i++) dfs(pre[s][i]);
	temp.pop_back();
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;cmax,&amp;n,&amp;sp,&amp;m);
	for(int i=1;i&lt;=n;i++) {
		scanf(&quot;%d&quot;,&amp;weight[i]);
		weight[i]-=cmax/2;
	}
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int a,b,c;
		scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
		G[a][b]=G[b][a]=c;
	}
	dijkst(0);
	dfs(sp);
	printf(&quot;%d &quot;,minneed);
	for(int i=path.size()-1;i&gt;=0;i--){
		printf(&quot;%d&quot;,path[i]);
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	printf(&quot; %d&quot;,minremain);
	return 0;
}
</code></pre>
<h3 id="a1019">A1019</h3>
<pre><code>#include&lt;cstdio&gt;
 int main(){
 	int n,b,ans[50],index=0;
 	scanf(&quot;%d%d&quot;,&amp;n,&amp;b);
 	while(n!=0){
 		ans[index++]=n%b;
 		n/=b;
	 }
	 bool flag=true;
	 for(int i=0;i&lt;=index/2;i++){
	 	if(ans[i]!=ans[index-i-1]) flag=false;
	 }
	 if(flag==false) printf(&quot;No\n&quot;);
	 else printf(&quot;Yes\n&quot;);
	 for(int i=index-1;i&gt;=0;i--){
	 	if(i!=index-1) printf(&quot; &quot;);
	 	printf(&quot;%d&quot;,ans[i]);
	 }
	 return 0; 
 }
</code></pre>
<h3 id="a102025-后序中序建树输出层序">A1020(25 后序+中序建树，输出层序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=31;
struct node{
	int data;
	node *left,*right;
};
int post[maxn],in[maxn],n,num=0;
node * create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;data=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root;
}
void layerorder(node *root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		node* Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top-&gt;data);
		num++;
		if(num&lt;n) printf(&quot; &quot;);
		if(Top-&gt;left!=NULL) q.push(Top-&gt;left);
		if(Top-&gt;right!=NULL) q.push(Top-&gt;right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	node*root=create(0,n-1,0,n-1);
	layerorder(root);
	return 0;
}
</code></pre>
<h3 id="a102125-找出图中使深度最深的结点首先判断是否能看成树">A1021(25 找出图中使深度最深的结点(首先判断是否能看成树))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
bool vis[10010]; 
int n,maxheight=-1;
vector&lt;int&gt; ans,G[10010];
void dfs(int index,int height){
	vis[index]=true;
	if(height&gt;maxheight){
		maxheight=height;
		ans.clear();
		ans.push_back(index);
	}else if(height==maxheight) ans.push_back(index);
	for(int i=0;i&lt;G[index].size();i++){
		if(vis[G[index][i]]==false) dfs(G[index][i],height+1); 
	} 
}
int main(){
	int v1,v2,cnt=0,st;
	set&lt;int&gt; res;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n-1;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		G[v1].push_back(v2);
		G[v2].push_back(v1);
	} 
	fill(vis,vis+10010,false);
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			dfs(i,0);
			if(i==1){
				if(ans.size()!=0) st=ans[0];
				for(int j=0;j&lt;ans.size();j++) res.insert(ans[j]);
			} 
			cnt++;
		}
	}
	if(cnt&gt;1) printf(&quot;Error: %d components&quot;,cnt);
	else{
		ans.clear(); 
		fill(vis,vis+10010,false);
		maxheight=-1;
		dfs(st,0);
		for(int i=0;i&lt;ans.size();i++) res.insert(ans[i]);
		for(auto it=res.begin();it!=res.end();it++) printf(&quot;%d\n&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1022">A1022</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string, set&lt;int&gt; &gt; mptitle, mpautor, mpkey, mppublish, mpyear;
void query(map&lt;string, set&lt;int&gt; &gt;&amp; mp, string&amp; str) {
	if (mp.count(str) == 0) cout &lt;&lt; &quot;Not Found\n&quot;;
	else {
		for (auto it = mp[str].begin(); it != mp[str].end(); it++) {
			printf(&quot;%07d\n&quot;, *it);
		}
	}
}
int main() {
	int n,m,id;
	cin &gt;&gt; n;
	string title, autor, keyword, publish, year;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		char c = getchar();
		getline(cin, title);
		mptitle[title].insert(id);
		getline(cin, autor);
		mpautor[autor].insert(id);
		while (cin &gt;&gt; keyword) {
			mpkey[keyword].insert(id);
			 c = getchar();
			if (c == '\n') break;
		}
		getline(cin, publish);
		mppublish[publish].insert(id);
		getline(cin, year);
		mpyear[year].insert(id);
	}
	cin &gt;&gt; m;
	while(m--){
		int type;
		string temp;
		scanf(&quot;%d: &quot;, &amp;type);
		getline(cin, temp);
		cout &lt;&lt; type &lt;&lt; &quot;:&quot; &lt;&lt; &quot; &quot; &lt;&lt; temp&lt;&lt;endl;
		if (type == 1) query(mptitle, temp);
		if (type == 2) query(mpautor, temp);
		if (type == 3) query(mpkey, temp);
		if (type == 4) query(mppublish, temp);
		if (type == 5) query(mpyear, temp);
	}
	return 0;
}
</code></pre>
<h3 id="a102320-大整数乘2">A1023(20 大整数乘2)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
bool judge(bign a, bign b) {
	if (a.len != b.len) return false;
	else {
		int count[10] = { 0 };
		for (int i = 0; i &lt; a.len; i++) {
			count[a.d[i]]++;
			count[b.d[i]]--;
		}
		for (int i = 0; i &lt; 10; i++) {
			if (count[i] != 0) {
				return false;
			}
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
}
int main() {
	string str;
	cin &gt;&gt; str;
	bign a, ans;
	a=change(str);
	ans = multi(a, 2);
	if (judge(a, ans)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	print(ans);
	return 0;
}


方法二:
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt; 
using namespace std;
string Double(string s){
	string ans=s;
	int carry=0;
	for(int i=s.size()-1;i&gt;=0;i--){
		ans[i]=(((s[i]-'0')*2+carry)%10)+'0';
		carry=((s[i]-'0')*2+carry)/10;
	}
	if(carry&gt;0) ans=&quot;1&quot;+ans;
	return ans;
}
int main(){
	string s,res;
	map&lt;char,int&gt;mp;
	cin&gt;&gt;s;
	for(int i=0;i&lt;s.size();i++) mp[s[i]]++;
	res=Double(s);
	for(int i=0;i&lt;res.size();i++) mp[res[i]]--;
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second!=0){
			cout&lt;&lt;&quot;No\n&quot;&lt;&lt;res;
			return 0;
		}
	}
	cout&lt;&lt;&quot;Yes\n&quot;&lt;&lt;res;
	return 0;
}
</code></pre>
<h3 id="a102425-大整数反转相加判断回文数">A1024(25 大整数反转相加，判断回文数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
string rev(string s) {
	reverse(s.begin(),s.end());
	return s;
}
string add(string s1,string s2) {
	string ans=s1;
	int carry=0;
	for(int i=ans.size()-1; i&gt;=0; i--) {
		ans[i]=((s1[i]-'0')+(s2[i]-'0')+carry)%10+'0';
		carry=((s1[i]-'0')+(s2[i]-'0')+carry)/10;
	}
	if(carry!=0) ans=&quot;1&quot;+ans;
	return ans;
}
bool judge(string s) {
	for(int i=0; i&lt;s.size()/2; i++) {
		if(s[i]!=s[s.size()-i-1]) return false;
	}
	return true;
}
int main() {
	string s;
	int step;
	cin&gt;&gt;s&gt;&gt;step;
	if(s.size()==1||judge(s)) cout&lt;&lt;s&lt;&lt;endl&lt;&lt;&quot;0&quot;;
	else {
		for(int i=1; i&lt;=step; i++) {
			s=add(s,rev(s));
			if(judge(s)||i==step) {
				cout&lt;&lt;s&lt;&lt;endl&lt;&lt;i;
				break;
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a102525-条件排序">A1025(25 条件排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string id;
	int localid,score,frank,lrank;
};
bool cmp(node a,node b){
	return a.score!=b.score? a.score&gt;b.score : a.id&lt;b.id;
}
int main(){
	int n,k;
	cin&gt;&gt;n;
	vector&lt;node&gt; total;
	for(int j=1;j&lt;=n;j++){
		scanf(&quot;%d&quot;,&amp;k);
		vector&lt;node&gt; v(k);
		for(int i=0;i&lt;k;i++) {
			cin&gt;&gt;v[i].id&gt;&gt;v[i].score;
			v[i].localid=j;
		}
		sort(v.begin(),v.end(),cmp);
		v[0].lrank=1;
		for(int i=1;i&lt;k;i++) {
			if(v[i].score==v[i-1].score) v[i].lrank=v[i-1].lrank;
			else v[i].lrank=i+1;
		}
		for(int i=0;i&lt;k;i++) total.push_back(v[i]);
	}
	sort(total.begin(),total.end(),cmp);
	total[0].frank=1;
	for(int i=1;i&lt;total.size();i++) {
		if(total[i].score==total[i-1].score) total[i].frank=total[i-1].frank;
		else total[i].frank=i+1;
	}
	cout&lt;&lt;total.size()&lt;&lt;endl;
	for(int i=0;i&lt;total.size();i++){
		printf(&quot;%s %d %d %d\n&quot;,total[i].id.c_str(),total[i].frank,total[i].localid,total[i].lrank);
	}
	return 0;
}
</code></pre>
<h3 id="a1027">A1027</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	char c[14]={&quot;0123456789ABC&quot;};
	printf(&quot;#&quot;);
	for(int i=0;i&lt;3;i++){
		int n;
		scanf(&quot;%d&quot;,&amp;n);
		printf(&quot;%c%c&quot;,c[n/13],c[n%13]);
	}
	return 0;
}
</code></pre>
<h3 id="a102825-排序">A1028(25  排序)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	int id,grade;
	string name;
};
bool cmp1(node a,node b){
	return a.id&lt;b.id;
}
bool cmp2(node a,node b){
	return a.name!=b.name? a.name&lt;b.name :a.id&lt;b.id;
}
bool cmp3(node a,node b){
	return a.grade!=b.grade? a.grade&lt;b.grade : a.id&lt;b.id;
}
int main(){
	int n,c;
	cin&gt;&gt;n&gt;&gt;c;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i].id&gt;&gt;v[i].name&gt;&gt;v[i].grade;
	if(c==1) sort(v.begin(),v.end(),cmp1);
	else if(c==2) sort(v.begin(),v.end(),cmp2);
	else if(c==3)sort(v.begin(),v.end(),cmp3);
	for(int i=0;i&lt;n;i++) printf(&quot;%06d %s %d\n&quot;,v[i].id,v[i].name.c_str(),v[i].grade);
	return 0;
}
</code></pre>
<h3 id="a102925-求中位数-twopoints">A1029(25 求中位数 twopoints)</h3>
<pre><code>1.直接暴力
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
int main(){
    int n1,n2;
    long long a[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    int i;
    for( i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for( i=n1;i&lt;n2+n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    sort(a,a+n1+n2);
    printf(&quot;%d&quot;,a[(n1+n2-1)/2]);
    return 0;
}

2.two points

#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
const int INF=(1&lt;&lt;31)-1;
int main(){
    int n1,n2;
    long long a[maxn],b[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    for(int i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for(int i=0;i&lt;n2;i++){
        scanf(&quot;%lld&quot;,&amp;b[i]);
    }
    a[n1]=INF;
    b[n2]=INF;
    int midpos=(n1+n2-1)/2;
    int count=0,j=0,i=0;
    while(count&lt;midpos){
        if(a[i]&lt;b[j]) i++;
        else j++;
        count++;
    }
    if(a[i]&lt;b[j]) printf(&quot;%lld&quot;,a[i]);
    else printf(&quot;%lld&quot;,b[j]);
    return 0;
}
</code></pre>
<h3 id="a103030-dijkst距离最短加花费最少">A1030(30 dijkst,距离最短加花费最少)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=510;
const int INF=0x7fffffff;
int G[maxn][maxn],n,m,st,ed,cost[maxn][maxn],d[maxn],c[maxn],pre[maxn];
bool vis[maxn];
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(c,c+maxn,INF);
	fill(vis,vis+maxn,false);
	d[s]=0;
	c[s]=0;
	for(int i=0;i&lt;n;i++) pre[i]=i;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					d[v]=d[u]+G[u][v];
					c[v]=cost[u][v]+c[u];
					pre[v]=u;
				}else if(d[u]+G[u][v]==d[v]){
					if(c[v]&gt;c[u]+cost[u][v]){
						c[v]=cost[u][v]+c[u];
						pre[v]=u;
					}
				}
			}
		}
	} 
}
void dfs(int ed){
	if(ed==st){
        printf(&quot;%d &quot;,ed);
        return;
    } 
	dfs(pre[ed]);
	printf(&quot;%d &quot;,ed);
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;ed);
	fill(G[0],G[0]+maxn*maxn,INF);
	while(m--){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		scanf(&quot;%d%d&quot;,&amp;G[v1][v2],&amp;cost[v1][v2]);
		G[v2][v1]=G[v1][v2];
		cost[v2][v1]=cost[v1][v2];
	}
	dijkst(st);
	dfs(ed);
	printf(&quot;%d %d&quot;,d[ed],c[ed]);
	return 0;
}
</code></pre>
<h3 id="a1031">A1031</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
int main() {
	char str[100], uu[40][40];
    scanf(&quot;%s&quot;,str); 
	int N = strlen(str);
	int n1=(N+2)/3;
	int n3=(N+2)/3;
	int n2=N-n1-n3+2;
	int pos=0;
    memset(uu,' ',sizeof(uu));
	for(int i=0;i&lt;n1-1;i++){
		uu[i][0]=str[pos++];
	} 
	for(int j=0;j&lt;n2;j++){
		uu[n1-1][j]=str[pos++];
	}
	for(int k=n3-2;k&gt;=0;k--){
		uu[k][n2-1]=str[pos++];
	}
	for(int i=0;i&lt;n1;i++){
		for(int j=0;j&lt;n2;j++){
			printf(&quot;%c&quot;,uu[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a103225-链表-找公共后缀">A1032(25 链表  找公共后缀)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	char data;
	bool flag;
	int next;
}list[maxn];
int main(){
	int address,begin1,begin2,n;
	scanf(&quot;%d%d%d&quot;,&amp;begin1,&amp;begin2,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot; %c %d&quot;,&amp;list[address].data,&amp;list[address].next);
	}
	while(begin1!=-1){
		list[begin1].flag=true;
		begin1=list[begin1].next;
	}
	while(begin2!=-1){
		if(list[begin2].flag==true) {
			printf(&quot;%05d&quot;,begin2);
			return 0;
		}
		begin2=list[begin2].next;
	}
	printf(&quot;-1&quot;);
	return 0;
}
</code></pre>
<h3 id="a1033">A1033</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 510;
const int INF = 1000000000;
struct node{
	double price;
	double distance;
}station[maxn];
bool cmp(node a, node b) {
	return a.distance &lt; b.distance;
}
int main() {
	double cmax, d, davg;
	int n;
	scanf(&quot;%lf%lf%lf%d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%lf%lf&quot;, &amp;station[i].price, &amp;station[i].distance);
	}
	station[n].distance = d;
	station[n].price = 0;
	sort(station, station + n + 1, cmp);
	if (station[0].distance != 0) {
		printf(&quot;The maximum travel distance = 0.00&quot;);
		return 0;
	}
	int now = 0;
	double nowtank = 0, expend = 0,  canrun = cmax * davg;
	while (now &lt; n) {
        int k=-1;
        double minprice=INF;
		for (int i = now + 1; (station[i].distance - station[now].distance) &lt;= canrun &amp;&amp; i &lt;= n; i++) {
			if (station[i].price &lt; minprice) {
				minprice = station[i].price;
				k = i;
				if (minprice &lt; station[now].price) {
					break;
				}
			}
		}
		if (k == -1) break;
		double need = (station[k].distance - station[now].distance) / davg;
		if (station[k].price &lt; station[now].price) {
			if (nowtank &lt; need) {
				expend += (need - nowtank) * station[now].price;
				nowtank = 0;
			}
			else {
				nowtank -= need;
			}
		}
		else {
			expend += (cmax - nowtank) * station[now].price;
			nowtank = cmax - need;
		}
		now = k;
	}
	if (now == n) printf(&quot;%.2f&quot;, expend);
	else printf(&quot;The maximum travel distance = %.2f&quot;, station[now].distance + canrun);
	return 0;
}
</code></pre>
<h3 id="a103430-图的深度遍历-map-连通块-边权和点权">A1034(30 图的深度遍历、map、连通块、边权和点权)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string,int&gt; strtoint;
map&lt;int,string&gt; inttostr;
map&lt;string,int&gt; ans;
bool vis[2020];
int G[2020][2020],weight[2020],n,k,index=1;
int Stringtoint(string s){
	if(strtoint.count(s)==0){
		strtoint[s]=index;
		inttostr[index]=s;
		index++;//同时计数总的结点个数 
	}
	return strtoint[s];
}
void dfs(int id,int &amp;totaltime,int&amp;head,int &amp;num){
	vis[id]=true;
	num++;
	if(weight[id]&gt;weight[head]) head=id;
	for(int i=1;i&lt;index;i++){
		if(G[id][i]!=0){
			totaltime+=G[id][i];
			G[id][i]=G[i][id]=0;
			if(vis[i]==false) dfs(i,totaltime,head,num);
		} 
	}
}
int main(){
	string s1,s2;
	cin&gt;&gt;n&gt;&gt;k;
	int id1,id2,calltime;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;calltime;
		id1=Stringtoint(s1),id2=Stringtoint(s2);
		G[id1][id2]+=calltime;
		G[id2][id1]+=calltime;
		weight[id1]+=calltime;
		weight[id2]+=calltime;
	}
	fill(vis,vis+2020,false);
	for(int i=1;i&lt;index;i++){
		if(vis[i]==false){
			int totaltime=0,head=i,num=0;
			dfs(i,totaltime,head,num);
			if(num&gt;2&amp;&amp;totaltime&gt;k) ans[inttostr[head]]=num;
		}
	}
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(auto it=ans.begin();it!=ans.end();it++){
		cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a103520-字符串">A1035(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;string&gt; v;
	for(int j=0;j&lt;n;j++){
		bool flag=false;
		string name,password,ans;
		cin&gt;&gt;name&gt;&gt;password;
		for(int i=0;i&lt;password.length();i++){
			switch(password[i]){
				case '1':password[i]='@';flag=true;break;
				case '0':password[i]='%';flag=true;break;
				case 'l':password[i]='L';flag=true;break;
				case 'O':password[i]='o';flag=true;break;
			}
		}
		if(flag==true) v.push_back(name+&quot; &quot;+password);
	}
	if(n==1) printf(&quot;There is 1 account and no account is modified\n&quot;);
	else if(v.size()==0) printf(&quot;There are %d accounts and no account is modified\n&quot;,n);
	else{
		printf(&quot;%d\n&quot;,v.size());
		for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1036">A1036</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
struct student {
	char name[11];
	char gender;
	char id[11];
	int score;
}male,female,temp;
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	female.score = -1;
	male.score = 101;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %c %s %d&quot;, temp.name, &amp;temp.gender, temp.id, &amp;temp.score);
		if (temp.gender == 'F') {
			if (temp.score &gt; female.score) {
				female = temp;
			}
		}
		if (temp.gender == 'M') {
			if (temp.score &lt; male.score) {
				male = temp;
			}
		}
	}
	if (female.score == -1) printf(&quot;Absent\n&quot;);
	if (female.score &gt; -1) printf(&quot;%s %s\n&quot;, female.name, female.id);
	if (male.score == 101) printf(&quot;Absent\n&quot;);
	if (male.score &lt;101) printf(&quot;%s %s\n&quot;, male.name, male.id);
	if (female.score == -1 || male.score == 101) printf(&quot;NA&quot;);
	if (female.score &gt; -1 &amp;&amp; male.score &lt; 101) printf(&quot;%d&quot;, female.score - male.score);
	return 0;
}
</code></pre>
<h3 id="a103725-贪心">A1037(25 贪心)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b){return a&gt;b;}
int main(){
 	int nc,np,c,p,ans=0;
 	vector&lt;int&gt;c1,c2,p1,p2;
 	scanf(&quot;%d&quot;,&amp;nc);
 	for(int i=0;i&lt;nc;i++){
 		scanf(&quot;%d&quot;,&amp;c);
 		if(c&gt;=0) c1.push_back(c);
 		else c2.push_back(c);
	 }
	 scanf(&quot;%d&quot;,&amp;np);
	 for(int i=0;i&lt;np;i++){
 		scanf(&quot;%d&quot;,&amp;p);
 		if(p&gt;=0) p1.push_back(p);
 		else p2.push_back(p);
	 }
	 sort(c1.begin(),c1.end(),cmp);
	 sort(p1.begin(),p1.end(),cmp);
	 sort(c2.begin(),c2.end());
	 sort(p2.begin(),p2.end());
	 for(int i=0;i&lt;c1.size()&amp;&amp;i&lt;p1.size();i++)	ans+=c1[i]*p1[i];
	 for(int i=0;i&lt;c2.size()&amp;&amp;i&lt;p2.size();i++)	ans+=c2[i]*p2[i];
	 printf(&quot;%d&quot;,ans);
	 return 0;
}
</code></pre>
<h3 id="a103830-贪心-求最小字符串序列">A1038(30 贪心  求最小字符串序列)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
bool cmp(string &amp;a,string &amp;b){
	return a+b&lt;b+a;
}
int main(){
	int n;
	cin&gt;&gt;n;
	string ans;
	vector&lt;string&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i];
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++) ans+=v[i];
	while(ans[0]=='0') ans.erase(0,1);
	if(ans.size()==0) cout&lt;&lt;&quot;0&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a103925-vector">A1039(25 vector)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=26*26*26*10+10;
int getid(char *name){
	int id=0;
	for(int i=0;i&lt;3;i++) id=26*id+(name[i]-'A');
	id=id*10+(name[3]-'0');
	return id;
}
int main(){
	int n,k,courseid,num;
	char name[4];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	vector&lt;int&gt; v[maxn];
	for(int i=0;i&lt;k;i++){
		scanf(&quot;%d%d&quot;,&amp;courseid,&amp;num);
		for(int j=0;j&lt;num;j++){
			scanf(&quot;%s&quot;,name);
			v[getid(name)].push_back(courseid);
		}
	}
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s&quot;,name);
		printf(&quot;%s %d&quot;,name,v[getid(name)].size());
		sort(v[getid(name)].begin(),v[getid(name)].end());
		for(int j=0;j&lt;v[getid(name)].size();j++) printf(&quot; %d&quot;,v[getid(name)][j]);
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1040">A1040</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a104120-hash">A1041(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	int n,flag[100001]={0},j;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;v[i]);
		flag[v[i]]++;
	}
	for(j=0;j&lt;n;j++){
		if(flag[v[j]]==1) {
			cout&lt;&lt;v[j];
			break;
		}
	}
	if(j==n) cout&lt;&lt;&quot;None&quot;;
	return 0;
}
</code></pre>
<h3 id="a1042">A1042</h3>
<pre><code>#include&lt;cstdio&gt;
const int N = 55;
int main()
{
	char mp[5] = { 'S','H','C','D','J' };
	int start[N], next[N], end[N];
	int times;
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 1; i &lt;= 54; i++) {
		scanf(&quot;%d&quot;, &amp;next[i]);
	}
	for (int i = 1; i &lt;= 54; i++) {
		start[i] = i;
	}
	for (int step = 0; step &lt; times; step++) {
		for (int i = 1; i &lt;= 54; i++) {
			end[next[i]] = start[i];
		}
		for (int i = 1; i &lt;= 54; i++) {
			start[i] = end[i];
		}
	}
	for (int i = 1; i &lt;= 54; i++) {
		if (i != 1) printf(&quot; &quot;);
		start[i]--;
		printf(&quot;%c%d&quot;, mp[start[i] / 13], start[i] % 13+1);
	}
	return 0;
}
</code></pre>
<h3 id="a104325-二叉搜索树的遍历与反转">A1043(25 二叉搜索树的遍历与反转)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node*left,*right;
};
void insert(node*&amp;root,int data){
	if(root==NULL){
		root=new node;
		root-&gt;data=data;
		root-&gt;left=NULL;
		root-&gt;right=NULL;
		return;
	}
	if(root-&gt;data&lt;=data) insert(root-&gt;right,data);
	else if(root-&gt;data&gt;data) insert(root-&gt;left,data);
}
void preorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorder(root-&gt;left,v);
	preorder(root-&gt;right,v);
}
void preorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorderM(root-&gt;right,v);
	preorderM(root-&gt;left,v);
}
void postorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorder(root-&gt;left,v);
	postorder(root-&gt;right,v);
	v.push_back(root-&gt;data);
}
void postorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorderM(root-&gt;right,v);
	postorderM(root-&gt;left,v);
	v.push_back(root-&gt;data);
}
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n),pre,preM,post,postM;
	node*root=NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		insert(root,v[i]);
	}
	preorder(root,pre);
	preorderM(root,preM);
	if(pre==v){
		printf(&quot;YES\n&quot;);
		postorder(root,post);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,post[i]);
		}
	}else if(preM==v){
		printf(&quot;YES\n&quot;);
		postorderM(root,postM);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,postM[i]);
		}
	}else printf(&quot;NO&quot;);
	return 0;
}
</code></pre>
<h3 id="a104425-二分">A1044(25 二分)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; sum,ans;
int n,m;
void func(int i,int &amp;j,int &amp;tempsum){
	int low=i,high=n;
	while(low&lt;high){
		int mid=(low+high)/2;
		if(sum[mid]-sum[i-1]&gt;=m) high=mid;
		else low=mid+1;
	}
	j=high;
	tempsum=sum[j]-sum[i-1];
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	sum.resize(n+1);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
	}
	int minans=sum[n];
	for(int i=1;i&lt;=n;i++){
		int j,tempsum;
		func(i,j,tempsum);
		if(tempsum&gt;minans) continue;
		if(tempsum&gt;=m){
			if(tempsum&lt;minans){
				ans.clear();
				minans=tempsum;
			}
			ans.push_back(i);
			ans.push_back(j);
		}
	}
	for(int i=0;i&lt;ans.size();i+=2)	printf(&quot;%d-%d\n&quot;,ans[i],ans[i+1]);
	return 0;
}
</code></pre>
<h3 id="a1045">A1045</h3>
<pre><code>方法一:最长不下降子序列LIS
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
		ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
方法二:最长公共子序列
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;
    for(int i=0;i&lt;L;i++) dp[0][i]=0;
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
<h3 id="a1046">A1046</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int dis[maxn], A[maxn];
int main() {
	int n,times,left,right,sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		sum += A[i];
        dis[i] = sum;
	}
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 0; i &lt; times; i++) {
		scanf(&quot;%d%d&quot;, &amp;left, &amp;right);
		if (left &gt; right)  swap(left, right);
		int distance = dis[right - 1] - dis[left - 1];
			printf(&quot;%d\n&quot;, min(distance,sum-distance));
	}
	return 0;
}
</code></pre>
<h3 id="a104725-vector">A1047(25 vector)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[40010][5];
vector&lt;int&gt; v[2510];
bool cmp(int a,int b){
	return strcmp(name[a],name[b])&lt;0;
}
int main(){
	int n,k,c,courseid;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s%d&quot;,name[i],&amp;c);
		while(c--){
			scanf(&quot;%d&quot;,&amp;courseid);
			v[courseid].push_back(i);
		}
	}
	for(int i=1;i&lt;=k;i++){
		printf(&quot;%d %d\n&quot;,i,v[i].size());
		sort(v[i].begin(),v[i].end(),cmp);
		for(int j=0;j&lt;v[i].size();j++) printf(&quot;%s\n&quot;,name[v[i][j]]);
	}
	return 0;
}
</code></pre>
<h3 id="a104825">A1048(25 )</h3>
<pre><code>1.哈希散列解法
#include&lt;cstdio&gt;
int main(){
	int n,pay,flag[100010]={0},a[100010];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;pay);
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for(int i=1;i&lt;pay;i++){
		if(flag[i]&gt;0&amp;&amp;flag[pay-i]&gt;0){
			if((i==pay-i&amp;&amp;flag[i]&gt;1)||i!=pay-i){
				printf(&quot;%d %d&quot;,i,pay-i);
			    return 0;
			}
		}
	} 
	printf(&quot;No Solution&quot;);
	return 0;
}


2.二分法解法
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num, num + n);
	int j,i;
	for ( i = 0; i &lt; n; i++) {
		 j = lower_bound(num + i, num +n, m - num[i]) - num;
		if ( (num[j] + num[i] == m&amp;&amp;j!=i)||(num[i]==num[i+1]&amp;&amp;num[i]*2==m)) {
			printf(&quot;%d %d&quot;, num[i], num[j]);
			break;
		}
	}
	if (i &gt;= n) printf(&quot;No Solution&quot;);
	return 0;
}

3.two points
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int a[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	sort(a, a + n);
	int j=n-1,i=0;
    while(i&lt;j){
        if(a[i]+a[j]==m){
            printf(&quot;%d %d&quot;,a[i],a[j]);
            return 0;
        }
        else if(a[i]+a[j]&gt;m) j--;
        else i++;
    }
	printf(&quot;No Solution&quot;);
	return 0;
}
</code></pre>
<h3 id="a104930-数学问题1的个数">A1049(30  数学问题：&quot;1&quot;的个数)</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int main(){
	int n,left=0,right=0,a=1,now=1,ans=0;
	cin&gt;&gt;n;
	while(n/a){
		left=n/(a*10),right=n%a,now=n/a%10;
		if(now==0) ans+=left*a;
		else if(now==1) ans+=left*a+right+1;
		else ans+=(left+1)*a;
		a*=10; 
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a105020-hash">A1050(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	vector&lt;int&gt; v(128,0);
	getline(cin,s1);
	getline(cin,s2);
	for(int i=0;i&lt;s2.length();i++) v[s2[i]]++;
	for(int i=0;i&lt;s1.length();i++){
		if(v[s1[i]]==0) ans+=s1[i];
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a105125-栈">A1051(25 栈)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k);
	while(k--){
		vector&lt;int&gt; v(n+1);
		stack&lt;int&gt; st;
		bool flag=true;
		int current=1;
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
		for(int i=1;i&lt;=n;i++){
			st.push(i);
			if(st.size()&gt;m){
				flag=false;
				break;
			}
			while(!st.empty()&amp;&amp;st.top()==v[current]){
				st.pop();
				current++;
			}
		}
		if(current!=n+1) flag=false;
		if(flag) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a105225-链表按key排序">A1052(25 链表按key排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=100010;
struct node{
	int data,address,next;
}list[maxn]; 
bool cmp(node a,node b){return a.data&lt;b.data;}
int main(){
	int n,begin,address;
	vector&lt;node&gt; v;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;begin);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		v.push_back(list[begin]);
		begin=list[begin].next;
	}
    if(v.size()==0) printf(&quot;0 -1&quot;);
    else{
        sort(v.begin(),v.end(),cmp);
	    printf(&quot;%d %05d\n&quot;,v.size(),v[0].address);
	    for(int i=0;i&lt;v.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,v[i].address,v[i].data,v[i+1].address);
	    printf(&quot;%05d %d -1\n&quot;,v[v.size()-1].address,v[v.size()-1].data);
    }
    return 0;
}
</code></pre>
<h3 id="a105330-输出权值总和同为给定值的路径dfs">A1053(30 输出权值总和同为给定值的路径(dfs))</h3>
<pre><code>1.#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,s,sum=0,path[101];
struct node{
	int w;
	vector&lt;int&gt; child;
}tree[101];
bool cmp(int a,int b){return tree[a].w&gt;tree[b].w;}
void dfs(int index,int nodenum,int sum){
	if(sum&gt;s) return;
	if(sum==s){
		if(tree[index].child.size()!=0) return;
		for(int i=0;i&lt;nodenum;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,tree[path[i]].w);
		}
		printf(&quot;\n&quot;);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++){
		int child=tree[index].child[i];
		path[nodenum]=child;
		dfs(child,nodenum+1,sum+tree[child].w);
	} 
}
int main(){
	int id,k,c;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;tree[i].w);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;c);
			tree[id].child.push_back(c);
		}
		sort(tree[id].child.begin(),tree[id].child.end(),cmp);
	}
	path[0]=0;
	dfs(0,1,tree[0].w);
	return 0;
}

2.
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=110;
int n,m,s,weight[maxn],notroot[maxn]={0};
vector&lt;int&gt; tree[maxn];
vector&lt;int&gt; t,path;
bool cmp(int a,int b){
	return weight[a]&gt;weight[b];
} 
void dfs(int root,int sum){
	if(tree[root].size()!=0&amp;&amp;sum&gt;s)	return;
	if(tree[root].size()==0&amp;&amp;sum==s){
		t.push_back(root);
		path=t;
		for(int i=0;i&lt;path.size();i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,weight[path[i]]);
		}
		printf(&quot;\n&quot;);
		path.clear();
		t.pop_back();
		return;
	}
	t.push_back(root);
	for(int i=0;i&lt;tree[root].size();i++) dfs(tree[root][i],sum+weight[tree[root][i]]);
	t.pop_back();
}
int main(){
	int root=0;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i];
	for(int i=0;i&lt;m;i++){
		int id,k,temp;
		cin&gt;&gt;id&gt;&gt;k;
		while(k--){
			cin&gt;&gt;temp;
			notroot[temp]=1;
			tree[id].push_back(temp);
		}
		sort(tree[id].begin(),tree[id].end(),cmp);
	} 
	while(notroot[root]!=0&amp;&amp;root&lt;n) root++;
	dfs(root,weight[root]);
	return 0;
}
</code></pre>
<h3 id="a105420-map">A1054(20 map)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int m,n,temp;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	map&lt;int,int&gt; mp;
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;m;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			mp[temp]++;
		}
	}
	int times=-1,ans;
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;times){
			times=it-&gt;second;
			ans=it-&gt;first;
		} 
	} 
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a105525-按条件查找并排序输出">A1055(25 按条件查找并排序输出)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	char name[10];
	int age,worth;
};
bool cmp(node a,node b){
	if(a.worth!=b.worth) return a.worth&gt;b.worth;
	else if(a.age!=b.age) return a.age&lt;b.age;
	else return strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,m,k,amin,amax;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; t(n),v;
    vector&lt;int&gt; book(201,0);
	for(int i=0;i&lt;n;i++)  scanf(&quot;%s%d%d&quot;,t[i].name,&amp;t[i].age,&amp;t[i].worth);
    sort(t.begin(),t.end(),cmp);   
    for(int i=0;i&lt;n;i++){
        if(book[t[i].age]&lt;100){
            v.push_back(t[i]);
            book[t[i].age]++;
        }
    }
	for(int i=1;i&lt;=m;i++) {
		printf(&quot;Case #%d:\n&quot;,i);
		vector&lt;node&gt; ans;
        scanf(&quot;%d%d%d&quot;,&amp;k,&amp;amin,&amp;amax);
		for(int j=0;j&lt;v.size();j++) {
			if(v[j].age&gt;=amin&amp;&amp;v[j].age&lt;=amax) ans.push_back(v[j]);
		}
		if(ans.size()==0) printf(&quot;None\n&quot;);
		else if(k&gt;=ans.size()){
			for(int j=0;j&lt;ans.size();j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}else if(k&lt;ans.size())  {
			for(int j=0;j&lt;k;j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}   
	}
	return 0;
} 
</code></pre>
<h3 id="a105625-queue队列">A1056(25 queue队列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int w,rank;
};
int main(){
	int np,ng,orderid;
	queue&lt;int&gt; q;
	scanf(&quot;%d%d&quot;,&amp;np,&amp;ng);
	vector&lt;node&gt; v(np);
	for(int i=0;i&lt;np;i++) scanf(&quot;%d&quot;,&amp;v[i].w);
	for(int i=0;i&lt;np;i++) {
		scanf(&quot;%d&quot;,&amp;orderid);
		q.push(orderid);
	}
	int temp=np,group;
	while(q.size()!=1){
		if(temp%ng==0) group=temp/ng;
		else group=temp/ng+1;
		for(int i=0;i&lt;group;i++){
			int k=q.front();
			for(int j=1;j&lt;=ng;j++){
				if(i*ng+j&gt;temp) break;
				int front=q.front();
				if(v[front].w&gt;v[k].w) k=front;
				v[front].rank=group+1;
				q.pop();
			}
			q.push(k); 
		}
		temp=group; 
	}
	v[q.front()].rank=1;
	for(int i=0;i&lt;np;i++){
		if(i!=0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,v[i].rank);
	}
	return 0;
} 
</code></pre>
<h3 id="a105730-分块-树状数组">A1057(30 分块、树状数组)</h3>
<pre><code>1.分块
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int table[100010],block[317];
stack&lt;int&gt; st;
void Peekmedian(int x) {
	int sum = 0, block_id = 0;
	while (sum + block[block_id] &lt; x) {
		sum += block[block_id++];
	}
	int num = block_id * 316;
	while (sum + table[num] &lt; x) sum+=table[num++];
	printf(&quot;%d\n&quot;, num);
}
void Push(int x) {
	st.push(x);
	table[x]++;
	block[x / 316]++;
}
void Pop() {
	int top = st.top();
	st.pop();
	table[top]--;
	block[top / 316]--;
	printf(&quot;%d\n&quot;, top);
}
int main() {
	int n, temp;
	char cmd[15];
	scanf(&quot;%d&quot;, &amp;n);
	memset(table, 0, sizeof(table));
	memset(block, 0, sizeof(block));
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, cmd);
		if (strcmp(cmd, &quot;Pop&quot;)==0) {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else Pop();
		}
		else if (strcmp(cmd, &quot;Push&quot;)==0) {
			scanf(&quot;%d&quot;, &amp;temp);
			Push(temp);
		}
		else {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else {
				int k = st.size();
				if (k % 2 == 0) k = k / 2;
				else k = k / 2 + 1;
				Peekmedian(k);
			}
		}
	}
	return 0;
}
2.树状数组

</code></pre>
<h3 id="a105820-水题">A1058(20 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	int a,b,c,d,e,f,ans[3];
	scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);
	ans[2]=(c+f)%29;
	ans[1]=(b+e+(c+f)/29)%17;
	ans[0]=a+d+(b+e+(c+f)/29)/17;
	for(int i=0;i&lt;3;i++){
		if(i!=0) printf(&quot;.&quot;);
		printf(&quot;%d&quot;,ans[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a105925-建立素数表-求素数因数">A1059(25 建立素数表 求素数因数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=105000;
vector&lt;int&gt; prime;
long long n;
bool isprime(int n) {
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2; i&lt;=sqr; i++) {
		if(n%i==0) return false;
	}
	return true;
}
int main() {
	int index=0;
	scanf(&quot;%lld&quot;,&amp;n);
	printf(&quot;%lld=&quot;,n);
	for(int i=2; i&lt;=maxn; i++) {
		if(isprime(i)) prime.push_back(i);
	}
	if(n==1) printf(&quot;1&quot;);
	else {
		int hasprint=0;
		for(int i=0; n&gt;=2; i++) {
			int cnt=0,flag=0;
			while(n%prime[i]==0) {
				n/=prime[i];
				cnt++;
				flag=1;
			}
			if(flag){
				if(hasprint) printf(&quot;*&quot;);
				printf(&quot;%lld&quot;,prime[i]);
				hasprint=1;
			}
			if(cnt&gt;=2) printf(&quot;^%d&quot;,cnt);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a106025-字符串-科学计数法">A1060(25 字符串 科学计数法)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int n;
string deal(string s,int &amp;e){
	int k=0;
	while(s[0]=='0'&amp;&amp;s.length()&gt;0) s.erase(s.begin());//去除前导0 
	if(s[0]=='.'){//若去除后是小数点，说明是小于1的数 
		s.erase(s.begin());
		while(s[0]=='0'&amp;&amp;s.length()&gt;0) {
			s.erase(s.begin());//去除小数点后非零位前的所有0 
			e--;
		}
	}else{
		while(s[k]!='.'&amp;&amp;k&lt;s.length()){//寻找小数点 
			k++;
			e++;
		}
		if(k&lt;s.length()) s.erase(s.begin()+k);//删除小数点 
	}
	if(s.length()==0) e=0;
	int num=0;
	k=0;
	string ans;
	while(num&lt;n){
		if(k&lt;s.length()) ans+=s[k++];
		else ans+='0';
		num++;
	}	
	return ans; 
}		
int main(){
	string s1,s2,s3,s4;
	cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;
	int e1=0,e2=0;
	s3=deal(s1,e1);
	s4=deal(s2,e2);
	if(s3==s4&amp;&amp;e1==e2) cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1;	
	else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1&lt;&lt;&quot; 0.&quot;&lt;&lt;s4&lt;&lt;&quot;*10^&quot;&lt;&lt;e2;
	return 0;
}
</code></pre>
<h3 id="a106120-字符串">A1061(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	int i=0,pos=0;
	char ans[2];
	string a,b,c,d;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;(a[i]&gt;='A'&amp;&amp;a[i]&lt;='G')){
			ans[0]=a[i];
			break;
		}
		i++;
	}
	++i;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;((a[i]&gt;='A'&amp;&amp;a[i]&lt;='N')||isdigit(a[i]))){
			ans[1]=a[i];
			break;
		}
		i++;
	}
	while(pos&lt;c.length()&amp;&amp;pos&lt;d.length()){
		if(c[pos]==d[pos]&amp;&amp;isalpha(c[pos])) break;
		pos++;
	}
	string weekday[7]={&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;};
	printf(&quot;%s %02d:%02d&quot;,weekday[ans[0]-'A'].c_str(),isdigit(ans[1])?ans[1]-'0':ans[1]-'A'+10,pos);
	return 0;
} 
</code></pre>
<h3 id="a1062">A1062</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
struct node{
	int num;
	int de,cai,rank;
}temp;
bool cmp( node a,node b){
	if(a.rank!=b.rank) return a.rank&lt;b.rank;
	else if((a.de+a.cai)!=(b.de+b.cai)) return (a.de+a.cai)&gt;(b.de+b.cai);
	else if(a.de!=b.de) return a.de&gt;b.de;
	else return a.num&lt;b.num;
}
int main(){
	int n,L,H;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;H);
	vector&lt;node&gt; v;
	for(int i=0;i&lt;n;i++){
		int id,a,b,rank;
		scanf(&quot;%d%d%d&quot;,&amp;id,&amp;a,&amp;b);
		if(a&lt;L||b&lt;L) continue;
		if(a&gt;=H&amp;&amp;b&gt;=H) rank=1;
		else if(a&gt;=H&amp;&amp;b&lt;H) rank=2;
		else if(a&lt;H&amp;&amp;b&lt;H&amp;&amp;a&gt;=b) rank=3;
		else rank=4;
		v.push_back(node{id,a,b,rank});
	}
	sort(v.begin(),v.end(),cmp);
	printf(&quot;%d\n&quot;,v.size());
	for(int i=0;i&lt;v.size();i++) printf(&quot;%08d %d %d\n&quot;,v[i].num,v[i].de,v[i].cai);
	return 0;
} 
</code></pre>
<h3 id="a106325-set">A1063(25 set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int maxn = 51;
set&lt;int&gt; v[maxn];
int main() {
	int n,m,temp,k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[i].insert(temp);
		}
	}
	int a, b;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		int nc=0, nt=v[b-1].size();
		for (auto it = v[a - 1].begin(); it != v[a - 1].end(); it++) {
			if (v[b - 1].find(*it) != v[b - 1].end())  nc++;
			else nt++;
		}
		printf(&quot;%.1f%%\n&quot;, (nc * 100.0) / nt);
	}
}
</code></pre>
<h3 id="a106430-完全二叉树中序遍历建树">A1064(30 完全二叉树(中序遍历建树))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1001;
int CBT[maxn],a[maxn],n,index=0;
void inorder(int root){
	if(root&gt;n) return;
	inorder(root*2);
	CBT[root]=a[index++];
	inorder(root*2+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(1);
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,CBT[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a1065">A1065</h3>
<pre><code>#include&lt;cstdio&gt;
int main() {
	long long a, b, c;
	int n,times=1;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
		bool flag;
		long long sum = a + b;
		if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0)
			flag = true;
		else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)
			flag = false;
		else if (sum &gt; c)
			flag = true;
		else flag = false;
		if (flag == true)
			printf(&quot;Case #%d:true&quot;, times++);
		if (flag == false)
			printf(&quot;Case #%d:false&quot;, times++);
	}
	return 0;
}
</code></pre>
<h3 id="a106625-建立平衡二叉树">A1066(25 建立平衡二叉树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v,height;
	node*left,*right;
};
node* newnode(int v){
	node* Node=new node;
	Node-&gt;v=v;
	Node-&gt;height=1;
	Node-&gt;left=Node-&gt;right=NULL;
	return Node;
}
int getheight(node*root){
	if(root==NULL) return 0;
	return root-&gt;height; 
}
void updateheight(node *root){
	root-&gt;height=max(getheight(root-&gt;right),getheight(root-&gt;left))+1;
}
int getbalance(node* root){
	return getheight(root-&gt;left)-getheight(root-&gt;right);
}
void L(node*&amp;root){
	node*temp=root-&gt;right;
	root-&gt;right=temp-&gt;left;
	temp-&gt;left=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void R(node*&amp;root){
	node*temp=root-&gt;left;
	root-&gt;left=temp-&gt;right;
	temp-&gt;right=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void insert(node*&amp;root,int v){
	if(root==NULL){
		root=newnode(v);
		return;
	}
	if(v&lt;root-&gt;v){
		insert(root-&gt;left,v);
		updateheight(root);
		if(getbalance(root)==2){
			if(getbalance(root-&gt;left)==1) R(root);
			else if(getbalance(root-&gt;left)==-1){
				L(root-&gt;left);
				R(root);
			}
		}
	}
	else{
		insert(root-&gt;right,v);
		updateheight(root);
		if(getbalance(root)==-2){
			if(getbalance(root-&gt;right)==-1) L(root);
			else if(getbalance(root-&gt;right)==1){
				R(root-&gt;right);
				L(root);
			}
		}
	}
}
int main(){
	int n,temp;
	node* root=NULL;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		insert(root,temp);
	}
	printf(&quot;%d&quot;,root-&gt;v);
	return 0;
}
</code></pre>
<h3 id="a106725-贪心-swap排序求最小交换次数">A1067(25  贪心 swap排序，求最小交换次数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n,t,cnt=0,a[100001];
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;t;
		a[t]=i;
	}
	for(int i=1;i&lt;n;i++){
		while(a[0]!=0){
			swap(a[0],a[a[0]]);
			cnt++;
		}
		if(a[i]!=i){
			swap(a[i],a[0]);
			cnt++;
		}
	} 
	cout&lt;&lt;cnt;
	return 0;
}
</code></pre>
<h3 id="a1068">A1068</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a106920-数字黑洞">A1069(20 数字黑洞)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
string strsort(string s){
	sort(s.begin(),s.end());
	s.insert(0,4-s.size(),'0');
	return s;
}
string rev(string s){
	reverse(s.begin(),s.end());
	return s;
}
int main(){
	string s;
	cin&gt;&gt;s;
	s.insert(0, 4 - s.length(), '0');
	if(rev(s)==s){
		cout&lt;&lt;s&lt;&lt;&quot; - &quot;&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;&quot;0000&quot;;
		return 0;
	}
	int ans=1;
	while(1){
		s=strsort(s);
		string s1=rev(s);
		ans=stoi(s1)-stoi(s);
		printf(&quot;%s - %s = %04d\n&quot;,s1.c_str(),s.c_str(),ans);
		if(ans==6174) return 0;
		s=to_string(ans);
	}
	return 0;
}
</code></pre>
<h3 id="a107025-贪心">A1070(25 贪心)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	double inventory,price;
};
bool cmp(node &amp;a,node &amp;b){ return a.price&gt;b.price;};
int main(){
	int n,D;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;D);
	double prices,profit=0.0;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%lf&quot;,&amp;v[i].inventory);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%lf&quot;,&amp;prices);
		v[i].price=prices/v[i].inventory;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++){
		if(v[i].inventory&gt;=D){
			profit+=D*v[i].price;
			break;
		}else{
			profit+=v[i].inventory*v[i].price;
			D-=v[i].inventory;
		}
	}
	printf(&quot;%.2f&quot;,profit);
	return 0;
}
</code></pre>
<h3 id="a107125-map-字符串">A1071(25 map  字符串)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	map&lt;string,int&gt; mp;
	string s,temp,ans;
	getline(cin,s);
	int maxtimes=-1;
	for(int i=0;i&lt;s.length();i++){
		if(isalnum(s[i])){
			if(isupper(s[i])) s[i]=tolower(s[i]);
			temp+=s[i];
		}
		if(!isalnum(s[i])||i==s.length()-1){
			if(!temp.empty()) mp[temp]++;
			temp.clear();
		}
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;maxtimes) {
			ans=it-&gt;first;
			maxtimes=it-&gt;second;
		}
	}
	cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;maxtimes;
	return 0;
}
</code></pre>
<h3 id="a107230-多源dijkst求最佳源">A1072(30 多源dijkst求最佳源)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt; 
#include&lt;map&gt;
using namespace std;
const int maxn=1100;
const int INF=0x7fffffff;
int n,m,k,ds,G[maxn][maxn],d[maxn],index_g=n+1;
bool vis[maxn];
map&lt;string,int&gt; mp;
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	fill(vis,vis+maxn,false);
	for(int i=1;i&lt;=n+m;i++){
		int u=-1,MIN=INF;
		for(int j=1;j&lt;=n+m;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=1;v&lt;=n+m;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]) d[v]=d[u]+G[u][v];
			}
		}
	}
}
int getid(string s){
	if(s[0]=='G'){
		s.erase(s.begin());
		if(mp.count(s)==0) mp[s]=stoi(s)+n;
		return mp[s];
	}
	else return stoi(s);
}
int main(){
	int ansid=-1;
	double ansavg=INF,ansmindis=-1;
	string s1,s2;
	fill(G[0],G[0]+maxn*maxn,INF);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;ds);
	while(k--){
		cin&gt;&gt;s1&gt;&gt;s2;
		int v1=getid(s1);
		int v2=getid(s2);
		cin&gt;&gt;G[v1][v2];
		G[v2][v1]=G[v1][v2];
	}
	for(int i=n+1;i&lt;=n+m;i++){
		double mindis=INF,avg=0,sum=0;
		dijkst(i);
		for(int j=1;j&lt;=n;j++){
			if(d[j]&gt;ds){
				mindis=-1;
				break;
			}
			if(d[j]&lt;mindis) mindis=d[j];
			avg+=1.0*d[j]/n;
		}
		if(mindis==-1) continue;
		if(mindis&gt;ansmindis){
			ansid=i;
			ansmindis=mindis;
			ansavg=avg;
		}else if(mindis==ansmindis&amp;&amp;ansavg&gt;avg){
			ansid=i;
			ansavg=avg;
		}
	}
	if(ansid==-1) printf(&quot;No Solution&quot;);
	else{
		printf(&quot;G%d\n&quot;,ansid-n);
	    printf(&quot;%.1f %.1f&quot;,ansmindis,ansavg);
	}
	return 0;
}
</code></pre>
<h3 id="a1073-科学计数法">A1073 科学计数法</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	string s,t;
	int n,i=0;
	cin&gt;&gt;s;
	while(s[i]!='E') i++;
	t=s.substr(1,i-1);
	n=stoi(s.substr(i+1,s.length()-i-1));
	if(s[0]=='-') cout&lt;&lt;&quot;-&quot;;
	if(n&lt;0){
		cout&lt;&lt;&quot;0.&quot;;
		for(int j=0;j&lt;abs(n)-1;j++) cout&lt;&lt;&quot;0&quot;;
		for(int j=0;j&lt;t.size();j++) 
		    if(t[j]!='.') cout&lt;&lt;t[j];
	}else{
		cout&lt;&lt;t[0];
		int cnt,j;
		for(j=2,cnt=0;j&lt;t.length()&amp;&amp;cnt&lt;n;j++,cnt++) cout&lt;&lt;t[j];
		if(j==t.length()) {
			for(int k=0;k&lt;n-cnt;k++) cout&lt;&lt;&quot;0&quot;;
		} else{
			cout&lt;&lt;&quot;.&quot;;
			for(int k=j;k&lt;t.size();k++) cout&lt;&lt;t[k];
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107425-反转链表">A1074(25 反转链表)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	int address,data,next;
	int order;
}list[maxn];
bool cmp(node &amp;a,node &amp;b){
	return a.order&lt;b.order;
}
int main(){
	int begin,n,k,address,cnt=0;
	for(int i=0;i&lt;maxn;i++想·) list[i].order=maxn;
	scanf(&quot;%d%d%d&quot;,&amp;begin,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	int p=begin;
	while(p!=-1){
		list[p].order=cnt++;
		p=list[p].next;
	}
	sort(list,list+maxn,cmp);
	for(int i=0;i&lt;cnt/k;i++){
		for(int j=(i+1)*k-1;j&gt;i*k;j--){
			printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j-1].address);
		}
		printf(&quot;%05d %d &quot;,list[i*k].address,list[i*k].data);
		if(i&lt;cnt/k-1) printf(&quot;%05d\n&quot;,list[(i+2)*k-1].address);
		else{
			if(cnt%k==0) printf(&quot;-1\n&quot;);
			else{
				printf(&quot;%05d\n&quot;,list[(i+1)*k].address);
				for(int j=(i+1)*k;j&lt;cnt-1;j++){
				    printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j+1].address);
				}
				printf(&quot;%05d %d -1&quot;,list[cnt-1].address,list[cnt-1].data);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107525-排序">A1075(25 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int rank,id,total=0;
	vector&lt;int&gt; score;
	int passnum=0;
	bool isshown=false;
}; 
bool cmp(node a,node b){
	if(a.total!=b.total) return a.total&gt;b.total;
	else if(a.passnum!=b.passnum) return a.passnum&gt;b.passnum;
	else return a.id&lt;b.id;
}
int main(){
	int n,k,m,id,index,grade;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);
	vector&lt;node&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) v[i].score.resize(k+1,-1);
	vector&lt;int&gt; p(k+1);
	for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;p[i]);
	for(int i=0;i&lt;m;i++){
	    scanf(&quot;%d%d%d&quot;,&amp;id,&amp;index,&amp;grade);
	    v[id].id=id;
	    v[id].score[index]=max(grade, v[id].score[index]);
	    if(grade!=-1) v[id].isshown=true;
	    else if(v[id].score[index]==-1) v[id].score[index]=-2;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=k;j++){
			if(v[i].score[j]!=-1&amp;&amp;v[i].score[j]!=-2) v[i].total+=v[i].score[j];
			if(v[i].score[j]==p[j]) v[i].passnum++;
		}
	}
	sort(v.begin()+1,v.end(),cmp);
	v[1].rank=1;
	for(int i=2;i&lt;=n;i++){
		if(v[i].total==v[i-1].total) v[i].rank=v[i-1].rank;
		else v[i].rank=i;
	}
	for(int i=1;i&lt;=n;i++){
		if(v[i].isshown==true){
			printf(&quot;%d %05d %d&quot;,v[i].rank,v[i].id,v[i].total);
			for(int j=1;j&lt;=k;j++) {
				if(v[i].score[j]==-1) printf(&quot; -&quot;);
				else if(v[i].score[j]==-2) printf(&quot; 0&quot;);
				else printf(&quot; %d&quot;,v[i].score[j]);
			}
			printf(&quot;\n&quot;);
		}
	}
	return 0;
} 
</code></pre>
<h3 id="a107630-图的bfs-记录给定最大层数上的结点和">A1076(30 图的bfs、记录给定最大层数上的结点和)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int n,l,k;
bool inq[1010];
vector&lt;vector&lt;int&gt; &gt; v;
struct node{
	int id,level;
};
int bfs(node a){
	fill(inq,inq+1010,false);
	int cnt=0;
	queue&lt;node&gt; q;
	q.push(a);
	inq[a.id]=true;
	while(!q.empty()){
		node t=q.front();
		q.pop();
		int tid=t.id;
		for(int i=0;i&lt;v[tid].size();i++){
			int nextid=v[tid][i];
			if(inq[nextid]==false&amp;&amp;t.level&lt;l){
				cnt++;
				node nextnode={nextid,t.level+1};
				q.push(nextnode);
				inq[nextid]=true;
			}
		}
	}
	return cnt;
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;l);
	v.resize(n+1);
	int num,temp;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;num);
		while(num--){
			scanf(&quot;%d&quot;,&amp;temp);
			v[temp].push_back(i);
		}
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;temp);
		node tnode={temp,0};
		printf(&quot;%d\n&quot;,bfs(tnode));
	}
	return 0;
}
</code></pre>
<h3 id="a107720-多个字符串找公共后缀">A1077(20  多个字符串找公共后缀)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	scanf(&quot;%d\n&quot;,&amp;n);
	string ans;
	int minlen;
	for(int i=0;i&lt;n;i++){
		string s;
		getline(cin,s);
		reverse(s.begin(),s.end());
		if(i==0){
			ans=s;
			minlen=ans.length();
		}else{
			int len=s.length();
			minlen=min(minlen,len);
			for(int j=0;j&lt;minlen;j++){
				if(s[j]!=ans[j]) {
					ans=s.substr(0,j);
					break;
				}
			}
		}
	}
	reverse(ans.begin(),ans.end());
	if(ans.size()==0) cout&lt;&lt;&quot;nai&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a107825-hash-平方探查">A1078(25 hash 平方探查)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(1.0*n);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,temp,cnt=0;
	scanf(&quot;%d%d&quot;,&amp;msize,&amp;n);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize,0);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		int flag=0,ans;
		for(int j=0;j&lt;msize;j++){
			int pos=(temp+j*j)%msize;
			if(v[pos]==0){
				v[pos]=temp;
				flag=1;
				ans=pos;
				break;
			}
		}
		if(cnt!=0) printf(&quot; &quot;);
		cnt++;
		if(flag) printf(&quot;%d&quot;,ans);
		else printf(&quot;-&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a107925-树的dfs">A1079(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n;
double p,r,ans=0.0;
struct node{
	int data;
	vector&lt;int&gt; child;
}tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].child.size()==0){
		ans+=tree[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++) dfs(tree[index].child[i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int num,root,ischild[100010]={0},temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;num);
		if(num==0){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].data=temp;
		}else{
			for(int j=0;j&lt;num;j++) {
				scanf(&quot;%d&quot;,&amp;temp);
				ischild[temp]=1;
				tree[i].child.push_back(temp);
			}	
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		}
	}
	dfs(root,0);
	printf(&quot;%.1f&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a108030-排序">A1080(30 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int ge,gi,sum,rank,id;
	vector&lt;int&gt; choice;
};
bool cmp1(node&amp; a,node&amp; b){
	if(a.sum!=b.sum) return a.sum&gt;b.sum;
	else return a.ge&gt;b.ge;
}
bool cmp2(node&amp; a,node&amp; b){
	return a.id&lt;b.id;
}
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	vector&lt;int&gt; sch_need(m);
	vector&lt;node&gt; stu(n);
	for(int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;sch_need[i]);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;stu[i].ge,&amp;stu[i].gi);
		stu[i].sum=stu[i].ge+stu[i].gi;
		stu[i].id=i;
		stu[i].choice.resize(k);
		for(int j=0;j&lt;k;j++) scanf(&quot;%d&quot;,&amp;stu[i].choice[j]);
	}
	sort(stu.begin(),stu.end(),cmp1);
	vector&lt;node&gt; ans[m];
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;k;j++){
			int temp=stu[i].choice[j];
			if(ans[temp].size()&lt;sch_need[temp]||
			(ans[temp][ans[temp].size()-1].sum==stu[i].sum&amp;&amp;ans[temp][ans[temp].size()-1].ge==stu[i].ge)) {
				ans[temp].push_back(stu[i]);
				break;
			}
		}
	}
	for(int i=0;i&lt;m;i++){
		sort(ans[i].begin(),ans[i].end(),cmp2);
		for(int j=0;j&lt;ans[i].size();j++){
			if(j!=0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,ans[i][j].id);
		}
		printf(&quot;\n&quot;);	
	}
	return 0;
}
</code></pre>
<h3 id="a108120-分数相加">A1081(20 分数相加)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
long long gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	long long a2 = 0, b2 = 1,gcdvalue;
	for (int i = 0; i &lt; n; i++) {
		long long a, b;
		scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);
		gcdvalue = gcd(a, b);
		a /= gcdvalue;
		b /= gcdvalue;
		a2 = a * b2 + b * a2;
		b2 = b * b2;
		gcdvalue = gcd(a2, b2);
		a2 /= gcdvalue;
		b2 /= gcdvalue;
	}
	long long integer = a2 / b2;
	a2 = a2 - integer * b2;
	if (integer != 0) {
		printf(&quot;%lld&quot;, integer);
		if (a2 &gt; 0) printf(&quot; %lld/%lld&quot;,a2,b2);
		else if (a2 &lt; 0) printf(&quot; %lld/%lld&quot;, -a2, b2);
	}
	if (integer == 0 &amp;&amp; a2 != 0) printf(&quot;%lld/%lld&quot;, a2, b2);
	if (integer == 0 &amp;&amp; a2 == 0) printf(&quot;0&quot;);
	return 0;
}
方法二:
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	long long up,down;
};
long long gcd(long long a,long long b){
	return b==0? abs(a) : gcd(b,a%b);
}
node reduction(node res){
	if(res.down&lt;0){
		res.up=-res.up;
		res.down=-res.down;
	}
	if(res.up==0) res.down=1;
	else{
		long long d=gcd(abs(res.up),abs(res.down));
		res.up/=d;
		res.down/=d;
	}
	return res;
}
node add(node f1,node f2){
	node res;
	res.up=f1.down*f2.up+f1.up*f2.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
void showres(node res){
	res=reduction(res);
	if(res.down==1) printf(&quot;%lld\n&quot;,res.up);
	else if(abs(res.up)&gt;abs(res.down)){
		printf(&quot;%lld %lld/%lld\n&quot;,res.up/res.down,abs(res.up%res.down),res.down);
	}else printf(&quot;%lld/%lld\n&quot;,res.up,res.down);
}
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	node temp,ans;
	ans.up=0,ans.down=1;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%lld/%lld&quot;,&amp;temp.up,&amp;temp.down);
		ans=add(ans,temp);
	} 
	showres(ans);
	return 0;
}
</code></pre>
<h3 id="a108225-分段处理字符串">A1082(25 分段处理字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n;
	cin&gt;&gt;n;
	int len=n.length();
	int left=0,right=len-1;
	string num[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};
	string wei[5]={&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Yi&quot;};
	if(n[0]=='-') {
		cout&lt;&lt;&quot;Fu&quot;;
		left++;
	}
	while(left+4&lt;=right){
		right-=4;
	}
	while(left&lt;len){
		bool flag=false;
		bool hasprint=false;
		while(left&lt;=right){
			if(left&gt;0&amp;&amp;n[left]=='0') flag=true;
			else{
				if(flag==true){
					cout&lt;&lt;&quot; &quot;&lt;&lt;&quot;ling&quot;;
					flag=false;
				}
				if(left&gt;0) cout&lt;&lt;&quot; &quot;;
				cout&lt;&lt;num[n[left]-'0'];
				hasprint=true;
				if(left!=right) cout&lt;&lt;&quot; &quot;&lt;&lt;wei[right-left-1];
			}
			left++;
		}
		if(right!=len-1&amp;&amp;hasprint==true)	cout&lt;&lt;&quot; &quot;&lt;&lt;wei[(len-1-right)/4+2]; 
		right+=4; 
	}
	return 0;
} 
</code></pre>
<h3 id="a108325-排序">A1083(25 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string name,id;
	int grade;
}stu[1000];
bool cmp(node a,node b){return a.grade&gt;b.grade;}
int main(){
	int n,score,g1,g2;
	string name,id;
	vector&lt;node&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].id&gt;&gt;stu[i].grade;
	cin&gt;&gt;g1&gt;&gt;g2;
	for(int i=0;i&lt;n;i++) {
		if(stu[i].grade&gt;=g1&amp;&amp;stu[i].grade&lt;=g2){
			ans.push_back(stu[i]);
		}
	}
	if(ans.size()==0) cout&lt;&lt;&quot;NONE&quot;;
	else{
		sort(ans.begin(),ans.end(),cmp);
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%s %s\n&quot;,ans[i].name.c_str(),ans[i].id.c_str());
	} 
	return 0;
}
</code></pre>
<h3 id="a108420-字符串">A1084(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	cin&gt;&gt;s1&gt;&gt;s2;
	for(int i=0;i&lt;s1.length();i++){
		if(s2.find(s1[i])==string::npos&amp;&amp;ans.find(toupper(s1[i]))==string::npos)
		  ans+=toupper(s1[i]); 
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a108525-二分-twopoints-多解法">A1085(25 二分 twopoints 多解法)</h3>
<pre><code>二分法
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,p,ans=0;
	cin&gt;&gt;n&gt;&gt;p;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++)  cin&gt;&gt;v[i];
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n;i++){
		int j=upper_bound(v.begin()+i+1,v.begin()+n,(long long)p*v[i])-v.begin();
		ans=max(ans,j-i);
	}
	cout&lt;&lt;ans;
	return 0;
}


two points
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, p,num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num,num + n);
	int count=0,i=0,j=0;
    while(i&lt;n&amp;&amp;j&lt;n){
        while(j&lt;n&amp;&amp;num[j]&lt;=(long long)num[i]*p){
            count=max(count,j-i+1);
            j++;
        }
        i++;
    }
    printf(&quot;%d&quot;,count);
    return 0;
}
</code></pre>
<h3 id="a108625-栈模拟中序和先序建树输出后序">A1086(25 栈模拟中序和先序建树，输出后序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=31;
int n,pre[maxn],in[maxn],num=0;
struct node{
	int data;
	node*left,*right;
};
node*create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;data=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;right=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
void postorder(node*root){
	if(root==NULL) return;
	postorder(root-&gt;left);
	postorder(root-&gt;right);
	printf(&quot;%d&quot;,root-&gt;data);
	num++;
	if(num&lt;n) printf(&quot; &quot;);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char s[5];
	stack&lt;int&gt; st;
	int temp,preindex=0,inindex=0;
	for(int i=0;i&lt;2*n;i++){
		scanf(&quot;%s&quot;,s);
		if(strcmp(s,&quot;Push&quot;)==0){
			scanf(&quot;%d&quot;,&amp;temp);
			st.push(temp);
			pre[preindex++]=temp;
		}else{
			temp=st.top();
			st.pop();
			in[inindex++]=temp;
		}
	}
	node*root=create(0,n-1,0,n-1);
	postorder(root);
	return 0;
}
</code></pre>
<h3 id="a108730-dijkstdfs边权点权-总边权-平均点权">A1087(30 dijkst+dfs,边权点权、总边权、平均点权)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt; 
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=210;
const int INF=0x7fffffff;
int n,k,G[maxn][maxn],d[maxn],happ[maxn],maxhapp=0,num=0;
double maxavg=0;
vector&lt;int&gt; pre[maxn];
bool vis[maxn]={false};
map&lt;string,int&gt; cityint;
map&lt;int,string&gt; citystr;
vector&lt;int&gt; temppath,path;
void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					d[v]=G[u][v]+d[u];
					pre[v].clear();
					pre[v].push_back(u);
				}else if(d[u]+G[u][v]==d[v]) pre[v].push_back(u);
			}
		}
	}
}
void dfs(int s){
	if(s==0){
		num++;
		int temphapp=0;
		temppath.push_back(s);
		for(int i=temppath.size()-2;i&gt;=0;i--) temphapp+=happ[temppath[i]];
		double tempavg=temphapp*1.0/(temppath.size()-1);
		if(temphapp&gt;maxhapp){
			path=temppath;
			maxhapp=temphapp;
			maxavg=tempavg;
		}else if(temphapp==maxhapp&amp;&amp;tempavg&gt;maxavg){
			path=temppath;
			maxavg=tempavg;
		}
		temppath.pop_back();
		return;
	}
	temppath.push_back(s);
	for(int i=0;i&lt;pre[s].size();i++) dfs(pre[s][i]);
	temppath.pop_back();
}
int main(){
	string c1,c2;
	int a,index=0;
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;c1;
	cityint[c1]=index++;
	citystr[cityint[c1]]=c1;
	for(int i=0;i&lt;n-1;i++){
		cin&gt;&gt;c1&gt;&gt;a;
		cityint[c1]=index++;
	    citystr[cityint[c1]]=c1;
		happ[cityint[c1]]=a;
	}
	fill(G[0],G[0]+maxn*maxn,INF);
	while(k--){
		cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;a;
		G[cityint[c1]][cityint[c2]]=a;
		G[cityint[c2]][cityint[c1]]=a;
	}
	dijkst(0);
	dfs(cityint[&quot;ROM&quot;]);
	printf(&quot;%d %d %d %d\n&quot;,num,d[cityint[&quot;ROM&quot;]],maxhapp,(int)maxavg);
	for(int i=path.size()-1;i&gt;=0;i--){
		cout&lt;&lt;citystr[path[i]];
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	return 0;
} 
</code></pre>
<h3 id="a108820-分数的加减乘除">A1088(20  分数的加减乘除)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	long long up, down;
};
long long gcd(long long a,long long b){
	return b==0? abs(a) : gcd(b,a%b);
}
node reduction(node res){
	if(res.down&lt;0){
		res.up=-res.up;
		res.down=-res.down;
	}
	if(res.up==0) res.down=1;
	else{
		long long d=gcd(abs(res.up),abs(res.down));
		res.up/=d;
		res.down/=d;
	}
	return res;
}
node add(node f1,node f2){//分数相加
	node res;
	res.up=f1.down*f2.up+f1.up*f2.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node minu(node f1,node f2){//分数相减
	node res;
	res.up=f1.up*f2.down-f2.up*f1.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node multi(node f1,node f2){//分数相乘
	node res;
	res.up=f1.up*f2.up;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node divide(node f1,node f2){//分数相除
	node res;
	res.up=f1.up*f2.down;
	res.down=f1.down*f2.up;
	return reduction(res);
}
void showres(node res){
	res=reduction(res);
	if(res.up&lt;0) printf(&quot;(&quot;);
	if(res.down==1) printf(&quot;%lld&quot;,res.up);
	else if(abs(res.up)&gt;abs(res.down)){
		printf(&quot;%lld %lld/%lld&quot;,res.up/res.down,abs(res.up%res.down),res.down);
	}else printf(&quot;%lld/%lld&quot;,res.up,res.down);
	if(res.up&lt;0) printf(&quot;)&quot;);
}
int main(){
	node a,b,ans;
	scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;a.up,&amp;a.down,&amp;b.up,&amp;b.down);
	showres(a);
	printf(&quot; + &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(add(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; - &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(minu(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; * &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(multi(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; / &quot;);
	showres(b);
	printf(&quot; = &quot;);
	if(b.up==0) printf(&quot;Inf&quot;);
	else showres(divide(a,b));
	printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a1089-25-插入排序和归并排序">A1089  (25 插入排序和归并排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100],b[100],n,j,m;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i];
	for(j=0;j&lt;n-1&amp;&amp;b[j]&lt;=b[j+1];j++);
	for(m=j+1;m&lt;n&amp;&amp;a[m]==b[m];m++);
	if(m==n){
		cout&lt;&lt;&quot;Insertion Sort\n&quot;;
		sort(a,a+j+2);
	}else{
		cout&lt;&lt;&quot;Merge Sort\n&quot;;
		int flag=1,k=1;
		while(flag){
			flag=0;
			for(int i=0;i&lt;n;i++){
				if(a[i]!=b[i]) flag=1;
			}
			k=k*2;
			for(int i=0;i&lt;n/k;i++) sort(a+i*k,a+(i+1)*k);
			sort(a+(n/k)*k,a+n);
		}
	}
	for(int i=0;i&lt;n;i++){
		if(i!=0) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;a[i];
	}
	return 0;
}
</code></pre>
<h3 id="a109025-树的dfs求深度">A1090(25 树的dfs求深度)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int maxdepth=-1,num,n;
double p,r,ans=0;
vector&lt;int&gt; tree[100010];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(depth&gt;maxdepth){
			maxdepth=depth;
			num=1;
		}
		else if(depth==maxdepth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int father,root;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;father);
		if(father==-1) root=i;
	    else tree[father].push_back(i);
	}
	dfs(root,0);
	ans=p*pow((1+r/100),maxdepth);
	printf(&quot;%.2f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a109130-经典bfs求矩阵中块的个数">A1091(30 经典BFS求矩阵中块的个数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int x,y,z;
}Node;
int m,n,L,t,ans=0;
bool inq[70][1300][140]={false};
int pix[70][1300][140]={0};
int Z[6]={0,0,0,0,1,-1};
int X[6]={0,0,1,-1,0,0};
int Y[6]={1,-1,0,0,0,0};
bool judge(int z,int y,int x){
	if(x&gt;=n||x&lt;0||y&gt;=m||y&lt;0||z&lt;0||z&gt;=L) return false;
	if(pix[z][y][x]==0||inq[z][y][x]==true) return false;
	return true;
}
int bfs(int z,int y,int x){
	int total=0;
	queue&lt;node&gt; q;
	Node.x=x,Node.y=y,Node.z=z;
	q.push(Node);
	inq[z][y][x]=true;
	while(!q.empty()){
		node Top=q.front();
		q.pop();
		total++;//注意在出队的时候计数 
		for(int i=0;i&lt;6;i++){
			int newz=Top.z+Z[i];
			int newx=Top.x+X[i];
			int newy=Top.y+Y[i];
			if(judge(newz,newy,newx)){
				Node.x=newx,Node.y=newy,Node.z=newz;
				q.push(Node);
				inq[newz][newy][newx]=true;
			}
		}
	}
	if(total&gt;=t) return total;
	else return 0;
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;m,&amp;n,&amp;L,&amp;t);
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				scanf(&quot;%d&quot;,&amp;pix[i][j][k]);
			}
		}
	}
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				if(inq[i][j][k]==false&amp;&amp;pix[i][j][k]==1) ans+=bfs(i,j,k);
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1092字符串-hash">A1092(字符串 hash)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2;
	cin&gt;&gt;s1&gt;&gt;s2;
	vector&lt;int&gt; v(128,0);
	bool can=true;
	int miss=0;
	for(int i=0;i&lt;s1.length();i++)  v[s1[i]]++;
	for(int i=0;i&lt;s2.length();i++){
	    v[s2[i]]-=1;
	    if(v[s2[i]]&lt;0) {
	    	can=false;
	    	++miss;
		}
	}
	if(can==false) cout&lt;&lt;&quot;No &quot;&lt;&lt;miss;
	else cout&lt;&lt;&quot;Yes &quot;&lt;&lt;s1.length()-s2.length();
	return 0;
}
</code></pre>
<h3 id="a109325-逻辑题">A1093(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	cin&gt;&gt;s;
	long long ans=0;
	int num1[100010]={0},num2[100010]={0};
	for(int i=1;i&lt;s.length();i++){
		if(s[i-1]=='P') num1[i]=num1[i-1]+1;
		else num1[i]=num1[i-1];
	}
	for(int i=s.length()-2;i&gt;=0;i--){
		if(s[i+1]=='T') num2[i]=num2[i+1]+1;
		else num2[i]=num2[i+1];
	}
	for(int i=1;i&lt;s.length()-1;i++){
		if(s[i]=='A') ans+=num1[i]*num2[i];
	}
	cout&lt;&lt;ans%1000000007;
	return 0;
}
</code></pre>
<h3 id="a109425-树的dfs">A1094(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1,ansnum=-1,anslevel;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	level[depth]++;
	if(tree[index].size()==0){
		if(maxdepth&lt;depth) maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,1);
	for(int i=1;i&lt;=maxdepth;i++){
		if(level[i]&gt;ansnum){
			ansnum=level[i];
			anslevel=i;
		}
	}
	printf(&quot;%d %d&quot;,ansnum,anslevel);
	return 0;
}
</code></pre>
<h3 id="a109530-校园停车-排序-两辆配对-时间查询输出">A1095(30 校园停车 排序  两辆配对  时间查询输出)</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
struct node{
	string id;
	int time,flag=0;
};
bool cmp1(node &amp;a,node &amp;b){
	return a.id!=b.id? a.id&lt;b.id : a.time&lt;b.time;
}
bool cmp2(node &amp;a,node &amp;b){
	return a.time&lt;b.time;
}
int main(){
	int n,m,hh,mm,ss,maxparking=-1,tempindex=0;
	string status;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; record(n),car;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;record[i].id;
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		cin&gt;&gt;status;
		record[i].time=hh*3600+mm*60+ss;
		record[i].flag=(status==&quot;in&quot;)? 1 : -1;
	}
	sort(record.begin(),record.end(),cmp1);
	map&lt;string,int&gt; mp;
	for(int i=1;i&lt;n;i++){
		if(record[i-1].flag==1&amp;&amp;record[i].flag==-1&amp;&amp;record[i-1].id==record[i].id){
			car.push_back(record[i-1]);
			car.push_back(record[i]);
			mp[record[i].id]+=record[i].time-record[i-1].time;
		    if(maxparking&lt;mp[record[i].id]) maxparking=mp[record[i].id];
		}
	}
	sort(car.begin(),car.end(),cmp2);
	vector&lt;int&gt; cnt(n);
	for(int i=0;i&lt;car.size();i++){
		if(i==0) cnt[i]+=car[i].flag;
		else cnt[i]=cnt[i-1]+car[i].flag;
	}
	
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		int query=hh*3600+mm*60+ss;
		int j;
		for(j=tempindex;j&lt;car.size();j++){
			if(query&lt;car[j].time){
				printf(&quot;%d\n&quot;,cnt[j-1]);
				break;
			}else if(j==car.size()-1) printf(&quot;%d\n&quot;,cnt[j]);
		}
		tempindex=j;
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second==maxparking) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;
	}
	printf(&quot;%02d:%02d:%02d&quot;,maxparking/3600,maxparking%3600/60,maxparking%60);
	return 0;
}
</code></pre>
<h3 id="a109620-找出连续的因数">A1096(20 找出连续的因数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
long long n,temp=1;
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	int st=0,len=0;
	for(int i=2;i&lt;=sqrt(n*1.0);i++){
		int j,temp=1;
		for(j=i;j&lt;=sqrt(n*1.0);j++){
			temp*=j;
			if(n%temp!=0) break;
		}
		if(j-i&gt;len){
			len=j-i;
			st=i;
		}
	}
	if(st==0) printf(&quot;1\n%d&quot;,n);
	else{
		printf(&quot;%d\n&quot;,len);
	    for(int i=0;i&lt;len;i++){
		   if(i!=0) printf(&quot;*&quot;);
		   printf(&quot;%d&quot;,st+i);
    	}
	}
	return 0;
}
</code></pre>
<h3 id="a109725-链表分离">A1097(25 链表分离)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int address,data,next;
}list[100010];
int main(){
	int begin,n,address;
	scanf(&quot;%d%d&quot;,&amp;begin,&amp;n);
	vector&lt;int&gt; flag(10010,0);
	vector&lt;node&gt; remain,remov;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		if(flag[abs(list[begin].data)]==0) {
			flag[abs(list[begin].data)]=1;
			remain.push_back(list[begin]);
		}else remov.push_back(list[begin]);
		begin=list[begin].next;
	}
	for(int i=0;i&lt;remain.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remain[i].address,remain[i].data,remain[i+1].address);		
	printf(&quot;%05d %d -1\n&quot;,remain[remain.size()-1].address,remain[remain.size()-1].data);
	if(remov.size()!=0){
		for(int i=0;i&lt;remov.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remov[i].address,remov[i].data,remov[i+1].address);		
     	printf(&quot;%05d %d -1&quot;,remov[remov.size()-1].address,remov[remov.size()-1].data);
	}
	return 0;
}
</code></pre>
<h3 id="a109825-判断插入排序和堆排序">A1098(25 判断插入排序和堆排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
void downadjust(vector&lt;int&gt;&amp;b,int low,int high){
	int i=low,j=i*2;
	while(j&lt;=high){
		if(j+1&lt;=high&amp;&amp;b[j+1]&gt;b[j]) j=j+1;
		if(b[i]&gt;=b[j]) break;
		swap(b[i],b[j]);
		i=j;
		j=i*2;
	}
}
int main(){
	int n,p,q;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt;a(n+1),b(n+1);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for(p=2;b[p-1]&lt;=b[p]&amp;&amp;p&lt;=n;p++);
	int index=p;
	while(index&lt;=n&amp;&amp;a[index]==b[index]) index++;
	if(index==n+1){
		printf(&quot;Insertion Sort\n&quot;);
		sort(b.begin()+1,b.begin()+p+1);	
	}
	else{
		printf(&quot;Heap Sort\n&quot;);
		for(q=n;b[q]&gt;=b[1]&amp;&amp;q&gt;2;q--);
		swap(b[1],b[q]);
		downadjust(b,1,q-1);
	}
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,b[i]);
	}
	return 0;
} 
</code></pre>
<h3 id="a109930-中序遍历建立二叉搜索树">A1099(30 中序遍历建立二叉搜索树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=101;
struct node{
	int v;
	int left,right;
}Node[maxn];
int n,a[maxn],index=0,num=0;
void inorder(int root){
	if(root==-1) return;
	inorder(Node[root].left);
	Node[root].v=a[index++];
	inorder(Node[root].right);
} 
void bfs(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int temp=q.front();
		q.pop();
		if(num&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,Node[temp].v);
		num++;
		if(Node[temp].left!=-1) q.push(Node[temp].left);
		if(Node[temp].right!=-1) q.push(Node[temp].right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;Node[i].left,&amp;Node[i].right);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(0);
	bfs(0);
	return 0;
} 
</code></pre>
<h3 id="a110020-字符串-string-map">A1100(20 字符串 string map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
string unitdigit[13]={&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,
&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string tendigit[13]= {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,
&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
string numtostr[169];
map&lt;string,int&gt; strtonum;
void init(){
	for(int i=0;i&lt;13;i++){
		numtostr[i]=unitdigit[i];
		strtonum[unitdigit[i]]=i;
		numtostr[i*13]=tendigit[i];
		strtonum[tendigit[i]]=i*13;
	}
	for(int i=1;i&lt;13;i++){
		for(int j=1;j&lt;13;j++){
			string str=tendigit[i]+&quot; &quot;+unitdigit[j];
			numtostr[i*13+j]=str;
			strtonum[str]=i*13+j;
		}
	}
}
int main(){
	init();
	int n,temp;
	scanf(&quot;%d\n&quot;,&amp;n);
	string s;
	while(n--){
		getline(cin,s);
		if(s[0]&gt;='0'&amp;&amp;s[0]&lt;='9'){
			temp=stoi(s);
			cout&lt;&lt;numtostr[temp]&lt;&lt;endl;
		}
		else cout&lt;&lt;strtonum[s]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a110125-逻辑题">A1101(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std; 
int main(){
	int n,a[100010],leftmax=-1,rightmin=0x7fffffff;
	int left[100010],right[100010];
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	left[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i-1]&gt;leftmax) leftmax=a[i-1];
		left[i]=leftmax;
	}
	right[n-1]=a[n-1];
	for(int i=n-2;i&gt;=0;i--){
		if(a[i+1]&lt;rightmin) rightmin=a[i+1];
		right[i]=rightmin;
	}
	for(int i=0;i&lt;n;i++){
		if(a[i]&gt;=left[i]&amp;&amp;a[i]&lt;=right[i]) ans.insert(a[i]);
	}
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(auto it=ans.begin();it!=ans.end();it++){
		if(it!=ans.begin()) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;*it;
	}
	cout&lt;&lt;endl;
	 return 0;
}
</code></pre>
<h3 id="a110225-二叉树反转">A1102(25 二叉树反转)</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int left,right;
}tree[11];
int n,ischild[11]={0},root,num1=0,num2=0;
void layerorder(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top);
		num1++;
		if(num1&lt;n) printf(&quot; &quot;);
		if(tree[Top].left!=-1) q.push(tree[Top].left);
		if(tree[Top].right!=-1) q.push(tree[Top].right); 
	}
}
void inorder(int root){
	if(root==-1) return;
	inorder(tree[root].left);
	printf(&quot;%d&quot;,root);
	num2++;
	if(num2&lt;n) printf(&quot; &quot;);
	inorder(tree[root].right);
}
void invert(int root){
	if(root==-1) return;
	invert(tree[root].left);
	invert(tree[root].right);
	swap(tree[root].left,tree[root].right);
} 
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char c1,c2;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%*c%c %c&quot;,&amp;c1,&amp;c2);
		if(c1=='-') tree[i].left=-1;
		else {
			ischild[c1-'0']=1;
			tree[i].left=c1-'0';
		}
		if(c2=='-') tree[i].right=-1;
		else {
			ischild[c2-'0']=1;
			tree[i].right=c2-'0';
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		} 
	}
	invert(root);
	layerorder(root);
	printf(&quot;\n&quot;);
	inorder(root);
	return 0;
}
</code></pre>
<h3 id="a110330-dfs-分解因式">A1103(30 DFS 分解因式)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
int n,k,p,maxfac=-1;
vector&lt;int&gt; fac,temp,ans; 
void init(){
	int i=0;
	while(pow(i,p)&lt;=n){
		fac.push_back(pow(i,p));
		i++;
	} 
}
void dfs(int index,int nowk,int sum,int facsum){
	if(nowk==k&amp;&amp;sum==n){
		if(facsum&gt;maxfac){
			maxfac=facsum;
			ans=temp;
		}
		return;
	}
	if(nowk&gt;k||sum&gt;n) return;
	if(index&gt;=1){
		temp.push_back(index);
		dfs(index,nowk+1,sum+fac[index],facsum+index);
		temp.pop_back();
		dfs(index-1,nowk,sum,facsum);
	}
}
int main(){
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;p);
	init();
	dfs(fac.size()-1,0,0,0);
	if(maxfac==-1) printf(&quot;Impossible&quot;);
	else{
		printf(&quot;%d = &quot;,n);
		for(int i=0;i&lt;ans.size();i++){
		   if(i&gt;0) printf(&quot; + &quot;);
		   printf(&quot;%d^%d&quot;,ans[i],p);
	   }
	}
	return 0;
}
</code></pre>
<h3 id="a110420-片段和-逻辑题">A1104(20 片段和 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int main(){
	int n;
	long double ans=0,temp;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;temp;
		ans+=temp*(n-i)*(i+1);
	}
	printf(&quot;%.2llf\n&quot;,ans);
	return 0; 
}
</code></pre>
<h3 id="a110525-顺时针螺旋二维数组注意判断下标越界">A1105(25 顺时针螺旋二维数组，注意判断下标越界)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b) {
	return a&gt;b;
}
int main() {
	int N, m,n;
	scanf(&quot;%d&quot;,&amp;N);
	vector&lt;int&gt;t(N);
	for(int i=0; i&lt;N; i++) scanf(&quot;%d&quot;,&amp;t[i]);
	sort(t.begin(),t.end(),cmp);
	m=(int)(ceil(sqrt(N*1.0)));
	while(N%m!=0) m++;
	n=N/m;
	vector&lt;vector&lt;int&gt; &gt;v(m,vector&lt;int&gt;(n));
	int level=m/2+m%2,index=0;
	for(int i=0; i&lt;level; i++) {
		for(int j=i; j&lt;n-i&amp;&amp;index&lt;N; j++)  v[i][j]=t[index++];
		for(int j=i+1; j&lt;m-i&amp;&amp;index&lt;N; j++) v[j][n-i-1]=t[index++];
		for(int j=n-i-2; j&gt;=i&amp;&amp;index&lt;N; j--) v[m-i-1][j]=t[index++];
		for(int j=m-i-2; j&gt;i&amp;&amp;index&lt;N; j--) v[j][i]=t[index++];
	}
	for(int i=0; i&lt;m; i++) {
		if(i!=0) printf(&quot;\n&quot;);
		for(int j=0; j&lt;n; j++) {
			if(j!=0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,v[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a110625-树的dfs">A1106(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n,num=0,mindepth=0x7fffffff;
double p,r,ans=0.0;
vector&lt;int&gt; tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(mindepth&gt;depth){
			mindepth=depth;
			num=1;
		}else if(mindepth==depth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int k,temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].push_back(temp);
		}
	}
	dfs(0,0);
	ans=p*pow((1+r/100),mindepth);
	printf(&quot;%.4f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a110730-经典并查集">A1107(30 经典并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
vector&lt;int&gt;father,isroot;
bool cmp(int a,int b){return a&gt;b;}
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
}
void Union(int a,int b){
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA!=faB) father[faA]=faB;
}
int main(){
	int course[1001]={0},n,num,courseid,cnt=0;
	scanf(&quot;%d&quot;,&amp;n);
	father.resize(n+1);
	isroot.resize(n+1,0);
	for(int i=1;i&lt;=n;i++) father[i]=i;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d:&quot;,&amp;num);
		while(num--){
			scanf(&quot;%d&quot;,&amp;courseid);
			if(course[courseid]==0) course[courseid]=i;
			Union(i,findfather(course[courseid])); 
		}
	}
	for(int i=1;i&lt;=n;i++) isroot[findfather(i)]++;
	for(int i=1;i&lt;=n;i++){
		if(isroot[i]!=0) cnt++;
	}
	sort(isroot.begin(),isroot.end(),cmp);
	printf(&quot;%d\n&quot;,cnt);
	for(int i=0;i&lt;cnt;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,isroot[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a110820-字符串-sscanf-sprintf">A1108(20 字符串 sscanf、sprintf)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
int main(){
	int n,num=0;
	double sum=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		char s[50],b[50];
		double temp;
		int flag=0;
		scanf(&quot;%s&quot;,s);
		sscanf(s,&quot;%lf&quot;,&amp;temp);
		sprintf(b,&quot;%.2f&quot;,temp);
		for(int j=0;j&lt;strlen(s);j++){
			if(s[j]!=b[j]) flag=1;
		}
		if(flag||temp&lt;-1000||temp&gt;1000){
			printf(&quot;ERROR: %s is not a legal number\n&quot;,s);
			continue;
		}
		num++;
		sum+=temp;
	}
	if(num==0) printf(&quot;The average of 0 numbers is Undefined&quot;);
	else if(num==1) printf(&quot;The average of 1 number is %.2f&quot;,sum);
	else printf(&quot;The average of %d numbers is %.2f&quot;,num,sum/num);
	return 0;
}
</code></pre>
<h3 id="a110925-排序">A1109(25 排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int height;
	char name[10];
}v[10010];
bool cmp(node a,node b){
	return a.height!=b.height? a.height&gt;b.height : strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,k,index=0,num;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	int m=round(n*1.0/k);
	for(int i=0;i&lt;n;i++) scanf(&quot;%s%d&quot;,v[i].name,&amp;v[i].height);
	sort(v,v+n,cmp);
	for(int i=0;i&lt;k;i++){
		if(i==0) num=n-m*(k-1);
		else num=m;
		vector&lt;node&gt; temp(num);
		temp[num/2]=v[index++];
		for(int j=0;j&lt;num;j++){
			if(num/2-j-1&gt;=0) temp[num/2-j-1]=v[index++];
			if(num/2+j+1&lt;num) temp[num/2+j+1]=v[index++];
		}
		for(int j=0;j&lt;num;j++){
			if(j&gt;0) printf(&quot; &quot;);
			printf(&quot;%s&quot;,temp[j].name);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a111025-判断是否是完全二叉树-dfs">A1110(25 判断是否是完全二叉树 dfs)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node{
	int left,right;
}v[30];
int n,maxn=-1,ans;
void dfs(int root,int index){
	if(index&gt;maxn){
		maxn=index;
		ans=root;
	}
	if(v[root].left!=-1) dfs(v[root].left,index*2);
	if(v[root].right!=-1) dfs(v[root].right,index*2+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	string l,r;
	int ischild[30]={0},root=0;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;l&gt;&gt;r;
		if(l==&quot;-&quot;) v[i].left=-1;
		else {
			v[i].left=stoi(l);
			ischild[v[i].left]=1;
		}
		if(r==&quot;-&quot;) v[i].right=-1;
		else {
			v[i].right=stoi(r);
			ischild[v[i].right]=1;
		}
	}
	while(ischild[root]==1) root++;
	dfs(root,1);
	if(maxn==n) printf(&quot;YES %d&quot;,ans);
    else printf(&quot;NO %d&quot;,root);
	return 0;
} 
</code></pre>
<h3 id="a111130-两次dijkst加dfs最短-最快路径-结点最少路径">A1111(30 两次dijkst加dfs,最短、最快路径、结点最少路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt; 
using namespace std;
const int INF=0x7fffffff;
const int maxn=520;
int n,m,st,ed,e[maxn][maxn],t[maxn][maxn],d[maxn],time[maxn],dispre[maxn],timepre[maxn],fast[maxn],fewnum[maxn];
bool vis[maxn];
vector&lt;int&gt; dispath,timepath;
void dis_dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(fast,fast+maxn,INF);
	for(int i=0;i&lt;n;i++) dispre[i]=i;
	d[s]=0;
	fast[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
        for(int j=0;j&lt;n;j++){
        	if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
        		u=j;
        		MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;e[u][v]!=INF){
				if(d[u]+e[u][v]&lt;d[v]){
					d[v]=d[u]+e[u][v];
					fast[v]=fast[u]+t[u][v];
					dispre[v]=u;
				}else if(d[u]+e[u][v]==d[v]&amp;&amp;fast[v]&gt;fast[u]+t[u][v]){
					fast[v]=fast[u]+t[u][v];
					dispre[v]=u;
				}
			}
		} 
	}
}
void time_dijkst(int s){
	fill(time,time+maxn,INF);
	fill(vis,vis+maxn,false);
	time[s]=0;
	fewnum[s]=1;
	for(int i=0;i&lt;n;i++) timepre[i]=i;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
        for(int j=0;j&lt;n;j++){
        	if(vis[j]==false&amp;&amp;time[j]&lt;MIN){
        		u=j;
        		MIN=time[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;t[u][v]!=INF){
				if(time[v]&gt;time[u]+t[u][v]){
					time[v]=time[u]+t[u][v];
					timepre[v]=u;
					fewnum[v]=fewnum[u]+1;
				}else if(time[v]==time[u]+t[u][v]&amp;&amp;fewnum[v]&gt;fewnum[u]+1){
					timepre[v]=u;
					fewnum[v]=fewnum[u]+1;
				}
			}
		}
	}
}
void dis_dfs(int ed){
	dispath.push_back(ed);
	if(ed==st) return;
	dis_dfs(dispre[ed]);
}
void time_dfs(int ed){
	timepath.push_back(ed);
	if(ed==st) return;
	time_dfs(timepre[ed]);
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int v1,v2,flag,len,ti;
	fill(e[0],e[0]+maxn*maxn,INF);
	fill(t[0],t[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d%d%d%d&quot;,&amp;v1,&amp;v2,&amp;flag,&amp;len,&amp;ti);
		e[v1][v2]=len;
		t[v1][v2]=ti;
		if(flag!=1){
			e[v2][v1]=len;
			t[v2][v1]=ti;
		}
	}
	scanf(&quot;%d%d&quot;,&amp;st,&amp;ed);
	dis_dijkst(st);
	time_dijkst(st);
	dis_dfs(ed);
	time_dfs(ed);
	if(dispath==timepath){
		printf(&quot;Distance = %d; Time = %d: &quot;,d[ed],time[ed]);
		for(int i=dispath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,dispath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
	}else{
		printf(&quot;Distance = %d: &quot;,d[ed]);
		for(int i=dispath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,dispath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
		printf(&quot;\n&quot;);
		printf(&quot;Time = %d: &quot;,time[ed]);
		for(int i=timepath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,timepath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a111220-字符串-找出坏键">A1112(20 字符串、找出“坏键”)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	map&lt;char,bool&gt; mp,hasprint;
	string s,ans;
	int k,cnt=1;
	scanf(&quot;%d\n&quot;,&amp;k);
	cin&gt;&gt;s;
	s=&quot;*&quot;+s+&quot;*&quot;;
	for(int i=1;i&lt;s.length();i++){
		if(s[i]==s[i-1]) cnt++;
		else{
			if(cnt%k!=0) mp[s[i-1]]=true;
			cnt=1;
		}
	}
	for(int i=1;i&lt;s.length()-1;i++){
		ans+=s[i];
		if(mp[s[i]]!=true){
			if(hasprint.count(s[i])!=true){
				cout&lt;&lt;s[i];
		     	hasprint[s[i]]=true;
			}
			i+=k-1;
		}
	}
	cout&lt;&lt;endl&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a111325-水题">A1113(25 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,s=0,s1=0;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt;v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n;i++){
		if(i&lt;n/2) s1+=v[i];
		s+=v[i];
	}
	printf(&quot;%d %d&quot;,n%2==0? 0:1,s-s1*2);
	return 0;
}
</code></pre>
<h3 id="a1114-25-并查集">A1114 (25 并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt; 
using namespace std;
int n,father[10001],family[10001],exist[10001];
struct node{
	int sets,area;
}v[10001];
struct fam{
	int id,num=0;
	double avgset=0, avgarea=0;
}f[10001];
bool cmp(fam a,fam b){
	return a.avgarea!=b.avgarea ? a.avgarea&gt;b.avgarea : a.id&lt;b.id;
}
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
}
void Union(int a,int b){
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA&gt;faB) father[faA]=faB;
	else if(faA&lt;faB) father[faB]=faA;
}
int main(){
	set&lt;int&gt; ans;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;10001;i++) father[i]=i;
	for(int i=0;i&lt;n;i++){
		int id,fa,mo,k,childid;
		scanf(&quot;%d%d%d%d&quot;,&amp;id,&amp;fa,&amp;mo,&amp;k);
		exist[id]=1;
		if(fa!=-1){
			exist[fa]=1;
			Union(id,fa);
		} 
		if(mo!=-1) {
			Union(id,mo);;
			exist[mo]=1;
		}
		while(k--){
		 	scanf(&quot;%d&quot;,&amp;childid);
		 	exist[childid]=1;
		 	Union(id,childid);
		} 
		scanf(&quot;%d%d&quot;,&amp;v[id].sets,&amp;v[id].area);
	}
	for(int i=0;i&lt;10001;i++){
		if(exist[i]==1){
			ans.insert(findfather(i));
			f[findfather(i)].id=findfather(i);
			f[findfather(i)].num++;
			f[findfather(i)].avgset+=v[i].sets;
			f[findfather(i)].avgarea+=v[i].area;
		}
	}
	for(auto it=ans.begin();it!=ans.end();it++){
		f[*it].avgarea=f[*it].avgarea/f[*it].num;
		f[*it].avgset=f[*it].avgset/f[*it].num;
	} 
	sort(f,f+10001,cmp);
	printf(&quot;%d\n&quot;,ans.size());
	for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %d %.3f %.3f\n&quot;,f[i].id,f[i].num,f[i].avgset,f[i].avgarea);
	return 0;
}
</code></pre>
<h3 id="a111530-二叉搜索树建立与dfs">A1115(30 二叉搜索树建立与DFS)</h3>
<pre><code>#include&lt;cstdio&gt;
struct node{
	int v;
	node*left,*right;
};
int maxlevel=-1,level=0,n1=0,n2=0;
void insert(node *&amp;root,int v){
	level++;
	if(root==NULL){
		root=new node;
		root-&gt;v=v;
		root-&gt;left=root-&gt;right=NULL;
		if(maxlevel&lt;level) maxlevel=level;
		level=0;
		return;
	}
	if(v&lt;=root-&gt;v) insert(root-&gt;left,v);
	else insert(root-&gt;right,v);
}
void dfs(node*root,int level){
	if(root==NULL) return;
	if(level==maxlevel) n1++;
	else if(level==maxlevel-1) n2++;
	dfs(root-&gt;left,level+1);
	dfs(root-&gt;right,level+1);
}
int main(){
	int n,a;
	node*root=NULL;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		insert(root,a);
	}
	dfs(root,1);
	printf(&quot;%d + %d = %d&quot;,n1,n2,n1+n2);
	return 0;
}
</code></pre>
<h3 id="a111620-水题">A1116(20 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
using namespace std;
bool isprime(int x){
	if(x&lt;=1) return false;
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int n,temp,k;
	scanf(&quot;%d&quot;,&amp;n);
	map&lt;int,int&gt; mp,hascheck;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		mp[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;temp);
		if(mp.count(temp)==0) printf(&quot;%04d: Are you kidding?\n&quot;,temp);
		else{
			if(hascheck.count(temp)==0){
			hascheck[temp]=1;
			if(mp[temp]==1) printf(&quot;%04d: Mystery Award\n&quot;,temp);
	     	else if(isprime(mp[temp])) printf(&quot;%04d: Minion\n&quot;,temp);
	     	else printf(&quot;%04d: Chocolate\n&quot;,temp);
		 }
		else printf(&quot;%04d: Checked\n&quot;,temp);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a111725-逻辑题">A1117(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100010]={0},n,j=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n,greater&lt;int&gt;());
    while(j&lt;n&amp;&amp;a[j]&gt;j+1) j++;
	printf(&quot;%d&quot;,j);
	return 0;
}
</code></pre>
<h3 id="a111825-并查集">A1118(25 并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
int n,father[10006],tree[10006]={0};
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
} 
void Union(int a,int b){
	int fa=findfather(a);
	int fb=findfather(b);
	if(fa!=fb) father[fa]=fb;
}
int main(){
	int k,q,t,temp,num=0;
	scanf(&quot;%d&quot;,&amp;n);
	set&lt;int&gt; birds;
	for(int i=0;i&lt;10006;i++) father[i]=i;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;k,&amp;t);
		birds.insert(t);
		for(int j=0;j&lt;k-1;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			birds.insert(temp);
			Union(temp,t);
		}
	}
	for(auto it=birds.begin();it!=birds.end();it++)	tree[findfather(*it)]++;
	for(int i=0;i&lt;10006;i++){
		if(tree[i]!=0) num++;
	}
	printf(&quot;%d %d\n&quot;,num,birds.size());
	scanf(&quot;%d&quot;,&amp;q);
	while(q--){
		scanf(&quot;%d%d&quot;,&amp;t,&amp;temp);
		if(findfather(t)==findfather(temp)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
} 
</code></pre>
<h3 id="a1119-30-树的前序和后序-求中序">A1119 (30 树的前序和后序 求中序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,post[31],pre[30],num=0;
bool unique=true;
struct node{
	int v;
	node*left,*right;
};
node* create(int prel,int prer,int postl,int postr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;v=pre[prel];//每次取先序序列的第一个为根节点
	int k=prel+1;
	while(k&lt;=prer&amp;&amp;pre[k]!=post[postr-1]) k++;
	if(prel+1&lt;n&amp;&amp;postr-1&gt;=0&amp;&amp;pre[prel+1]==post[postr-1]) unique=false;
	//如果先序序列的第二个元素等于后序序列的倒数第二个元素，说明树的个数不唯一，因为无法确定该结点属于左子树还是右子树
	int numleft=k-prel-1;
	root-&gt;left=create(prel+1,k-1,postl,postl+numleft-1);
	root-&gt;right=create(k,prer,postl+numleft,postr-1);//如果树的个数不唯一，假设该不确定节点属于右子树
	return root;
}
void inorder(node*root){
	if(root==NULL) return;
	inorder(root-&gt;left);
    if(num&gt;0) printf(&quot; &quot;);
	printf(&quot;%d&quot;,root-&gt;v);
	num++;
	inorder(root-&gt;right);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=NULL;
	root=create(0,n-1,0,n-1);
	if(unique) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	inorder(root);
    printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a112020-水题">A1120(20 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=10010;
int main(){
	int n,sum[maxn]={0};
	string str;
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	bool flag[maxn]={false};
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;str;
		int len=str.size();
		for(int j=0;j&lt;len;j++){
			sum[i]+=(str[j]-'0');
		}
	}
	for(int i=0;i&lt;n;i++) ans.insert(sum[i]);
	printf(&quot;%d\n&quot;,ans.size());
	for(auto it=ans.begin();it!=ans.end();it++) {
		if(it!=ans.begin()) printf(&quot; %d&quot;,*it);
		else printf(&quot;%d&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1121-25-map-set应用">A1121 (25 map、set应用)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
bool flag[100000] = { false };
map&lt;int, int&gt;couple;
int main() {
	int n, m, p1, p2;
	set&lt;int&gt; ans;
	vector&lt;int&gt; guests;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%d%d&quot;, &amp;p1, &amp;p2);
		couple[p1] = p2;
		couple[p2] = p1;
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;p1);
		guests.push_back(p1);
		flag[p1] = true;
	}
	for (int i = 0; i &lt; guests.size(); i++) {
		if (couple.count(guests[i])==0||(flag[couple[guests[i]]]==false)&amp;&amp; couple.count(guests[i]) != 0) ans.insert(guests[i]);
	}
	printf(&quot;%d\n&quot;, ans.size());
	for (auto it = ans.begin(); it != ans.end(); it++) {
		if (it != ans.begin()) printf(&quot; &quot;);
		printf(&quot;%05d&quot;, *it);
	}
	return 0;
}
</code></pre>
<h3 id="a112225-哈密顿回路-set">A1122(25 哈密顿回路  set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,c1,c2,g[210][210];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		g[c1][c2]=1;
		g[c2][c1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int num,flag1=1,flag2=1;
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		set&lt;int&gt; s;
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);	
			s.insert(v[i]);
		}	
		if(num-1!=n||s.size()!=n||v[0]!=v[num-1]) flag1=0;
		for(int i=0;i&lt;num-1;i++){
			if(g[v[i]][v[i+1]]!=1) flag2=0;
		}
		if(flag1==1&amp;&amp;flag2==1) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a112330-avl-层序遍历-判断是否是完全二叉树">A1123(30 AVL 、层序遍历、判断是否是完全二叉树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v,height;
	node* left,*right;
};
node* newnode(int v){
	node* Node=new node;
	Node-&gt;v=v;
	Node-&gt;left=Node-&gt;right=NULL;
	Node-&gt;height=1;
	return Node;
}
int getheight(node *root){
	if(root==NULL) return 0;
	return root-&gt;height;
}
void updateheight(node *root){
	root-&gt;height=max(getheight(root-&gt;left),getheight(root-&gt;right))+1;
}
int getbalance(node *root){
	return getheight(root-&gt;left)-getheight(root-&gt;right);
}
void R(node*&amp;root){
	node*temp=root-&gt;left;
	root-&gt;left=temp-&gt;right;
	temp-&gt;right=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void L(node*&amp;root){
    node*temp=root-&gt;right;
	root-&gt;right=temp-&gt;left;
	temp-&gt;left=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void insert(node*&amp;root,int v){
	if(root==NULL){
		root=newnode(v);
		return;
	}
	if(root-&gt;v&gt;v){
		insert(root-&gt;left,v);
		updateheight(root);
		if(getbalance(root)==2){
			if(getbalance(root-&gt;left)==1){
				R(root);
			}else if(getbalance(root-&gt;left)==-1){
				L(root-&gt;left);
				R(root);
			}
		}
	}else{
		insert(root-&gt;right,v);
		updateheight(root);
		if(getbalance(root)==-2){
			if(getbalance(root-&gt;right)==-1){
				L(root);
			}else if(getbalance(root-&gt;right)==1){
				R(root-&gt;right);
				L(root);
			}
		}
	}
}
int iscomplete=1,after=0,n,num=0;
void layerorder(node*root){
	queue&lt;node*&gt;q;
	q.push(root);
	while(!q.empty()){
		node* t=q.front();
		q.pop();
		if(num&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,t-&gt;v);
		num++;
		if(t-&gt;left!=NULL){
			if(after) iscomplete=0;
			q.push(t-&gt;left);
		}else after=1;
		if(t-&gt;right!=NULL){
			if(after) iscomplete=0;
			q.push(t-&gt;right);
		}else after=1;
	}
}
int main(){
	int temp;
	scanf(&quot;%d&quot;,&amp;n);
	node*root=NULL;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		insert(root,temp);
	}
	layerorder(root);
	if(iscomplete) printf(&quot;\nYES&quot;);
	else printf(&quot;\nNO&quot;);
	return 0;
}
</code></pre>
<h3 id="a1124-20-逻辑题">A1124  20 逻辑题</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int m,n,s;
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
	vector&lt;string&gt; v(m+1);
	map&lt;string,bool&gt; win;
	for(int i=1;i&lt;=m;i++)	cin&gt;&gt;v[i];
	if(s&gt;m) cout&lt;&lt;&quot;Keep going...&quot;;
	else{
		for(int i=s;i&lt;=m;i++){
			if(win.count(v[i])==0){
				win[v[i]]=true;
				cout&lt;&lt;v[i]&lt;&lt;endl;
				i+=n-1;
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112525-贪心-排序">A1125(25 贪心 排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
	sort(v.begin(),v.end());
	double seg=v[0];
	for(int i=0;i&lt;n-1;i++) seg=(seg+v[i+1])/2;
	printf(&quot;%d&quot;,(int)seg);
	return 0;
}
</code></pre>
<h3 id="a112625-欧拉图-欧拉回路-欧拉路径">A1126(25 欧拉图 欧拉回路 欧拉路径)</h3>
<pre><code>#include&lt;cstdio&gt;
int g[510][510],degree[510]={0},n,m;
bool vis[510]={false};
void dfs(int u){
	vis[u]=true;
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false&amp;&amp;g[u][i]==1){
			dfs(i);
		}
	}
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int v1,v2,evennum=0,block=0;
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
		degree[v1]++;
		degree[v2]++;
	}
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,degree[i]);
		if(degree[i]%2==0) evennum++;
	}
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			dfs(i);
			block++;
		}	
	}
	if(block==1&amp;&amp;evennum==n) printf(&quot;\nEulerian&quot;);
	else if(block==1&amp;&amp;evennum==n-2) printf(&quot;\nSemi-Eulerian&quot;);
	else printf(&quot;\nNon-Eulerian&quot;);
	return 0;
}
</code></pre>
<h3 id="a112730-中序后序建树dfs输出z字形层序遍历">A1127(30 中序后序建树，dfs，输出z字形层序遍历)</h3>
<pre><code>方法一:层序遍历用结构体统计每层结点
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
int n,post[31],in[31];
vector&lt;int&gt; level[35];
struct node{
	int v,depth;
	node* left,*right;
};
node* create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;v=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root; 
}
void bfs(node*root){
	queue&lt;node&gt; q;
	q.push(node{root-&gt;v,1,root-&gt;left,root-&gt;right});
	while(!q.empty()){
		node t=q.front();
		q.pop();
		level[t.depth].push_back(t.v);
		if(t.left!=NULL) q.push(node{t.left-&gt;v,t.depth+1,t.left-&gt;left,t.left-&gt;right});
		if(t.right!=NULL) q.push(node{t.right-&gt;v,t.depth+1,t.right-&gt;left,t.right-&gt;right});
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=create(0,n-1,0,n-1);
	bfs(root);
	printf(&quot;%d&quot;,root-&gt;v);
	for(int i=2;i&lt;35;i++){
		if(i%2==0){
			for(int j=0;j&lt;level[i].size();j++) printf(&quot; %d&quot;,level[i][j]);
		}else{
			for(int j=level[i].size()-1;j&gt;=0;j--) printf(&quot; %d&quot;,level[i][j]);
		}
	}
	return 0;
}


方法二:层序遍历用当前队列的元素个数统计每层节点
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
int n,post[31],in[31],depth=1;
vector&lt;int&gt; level[31];
struct node{
	int v;
	node* left,*right;
};
node* create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;v=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root; 
}
void bfs(node*root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		int count=q.size();
		while(count--){
			node* t=q.front();
			q.pop();
			level[depth].push_back(t-&gt;v);
			if(t-&gt;left!=NULL) q.push(t-&gt;left);
			if(t-&gt;right!=NULL) q.push(t-&gt;right);
		}
		depth++;
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=create(0,n-1,0,n-1);
	bfs(root);
	printf(&quot;%d&quot;,root-&gt;v);
	for(int i=2;i&lt;=depth;i++){
		if(i%2==0){
			for(int j=0;j&lt;level[i].size();j++) printf(&quot; %d&quot;,level[i][j]);
		}else{
			for(int j=level[i].size()-1;j&gt;=0;j--) printf(&quot; %d&quot;,level[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112820-n皇后问题">A1128(20  n皇后问题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int k,n,a[1005];
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int flag=1;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		for(int i=2;i&lt;=n;i++){
			for(int j=1;j&lt;i;j++){
				if(a[j]==a[i]||abs(i-j)==abs(a[j]-a[i])){
					flag=0;
					break;
				}
			}
			if(flag==0){
				printf(&quot;NO\n&quot;);
				break;
			}
		}
		if(flag) printf(&quot;YES\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1129-25-set的应用-结构体内运算符重载">A1129 (25 set的应用 结构体内运算符重载)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int id,fre;
};
bool operator &lt; (const node &amp;a,const node &amp;b){
	return a.fre!=b.fre? a.fre&gt;b.fre : a.id&lt;b.id;
}
int main(){
	int n,k,item,times[50005]={0};
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	set&lt;node&gt; s; 
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;item);
		if(i!=0){
			int j=0;
			printf(&quot;%d:&quot;,item);
			for(auto it=s.begin();j&lt;k&amp;&amp;it!=s.end();it++,j++) printf(&quot; %d&quot;,*it);
			printf(&quot;\n&quot;);
		}
		auto it=s.find(node{item,times[item]});
		times[item]++;
		if(it!=s.end()) s.erase(it);
		s.insert(node{item,times[item]});
	}
	return 0;
}
</code></pre>
<h3 id="a1130中序遍历二叉树-输出中缀表达式">A1130(中序遍历二叉树 输出中缀表达式)</h3>
<pre><code>//中序遍历可以得到中缀表达式
//如果不是叶节点且不是根节点就加括号
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node{
	string v;
	int left,right;
}tree[21];
string ans;
int n,l,r,notroot[21]={0},root=1;
void inorder(int index){
	bool flag=false;
	if((tree[index].left!=-1||tree[index].right!=-1)&amp;&amp;index!=root){
		flag=true;
		ans+=&quot;(&quot;;
	}
	if(tree[index].left!=-1) inorder(tree[index].left);
	ans+=tree[index].v;
	if(tree[index].right!=-1) inorder(tree[index].right);
	if(flag) ans+=&quot;)&quot;;
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tree[i].v&gt;&gt;tree[i].left&gt;&gt;tree[i].right;
		if(tree[i].left!=-1) notroot[tree[i].left]=1;
		if(tree[i].right!=-1) notroot[tree[i].right]=1;
	}
	while(notroot[root]!=0) root++;
	inorder(root);
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a113130-dfs-unordered_map邻接矩阵-难题">A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
vector&lt;vector&lt;int&gt; &gt; v(10000);
int visit[10000] = { 0 }, mincnt, mintransfer, st, ed;
unordered_map&lt;int, int&gt; line;
vector&lt;int&gt; path, temppath;
int transfercnt(vector&lt;int&gt; a) {
	int cnt = -1, preline = 0;
	for (int i = 1; i &lt; a.size(); i++) {
		if (line[a[i - 1] * 10000 + a[i]] != preline) cnt++;
		preline = line[a[i - 1] * 10000 + a[i]];
	}
	return cnt;
}
void dfs(int node, int cnt) {
	if (node == ed &amp;&amp; (cnt &lt; mincnt || (cnt == mincnt &amp;&amp; transfercnt(temppath) &lt; mintransfer))) {
		mincnt = cnt;
		mintransfer = transfercnt(temppath);
		path = temppath;
    return;
	}
	for (int i = 0; i &lt; v[node].size(); i++) {
		if (visit[v[node][i]] == 0) {
			visit[v[node][i]] = 1;
			temppath.push_back(v[node][i]);
			dfs(v[node][i], cnt + 1);
			visit[v[node][i]] = 0;
			temppath.pop_back();
		}
	}
}
int main() {
	int n, m, pre, temp, k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d&quot;, &amp;m, &amp;pre);
		for (int j = 1; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[pre].push_back(temp);
			v[temp].push_back(pre);
			line[pre * 10000 + temp]=line[temp*10000+pre] = i;
			pre = temp;
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	while (k--) {
		mintransfer = mincnt = 1000000000;
		scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);
		temppath.clear();
		temppath.push_back(st);
		visit[st] = 1;
		dfs(st, 0);
		visit[st] = 0;
		printf(&quot;%d\n&quot;, mincnt);
		int preline = 0, pretransfer = st;
		for (int i = 1; i &lt; path.size(); i++) {
			if (line[path[i - 1] * 10000 + path[i]] != preline) {
				if (preline != 0) printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, path[i - 1]);
				preline = line[path[i - 1] * 10000 + path[i]];
				pretransfer = path[i - 1];
			}
		}
		printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, ed);
	}
	return 0;
}
</code></pre>
<h3 id="a113220-字符串-水题">A1132(20 字符串 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	string s, s1, s2;
	int n, len;
	cin &gt;&gt; n;
	while (n--) {
		cin &gt;&gt; s;
		len = s.size();
		s1 = s.substr(0, len / 2);
		s2 = s.substr(len / 2, len / 2);
		if (stoi(s1) == 0 || stoi(s2) == 0) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else if (stoi(s) % (stoi(s1) * stoi(s2)) == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1133链表-重新排列">A1133(链表  重新排列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int id, data, next;
};
vector&lt;node&gt; v, ans;
int main() {
	node a[100010];
	int begin, n, k;
	int id, data, next;
	scanf(&quot;%d%d%d&quot;, &amp;begin, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;id, &amp;data, &amp;next);
		a[id] = { id,data,next };
	}
	for (; begin != -1; begin = a[begin].next) v.push_back(a[begin]);
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &lt; 0) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt;= 0 &amp;&amp; v[i].data &lt;= k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt; k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; ans.size() - 1; i++) {
		printf(&quot;%05d %d %05d\n&quot;, ans[i].id, ans[i].data, ans[i + 1].id);
	}
	printf(&quot;%05d %d -1&quot;, ans[ans.size() - 1].id, ans[ans.size() - 1].data);
	return 0;
}
</code></pre>
<h3 id="a113425-hash散列">A1134(25 hash散列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,exist[10001];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v[10001];
	for(int i=0;i&lt;m;i++){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[i].push_back(v1);
		v[i].push_back(v2);
	} 
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int num,hashtable[10001]={0},temp,flag=1;
		scanf(&quot;%d&quot;,&amp;num);
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;temp);
			hashtable[temp]=1;
		}
		for(int i=0;i&lt;m;i++){
			if(hashtable[v[i][0]]!=1&amp;&amp;hashtable[v[i][1]]!=1){
				flag=0;
				break;
			}
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a113530-判断红黑树-递归判断">A1135(30 判断红黑树 递归判断)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v;
	node*left,*right;
};
void create(node*&amp;root,int v){
	if(root==NULL){
		root=new node;
		root-&gt;v=v;
		root-&gt;left=root-&gt;right=NULL;
		return;
	}
	if(abs(v)&lt;=abs(root-&gt;v)) create(root-&gt;left,v);
	else create(root-&gt;right,v);
}
bool judge1(node*root){
	if(root==NULL) return true;
	if(root-&gt;v&lt;0){
		if(root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;v&lt;0) return false;
		if(root-&gt;right!=NULL&amp;&amp;root-&gt;right-&gt;v&lt;0) return false;
	}
	return judge1(root-&gt;left)&amp;&amp;judge1(root-&gt;right);
}
int getnum(node*root){
	if(root==NULL) return 0;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	return root-&gt;v&gt;0? max(l,r)+1 :max(l,r);
}
bool judge2(node*root){
	if(root==NULL) return true;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	if(l!=r) return false;
	return judge2(root-&gt;left)&amp;&amp;judge2(root-&gt;right);
}
int main(){
	int k,n,temp;
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		node*root=NULL;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;temp);
			create(root,temp);
		}
		if(root-&gt;v&gt;0&amp;&amp;judge1(root)&amp;&amp;judge2(root)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1136-20-回文串-字符串">A1136 (20 回文串 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
string revs(string s){
	reverse(s.begin(),s.end());
	return s;
}
string add(string s1,string s2){
	string s=s1;
	int carry=0;
	for(int i=s1.size()-1;i&gt;=0;i--){
		s[i]=((s1[i]-'0')+(s2[i]-'0')+carry)%10+'0';
		carry=((s1[i]-'0')+(s2[i]-'0')+carry)/10;
	}
	if(carry&gt;0) s='1'+s;
	return s;
}
int main(){
	string s,rev;
	cin&gt;&gt;s;
	if(s==revs(s)) {
		cout&lt;&lt;s&lt;&lt;&quot; is a palindromic number.&quot;;
		return 0;
	}
	for(int i=1;i&lt;=10;i++){
		string sum=add(s,revs(s));
		cout&lt;&lt;s&lt;&lt;&quot; + &quot;&lt;&lt;revs(s)&lt;&lt;&quot; = &quot;&lt;&lt;sum&lt;&lt;endl;
		s=sum;
		if(s==revs(s)){
			cout&lt;&lt;s&lt;&lt;&quot; is a palindromic number.&quot;;
			break;
		}else{
			if(i==10) cout&lt;&lt;&quot;Not found in 10 iterations.&quot;;
		}
	}
	return 0;
}
</code></pre>
<h3 id="a113725-map-排序">A1137(25 map 排序)</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node {
	string name;
	int gp,gm,gf,g;
};
int p,m,n,index1=1;
map&lt;string,int&gt; mp;
vector&lt;node&gt; v,ans;
bool cmp(node a,node b){
	return a.g!=b.g? a.g&gt;b.g : a.name&lt;b.name;
}
int main() {
	scanf(&quot;%d%d%d&quot;,&amp;p,&amp;m,&amp;n);
	string name;
	int sc;
	for(int i=0; i&lt;p; i++) {
		cin&gt;&gt;name&gt;&gt;sc;
		if(sc&gt;=200){
			v.push_back(node {name,sc,-1,-1,0});
			mp[name]=index1++;
		}
	}
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;name&gt;&gt;sc;
		if(mp[name]!=0) v[mp[name]-1].gm=sc;
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;name&gt;&gt;sc;
		if(mp[name]!=0){
			int id=mp[name]-1;
			v[id].gf=sc;
			if(v[id].gf&gt;=v[id].gm) v[id].g=v[id].gf;
			if(v[id].gf&lt;v[id].gm)	v[id].g=round(0.4*v[id].gm+0.6*v[id].gf);
		}
	}
	for(int i=0;i&lt;v.size();i++){
		if(v[i].g&gt;=60) ans.push_back(v[i]);
	}
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i&lt;ans.size();i++){
		printf(&quot;%s %d %d %d %d\n&quot;,ans[i].name.c_str(),ans[i].gp,ans[i].gm,ans[i].gf,ans[i].g);
	}
	return 0;
}
</code></pre>
<h3 id="a113825-树-前序加中序输出后序">A1138(25 树 前序加中序输出后序)</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
vector&lt;int&gt; pre, in;
bool flag = false;
void postOrder(int prel, int inl, int inr) {
	if (inl &gt; inr || flag == true) return;
	int i = inl;
	while (in[i] != pre[prel]) i++;
	postOrder(prel+1, inl, i-1);
	postOrder(prel+i-inl+1, i+1, inr);
	if (flag == false) {
		printf(&quot;%d&quot;, in[i]);
		flag = true;
	}
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	in.resize(n);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;in[i]);
	postOrder(0, 0, n-1);
	return 0;
}
</code></pre>
<h3 id="a113930-逻辑题-unordered_map">A1139(30 逻辑题 unordered_map)</h3>
<pre><code>#include&lt;unordered_map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int a,b;
};
bool cmp(const node &amp;i,const node &amp;j){
	return i.a!=j.a? i.a&lt;j.a : i.b&lt;j.b;
}
unordered_map&lt;int ,bool&gt; isfri;
int main(){
	int n,m,k,c,d;
	cin&gt;&gt;n&gt;&gt;m;
	string a,b;
	vector&lt;int&gt; v[10000];
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;a&gt;&gt;b;
		if(a.length()==b.length()) {
			v[abs(stoi(a))].push_back(abs(stoi(b)));
			v[abs(stoi(b))].push_back(abs(stoi(a)));
		}
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
	}
	cin&gt;&gt;k;
	while(k--){
		vector&lt;node&gt; ans;
		cin&gt;&gt;c&gt;&gt;d;
		for(int i=0;i&lt;v[abs(c)].size();i++){
			for(int j=0;j&lt;v[abs(d)].size();j++){
				if(v[abs(c)][i]==abs(d)||v[abs(d)][j]==abs(c)) continue;
				if(isfri[v[abs(c)][i]*10000+v[abs(d)][j]]==true) ans.push_back(node{v[abs(c)][i],v[abs(d)][j]});
			}
		}
		sort(ans.begin(),ans.end(),cmp);
		cout&lt;&lt;ans.size()&lt;&lt;endl;
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %04d\n&quot;,ans[i].a,ans[i].b);
	}
	return 0;
}
</code></pre>
<h3 id="a114020-字符串">A1140(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt; 
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	int n,j;
	cin&gt;&gt;s&gt;&gt;n;
	for(int x=1;x&lt;n;x++){
       string ans;
       for(int i=0;i&lt;s.length();i=j){
       	for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
       	ans+=s[i]+to_string(j-i);
	   }
	   s=ans;
	}
	cout&lt;&lt;s;
	return 0;
} 
</code></pre>
<h3 id="a114125-stl-排序">A1141(25 stl、排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node{
	string name;
	double score=0;
	int num=0,fscore=0,rank;
}t[100010];
int index=0;
unordered_map&lt;string,int&gt; mp;
int change(string &amp;s){
	for(int i=0;i&lt;s.size();i++){
		if(isupper(s[i])) s[i]=tolower(s[i]);
	}
	if(mp.count(s)==0) mp[s]=index++;
	return mp[s]; 
}
bool cmp(node a,node b){
	if(a.fscore!=b.fscore) return a.fscore&gt;b.fscore;
	else if(a.num!=b.num) return a.num&lt;b.num;
	else return a.name&lt;b.name;
}
int main(){
	int n;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		string id,code;
		int score,tid;
		cin&gt;&gt;id&gt;&gt;score&gt;&gt;code;
		tid=change(code);
		t[tid].name=code;
		t[tid].num++;
		if(id[0]=='B') t[tid].score+=score/1.5;
		if(id[0]=='A') t[tid].score+=score*1.0;
		if(id[0]=='T') t[tid].score+=score*1.5;
	}
	for(int i=0;i&lt;index;i++) t[i].fscore=(int)(t[i].score);
	sort(t,t+index,cmp);
	cout&lt;&lt;index&lt;&lt;endl;
	t[0].rank=1;
	printf(&quot;%d %s %d %d\n&quot;,t[0].rank,t[0].name.c_str(),t[0].fscore,t[0].num);
	for(int i=1;i&lt;index;i++){
		if(t[i].fscore==t[i-1].fscore) t[i].rank=t[i-1].rank;
		else t[i].rank=i+1;
		printf(&quot;%d %s %d %d\n&quot;,t[i].rank,t[i].name.c_str(),t[i].fscore,t[i].num);
	}
	return 0;
}
</code></pre>
<h3 id="a114225-无向完全图-最大子图-两点相连">A1142(25 无向完全图 最大子图  两点相连)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int nv,ne,m,k,g[210][210],v1,v2;
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	for(int i=0;i&lt;ne;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;m);
	while(m--){
		int isclique=1,ismax=1,hash[210]={0};
		scanf(&quot;%d&quot;,&amp;k);
		vector&lt;int&gt; v(k);
		for(int i=0;i&lt;k;i++) {
			scanf(&quot;%d&quot;,&amp;v[i]);
			hash[v[i]]=1;
		}
		for(int i=0;i&lt;k-1;i++){
			if(isclique==0) break;
			for(int j=i+1;j&lt;k;j++){
				if(g[v[i]][v[j]]!=1){
					isclique=0;
					printf(&quot;Not a Clique\n&quot;);
				    break;
				}
			}
		}
		if(isclique==0) continue;
		for(int i=1;i&lt;=nv;i++){
			if(ismax==0) break;
			if(hash[i]!=1){
				for(int j=0;j&lt;k;j++){
					if(g[i][v[j]]==1){
						if(j==k-1) ismax=0;
					}else break;
				}
			}
		}
		if(ismax==1) printf(&quot;Yes\n&quot;);
		else printf(&quot;Not Maximal\n&quot;);
	} 
	return 0;
}
</code></pre>
<h3 id="a114330-树-lca-最低公共祖先">A1143(30 树 LCA 最低公共祖先)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;unordered_map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int m,n,u,v,ans;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	unordered_map&lt;int,bool&gt;mp;
	vector&lt;int&gt; pre(n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;pre[i]);
		mp[pre[i]]=true;
	}
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		for(int j=0;j&lt;n;j++){
			if((pre[j]&gt;=u&amp;&amp;pre[j]&lt;=v)||(pre[j]&lt;=u&amp;&amp;pre[j]&gt;=v)){
				ans=pre[j];
				break;
			}
		}
		if(mp.count(u)==0&amp;&amp;mp.count(v)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,u,v);
		else if(mp.count(u)==0&amp;&amp;mp.count(v)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,u);
		else if(mp.count(v)==0&amp;&amp;mp.count(u)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,v);
		else if(ans==u||ans==v) printf(&quot;%d is an ancestor of %d.\n&quot;,ans,ans==u?v:u);
		else printf(&quot;LCA of %d and %d is %d.\n&quot;,u,v,ans);
	}
	return 0;
}
</code></pre>
<h3 id="a114525-hash-平方探查">A1145(25 hash 平方探查)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x){
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,a;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		int flag=0;
		for(int j=0;j&lt;msize;j++){
			int pos=(a+j*j)%msize;
			if(v[pos]==0){
				flag=1;
				v[pos]=a;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,a);
	}
	int cnt=0,temp;
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//注意这里的&lt;=，因为要回到初始的位置才知道是否能插入
			cnt++;
			if(v[(temp+j*j)%msize]==temp||v[(temp+j*j)%msize]==0) break;
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
    return 0;
}
</code></pre>
<h3 id="a114420-找丢失的最小正数">A1144(20 找丢失的最小正数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int n,ans=1,temp;
    map&lt;int,int&gt; mp;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;temp;
		if(temp&gt;0) mp[temp]++;
	}
	while(mp[ans]!=0) ans++;
	cout&lt;&lt;ans;
	return 0;
} 
</code></pre>
<h3 id="a114525-hash-平方探查法插入与查找">A1145(25 hash 平方探查法插入与查找)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,temp,cnt=0;;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize,0);//注意初始化数组元素
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		int flag=0;
		for(int j=0;j&lt;msize;j++){//注意是小于号 
			int pos=(temp+j*j)%msize;
			if(v[pos]==0){
				v[pos]=temp;
				flag=1;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,temp);
	}
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//注意这里是等号,与插入时不同，要回到初始位置才知道查找失败 
			int pos=(temp+j*j)%msize;
			cnt++;
			if(v[pos]==temp||v[pos]==0) break;//找到或没找到
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
}
</code></pre>
<h3 id="a114625-判断是否为拓扑排序序列">A1146(25 判断是否为拓扑排序序列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,in[1001]={0},flag=0,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v[1001];
	for(int i=0;i&lt;m;i++){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[v1].push_back(v2);
		in[v2]++;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int i=0;i&lt;k;i++){
		vector&lt;int&gt; tin(in,in+n+1);
		int judge=1;
		for(int j=0;j&lt;n;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			if(tin[temp]!=0) judge=0;
			for(int x=0;x&lt;v[temp].size();x++) tin[v[temp][x]]--;
		}
		if(judge==1) continue;
		if(flag==1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,i);
		flag=1;	
	}
	return 0;
} 
</code></pre>
<h3 id="a114730-判断大顶堆小顶堆-后序遍历">A1147(30  判断大顶堆小顶堆 后序遍历)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int m, n, num = 0;
vector&lt;int&gt;v;
void dfs(int index) {//后序遍历
	if (index &gt; n) return;
	dfs(index * 2);
	dfs(index * 2 + 1);
	printf(&quot;%d&quot;, v[index]);
	if (num &lt; n - 1)printf(&quot; &quot;);
	num++;
}
int main() {
	scanf_s(&quot;%d%d&quot;, &amp;m, &amp;n);
	while (m--) {
		v.resize(n+1);
		bool flagmin = true, flagmax = true;
		for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
		for (int i = 2; i &lt;= n; i++) {
			if (v[i] &gt;= v[i / 2]) flagmax = false;
			if (v[i] &lt;= v[i / 2]) flagmin = false;
		}
		if (flagmin) printf(&quot;Min Heap\n&quot;);
		else if (flagmax) printf(&quot;Max Heap\n&quot;);
		else if (flagmax == false &amp;&amp; flagmin == false) printf(&quot;Not Heap\n&quot;);
		dfs(1);
		num = 0;
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1148狼人杀-找到两个狼人">A1148(狼人杀 找到两个狼人)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];
	for(int i=1;i&lt;=n;i++){
		for(int j=i+1;j&lt;=n;j++){
			vector&lt;int&gt; lie,a(n+1,1);
			a[i]=a[j]=-1;
			for(int k=1;k&lt;=n;k++){
				if(v[k]*a[abs(v[k])]&lt;0) lie.push_back(k);
			}
			if(lie.size()==2&amp;&amp;a[lie[0]]+a[lie[1]]==0){
				cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;No Solution&quot;;
	return 0;
} 
</code></pre>
<h3 id="a114925-map">A1149(25 map)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,g1,g2,num;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	map&lt;int,vector&lt;int&gt; &gt; mp;
	while(n--){
		scanf(&quot;%d%d&quot;,&amp;g1,&amp;g2);
		mp[g1].push_back(g2);
		mp[g2].push_back(g1);
	}
	while(m--){
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		int exist[100005]={0},flag=1;
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			exist[v[i]]=1;
		}
		for(int i=0;i&lt;num;i++){
			for(int j=0;j&lt;mp[v[i]].size();j++){
				 if(exist[mp[v[i]][j]]==1){
				    printf(&quot;No\n&quot;);
				    flag=0;
				    break;
			    }
			}
			if(flag==0) break;
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115025-判断循环图-输出最小路径">A1150(25 判断循环图 输出最小路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,dis[210][210]={0},mindis=0x7fffffff,ansid;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	while(m--){
		int c1,c2,d;
		scanf(&quot;%d%d%d&quot;,&amp;c1,&amp;c2,&amp;d);
		dis[c1][c2]=dis[c2][c1]=d;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int x=1;x&lt;=k;x++){
		int num,total=0,flag=1;
		scanf(&quot;%d&quot;,&amp;num);
		set&lt;int&gt; s;
		vector&lt;int&gt; v(num);
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			s.insert(v[i]);
		}
		for(int i=0;i&lt;num-1;i++){
			if(dis[v[i]][v[i+1]]==0){
				flag=0;
				break;
			}
			total+=dis[v[i]][v[i+1]];
		} 
		printf(&quot;Path %d:&quot;,x);
		if(flag==0) printf(&quot; NA &quot;);
		else printf(&quot; %d &quot;,total);
		if(v[0]!=v[num-1]||s.size()!=n||flag==0) printf(&quot;(Not a TS cycle)\n&quot;);
		else if(num-1==n&amp;&amp;s.size()==n&amp;&amp;v[0]==v[num-1]){
			if(total&lt;mindis) {
			    mindis=total;
		     	ansid=x;
		    }
			printf(&quot;(TS simple cycle)\n&quot;);
		} 
		else if(num-1!=n&amp;&amp;s.size()==n&amp;&amp;v[0]==v[num-1]){
			if(total&lt;mindis) {
			    mindis=total;
		     	ansid=x;
		    }
		    printf(&quot;(TS cycle)\n&quot;);
		} 
	}
	printf(&quot;Shortest Dist(%d) = %d&quot;,ansid,mindis);
	return 0;
}
</code></pre>
<h3 id="a115130-树-中序加先序求lca">A1151(30  树 中序加先序求LCA)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10010;
map&lt;int,int&gt; pos;
vector&lt;int&gt; ins,pre;
void lca(int inl,int inr,int preroot,int a,int b){
	if(inl&gt;inr) return;
	int inroot=pos[pre[preroot]],ain=pos[a],bin=pos[b];
	if(ain&lt;inroot&amp;&amp;bin&lt;inroot) lca(inl,inroot-1,preroot+1,a,b);
	else if((ain&lt;inroot&amp;&amp;bin&gt;inroot)||(ain&gt;inroot&amp;&amp;bin&lt;inroot)){
		printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,ins[inroot]);
	}
	else if(ain&gt;inroot&amp;&amp;bin&gt;inroot) lca(inroot+1,inr,preroot+1+(inroot-inl),a,b);
	else if(ain==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);
	else if(bin==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);
}
int main(){
	int m,n,a,b;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	ins.resize(n + 1), pre.resize(n + 1);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;ins[i]);
		pos[ins[i]]=i;
	}
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,a);
		if(pos.count(b)==0&amp;&amp;pos.count(a)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);
		if(pos.count(a)!=0&amp;&amp;pos.count(b)!=0) lca(1,n,1,a,b);
	}
	return 0;
}

方法二:建树加dfs
#include&lt;cstdio&gt;
#include&lt;unordered_map&gt;
using namespace std;
const int maxn=10010;
int in[maxn],pre[maxn];
struct node{
	int v;
	node*left,*right;
};
node* create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;v=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;right=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
node* lca(node*root,int a,int b){
	if(root==NULL||root-&gt;v==a||root-&gt;v==b) return root;
	node*l=lca(root-&gt;left,a,b);
	node*r=lca(root-&gt;right,a,b);
	if(l==NULL) return r;
	if(r==NULL) return l;
	return root;
}
int main(){
	int m,n,u,v,res;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	unordered_map&lt;int,bool&gt;mp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;in[i]);
		mp[in[i]]=true;
	}
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	node*root=create(0,n-1,0,n-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		if(mp.count(u)==0&amp;&amp;mp.count(v)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,u,v);
		else if(mp.count(u)==0&amp;&amp;mp.count(v)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,u);
		else if(mp.count(v)==0&amp;&amp;mp.count(u)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,v);
		else{
			node*ans=lca(root,u,v);
			res=ans-&gt;v;
			if(res==u||res==v) printf(&quot;%d is an ancestor of %d.\n&quot;,res,res==u?v:u);
		    else printf(&quot;LCA of %d and %d is %d.\n&quot;,u,v,res);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a115220-字符串中找第一个k位素数">A1152(20 字符串中找第一个k位素数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(string s){
	if(stoi(s)&lt;=1) return false;
	int sqr=sqrt(stoi(s));
	for(int i=2;i&lt;=sqr;i++){
		if(stoi(s)%i==0) return false;
	}
	return true;
}
int main(){
	int l,k;
    string s;
	cin&gt;&gt;l&gt;&gt;k&gt;&gt;s;
	for(int i=0;i&lt;s.size();i++){
		if(i+k&lt;=s.size()){
			string t=s.substr(i,k);
			if(isprime(t)){
				cout&lt;&lt;t;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;404&quot;;
	return 0;
}
</code></pre>
<h3 id="a115325-模拟-排序引用传参-unordered_map">A1153(25 模拟 排序引用传参  unordered_map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	string info;
	int score;
};
bool cmp(const node&amp; a, const node&amp; b) {
	return a.score != b.score ? a.score &gt; b.score : a.info &lt; b.info;
}
int main() {
	int n, m, type;
	string t;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; v(n);
	for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].info &gt;&gt; v[i].score;
	for (int i = 1; i &lt;= m; i++) {
		vector&lt;node&gt; ans;
		cin &gt;&gt; type &gt;&gt; t;
		printf(&quot;Case %d: %d %s\n&quot;, i, type, t.c_str());
		int sum = 0, cnt = 0;
		if (type == 1) {
			for (int j = 0; j &lt; n; j++) {
				if (t[0] == v[j].info[0]) ans.push_back(v[j]);
			}
		}
		else if (type == 2) {
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(1, 3) == t) {
					cnt++;
					sum += v[j].score;
				}
			}
			if (cnt != 0) printf(&quot;%d %d\n&quot;, cnt, sum);
		}
		else {
			unordered_map&lt;string, int&gt; m;
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(4, 6) == t) m[v[j].info.substr(1, 3)]++;
			}
			for (auto it : m) ans.push_back({ it.first,it.second });
		}
		sort(ans.begin(), ans.end(), cmp);
		for (int j = 0; j &lt; ans.size(); j++) printf(&quot;%s %d\n&quot;, ans[j].info.c_str(), ans[j].score);
		if (((type == 1 || type == 3) &amp;&amp; ans.size() == 0) || (type == 2 &amp;&amp; cnt == 0)) printf(&quot;NA\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115425-图-边的两端点的判断">A1154(25 图  边的两端点的判断  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
struct node{
	int v1,v2;
};
int main(){
	int n,m,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; v(m);
	vector&lt;int&gt; colo(n);
	for(int i=0;i&lt;m;i++) scanf(&quot;%d%d&quot;,&amp;v[i].v1,&amp;v[i].v2);
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int flag=1;
		set&lt;int&gt; s;
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;colo[i]);
			s.insert(colo[i]);
		}
		for(int i=0;i&lt;m;i++){
			if(colo[v[i].v1]==colo[v[i].v2]){
				flag=0;
				break;
			}
		}
		if(flag==0) printf(&quot;No\n&quot;);
		else printf(&quot;%d-coloring\n&quot;,s.size());
	}
	return 0;
}
</code></pre>
<h3 id="a115530-完全二叉树-判断大顶堆小顶堆-dfs-打印路径">A1155(30 完全二叉树  判断大顶堆小顶堆 dfs  打印路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,t[1005],index;
vector&lt;int&gt; v;
void dfs(int i){
	if(i*2+1&gt;n&amp;&amp;i*2&gt;n){
		if(i&lt;=n){
			for(int i=0;i&lt;v.size();i++){
				if(i&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,v[i]);
			}
			printf(&quot;\n&quot;);
		}
		return;
	}
	v.push_back(t[i*2+1]);
	dfs(i*2+1);
	v.pop_back();
	v.push_back(t[i*2]);
	dfs(i*2);
	v.pop_back();
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	int flagmax=1,flagmin=1;
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]);
	v.push_back(t[1]);
	for(int i=2;i&lt;=n;i++){
		if(t[i]&lt;t[i/2]) flagmin=0;
		if(t[i]&gt;t[i/2]) flagmax=0;
	}
	dfs(1);
	if(flagmin==1) printf(&quot;Min Heap&quot;);
	else if(flagmax==1) printf(&quot;Max Heap&quot;);
	else if(flagmin==0&amp;&amp;flagmax==0) printf(&quot;Not Heap&quot;);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++(PAT)刷题笔记汇总]]></title>
        <id>https://liuxbo.github.io/post/cshua-ti-bi-ji/</id>
        <link href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">
        </link>
        <updated>2020-05-06T13:20:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-c字符串数组的0问题">1. c++字符串数组的\0问题</h3>
<pre><code>#include&lt;stdio.h&gt;
int main() {
	char str1[8] = { 'd','e','d','g','o' };
	char str2[5] = { 'd','e','d','g','o' };
	printf(&quot;%d\n&quot;, sizeof(str1));
	printf(&quot;%d\n&quot;, sizeof(str2));
	return 0;
}
</code></pre>
<p>![](C:\Users\lxb\Pictures\Camera Roll\KG1V`[}F4D7YE5L_NIJ289O.png)</p>
<p>对于字符串数组，当定义时直接对其赋值，无论元素是否占满数组，其储存的字符个数都是数组的元素个数，未占满时会自动用\0补全</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	puts(str);
	return 0;
}
</code></pre>
<p>输出会乱码</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clxb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191205103056228.png" alt="image-20191205103056228" loading="lazy"></figure>
<p>使用<code>getchar</code>要在输入的每个字符串后面加\0,例如</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	str[5] = '\0';
	puts(str);
	return 0;
}
</code></pre>
<h3 id="2数组相关问题">2.数组相关问题</h3>
<ul>
<li>
<p>反转一个一维数组</p>
<pre><code>#include &lt;cstdio&gt;
int main() {
	int a[5] = { 5,2,3,6,9 };
	for (int i = 0, j = 4; i &lt;= j; i++, j--) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	for(int i=0;i&lt;5;i++)
	printf(&quot;%d&quot;, a[i]);
	return 0;
}
</code></pre>
</li>
<li>
<p>找二维(或三维)数组中的“块”(比如相邻的若干个数组元素1)</p>
<p>用BFS，要设置增量数组，</p>
<p>对于一维的情况，可以设置</p>
<pre><code>int X[4]={0,0,1,-1};
int Y[4]={1,-1,0,0};
</code></pre>
<p>以便于访问上下左右四个位置</p>
<p>对于三维的情况，可以设置</p>
<pre><code>int X[6]={0,0,0,0,1,-1};
int Y[6]={0,0,1,-1,0,0};
int Z[6]={1,-1,0,0,0,0};
</code></pre>
<p>对应前后左右上下6个位置</p>
</li>
</ul>
<h3 id="3字符串问题">3.字符串问题</h3>
<ul>
<li>
<p><code>scanf (&quot;%s&quot;)</code>识别空格作为字符串结尾</p>
<p><code>getchar</code>  <code>putchar</code> 用来输入输出单个字符</p>
</li>
<li>
<p><code>cin</code> 读入字符串时，以空格为分隔符，如果想读入一整行字符串，用<code>getline(cin,s)</code>，注意前面如果输入数字n，一定要注意<code>scanf(&quot;%d\n&quot;,&amp;n);</code> 这样写，防止getline读入错误</p>
</li>
<li>
<p>判断两个字符串是否一样时可以用<code>strcmp()==0</code>，该函数其中一个参数可以为字符数组的名称</p>
</li>
<li>
<p>使⽤ <code>stoi()</code> 、 <code>stod()</code>  可以将字符串 string 转化为对应的 int 型、 double 型变量</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//输出123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//输出123.44
 return 0;
}
</code></pre>
<p><code>stoi</code>如果遇到的是⾮法输⼊（⽐如<code>stoi(&quot;123.4&quot;)</code>，123.4不是⼀个int型变量）： 1.会⾃动截取最前⾯的     数字，直到遇到不是数字为⽌ (所以说如果是浮点型，会截取前⾯的整数部分) 2.如果最前⾯不是数字，会运⾏时发⽣错误</p>
<p><code>stod</code>如果是⾮法输⼊： 1.会⾃动截取最前⾯的浮点数，直到遇到不满⾜浮点数为⽌ 2.如果最前⾯不是数字或者⼩数点，会运⾏时发⽣错误 3.如果最前⾯是⼩数点，会⾃动转化后在前⾯补0</p>
<p>不仅有<code>stoi</code>、<code>stod</code>两种，相应的还有：</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
</li>
<li>
<p><code>to_string()</code>将数值转化为字符串。返回对应的字符串。头文件同样为<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  如果想⽤<code>printf</code>输出string，需要加⼀ 个<code>.c_str()</code></p>
</li>
<li>
<p>字符串形式的两个数字相加</p>
<pre><code>string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
<li>
<p>涉及到的题目:</p>
<p>A1035，A1077,A1082,A1093,A1061，<strong>A1073</strong>(科学计数法)，A1077(公共后缀)，<strong>A1082</strong>,</p>
<p>A1112, A1152, A1140  A1136(回文串、字符串) 、 A1132(20 水题)</p>
</li>
</ul>
<h3 id="4中序序列和-后序或先序或层序-搭配-确定一棵二叉树">4.中序序列和 后序或先序或层序 搭配， 确定一棵二叉树</h3>
<ul>
<li>
<p>先由后序序列或先序序列确定根节点</p>
</li>
<li>
<p>利用在先序或后序序列找到的根节点的值，确定中序序列中根节点的位置</p>
</li>
<li>
<p>确定左子树、右子树的 先序/后序  和中序序列（左子树所有节点的个数只能在中序序列中得知）</p>
</li>
<li>
<p>分别向左孩子和右孩子递归构建</p>
<p>注意递归时区间的书写格式</p>
</li>
</ul>
<h3 id="5-映射问题hash-map-散列">5. 映射问题(hash 、map、散列...)</h3>
<ul>
<li>
<p>直接开数组，将数组下标与下标对应的内容作为映射,ASCII码表有128个字符，对于一些题目可以直接开<code>hashtable[128]</code>数组，关于其下标，可以用以下函数获得</p>
<pre><code>int change(char c){
    if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';
    if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'+10;
    if(c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'+36;
}
</code></pre>
</li>
<li>
<p>字符串hash</p>
<ul>
<li>
<pre><code>for(int i = 0; i &lt; 3; i++)  id = 26 * id + (name[i] - 'A'); //大写字母字符串映射为整数
</code></pre>
</li>
</ul>
</li>
<li>
<p>涉及到的题目</p>
<p>A1084,A1092,A1041,A1050，A1048  <strong>A1129(25 set的应用 结构体内运算符重载)</strong></p>
<p>A1145(25 hash 平方探查)</p>
</li>
</ul>
<h3 id="6-stl容器">6. <code>STL</code>容器</h3>
<ul>
<li>
<p>vector</p>
<p>定义一个m行n列的数组 <code>vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n));</code></p>
<pre><code>vector&lt;int&gt; vec1(4,1);              //vec1的内容为1,1,1,1
vector&lt;int&gt; vec1{ 1, 2, 3, 4, 5, 6 };       //vec1内容1,2，3,4,5,6
</code></pre>
<pre><code>vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值
</code></pre>
<pre><code>vector&lt;int&gt; vec(arr, arr + 5);   //将arr数组的元素用于初始化vec向量
//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，
//这个主要是为了和vec.end()指针统一。
</code></pre>
</li>
<li>
<p>priority_queue</p>
<p><code>priority_queue&lt;int,vector &lt; int &gt; ,greater&lt; int&gt; &gt;</code>表示数字越小的优先级越大，优先放在队首</p>
<p><code>priority_queue&lt;int,vector &lt; int &gt; ,less&lt; int&gt; &gt;</code>表示数字越大的优先级越大，优先放在队首，</p>
<p>该容器只能通过top()访问队首元素，push()进队，pop()出队，empty()检空</p>
</li>
<li>
<p>String</p>
<p><code>string &amp;insert(int p0, int n, char c);</code>//在p0处插入n个字符c</p>
<p><code>string &amp;insert(int p0,const string &amp;s);</code>//在p0位置插入字符串s</p>
<p><code>void insert(iterator it, const_iterator first, const_iterator last);</code>  //在it处插入从first开始至last-1的所有字符</p>
</li>
<li>
<p>异同</p>
<p>只有<code>vector</code>和<code>string</code>支持<code>*(it+i)</code>的访问方式 ,<code>set</code>只能通过迭代器访问(即*it)，</p>
<p><code>map</code> 、<code>string</code>和<code>vector</code>支持下标访问和迭代器访问。</p>
<p>map与set内部都会自动递增排序，(这里指map的key），并且set的元素值与map的key在其各自内部都是唯一的，包括数字和字</p>
</li>
<li>
<p>set、unordered_map</p>
<p><code>s.find(value)</code>,返回集合s中值为value的迭代器</p>
</li>
<li>
<p>map 、unordered_map</p>
<p>使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。count(key值)</p>
<p>遍历map中所有的元素<code>for (auto it : mp)</code>,mp为map容器变量名，用<code>it.first</code>和<code>it.second</code>访问每个key和相应的value</p>
<p>find() erase() size() clear()</p>
</li>
<li>
<p>注意</p>
<p>begin()函数返回一个迭代器,指向字符串的第一个元素.</p>
<p>end()函数返回一个迭代器，指向字符串的末尾(最后一个字符的下一个位置).</p>
<p>rbegin()返回一个逆向迭代器，指向字符串的最后一个字符。</p>
<p>rend()函数返回一个逆向迭代器，指向字符串的开头（第一个字符的前一个位置）。</p>
<p>vector数组可以直接用==判断两个数组是否相同</p>
<p>string类型可以直接用&lt;  或 &gt; 或== 直接进行字典序的比较，而char数组必须用strcmp比较</p>
<p>vector使用下标访问前注意先resize一下</p>
<p>set的内部排序可以重载运算符(以存放结构体变量为例)</p>
<pre><code>struct node{
	int id,fre;
};
bool operator &lt; (const node &amp;a,const node &amp;b){
	return a.fre!=b.fre? a.fre&gt;b.fre : a.id&lt;b.id;
}
//set存放的node型变量就会定义的方式排序
</code></pre>
<p>可以考虑 ⽤ unordered_map （或者 unordered_set ）缩短代码运⾏时间、提⾼代码效率</p>
</li>
</ul>
<p>A1039,A1047,A1063,A1060,A1100,A1054，A1071,A1022 A1120 ,A1149(map、vector)</p>
<p>A1121 (25 map、set应用)   A1137(25 map 排序)    A1139(30 逻辑题 unordered_map)</p>
<h3 id="7-输入输出问题">7. 输入输出问题</h3>
<p><code>scanf</code>中 ，<code>long long</code>型 ：<code>scanf(&quot;%lld&quot;,&amp;n)</code> , <code>double</code>型：<code>scanf(&quot;lf&quot;,&amp;n)</code></p>
<p><code>printf</code>中，<code>long long</code> 型：<code>printf(&quot;%lld&quot;,n)</code>   , <code>double</code> 型：<code>printf(&quot;%f&quot;,n)</code></p>
<p>若<code>getline(cin, str);</code>前有<code>scanf(&quot;%d%*c&quot;, &amp;n);</code>输入，可以用%*<em>c忽略一个字符型(比如换行),或者%</em> *d忽略一个数字型。也可以用getchar()吸收掉字符</p>
<p><code>scanf(&quot;%*c%d&quot;,&amp;n);可以吸收掉上一行末尾的的换行符</code></p>
<p>若输入格式为数字<code>空格</code> 字符<code>空格</code> 数字，可以写成<code>scanf(&quot;%d %c %d&quot;)</code> ,因为空格也算字符。</p>
<p>注意string类型用printf输出时一定要用c_str()转化一下</p>
<p><code>sscanf(a, &quot;%lf&quot;, &amp;temp);</code> 从左到右，将<strong>字符数组a</strong>以浮点数的形式存到double类型temp中；</p>
<p><code>sprintf(b, &quot;%.2f&quot;, temp);</code> 从右到左，将double类型temp以保留两位小数的形式存到<strong>字符数组b</strong>中</p>
<h3 id="8-提取数中的元素">8. 提取数中的元素</h3>
<pre><code>while (b != 0) {
		if (b % 10 == db) pb = pb * 10 + db;
		b = b / 10;
	}
提取b中的重复数字组成新的数字 b=38633 ，db为3，新数字为333

//计算某个数所有位上的数字之和  比如数字123的和为6
int getsum(int n){
	int sum=0;
	while(n!=0){
		sum+=n%10;
		n/=10;
	}
	return sum;
}
</code></pre>
<h3 id="9-常用函数">9. 常用函数</h3>
<ul>
<li>
<p><code>math.h</code>头文件函数</p>
<p><code>fabs(double x)</code>  取绝对值 ，</p>
<p><code>floor(double x)</code>和<code>ceil(double x)</code> ，分别为向下取整和向上取整，返回double型</p>
<p><code>pow(double r,double p)</code> 用于返回r^p</p>
<p><code>sqrt(double x)</code> ,返回算数平方根</p>
<p><code>log(double x)</code> ,返回以自然对数为底的对数，用换底公式求具体对数</p>
<p><code>sin(double x)</code> <code>cos(double x)</code> <code>tan(double x)</code></p>
<p><code>asin(double x)</code> <code>acos(double x)</code> <code>atan(double x)</code></p>
<p><code>round(double x)</code> 将x四舍五入，返回为double型</p>
</li>
<li>
<p><code>algorithm</code>头文件下的函数，加<code>using namespace std;</code></p>
<p><code>max(x,y)</code> <code>min(x,y)</code></p>
<p><code>abs(x)</code> 返回x的绝对值，x必须为整数</p>
<p><code>swap(x,y)</code></p>
<p><code>reverse(it,it2)</code> <code>reverse(a,a+4)</code>  ,将数组元素反转</p>
<p><code>next_permutation(a,a+...)</code> ,给出一个序列在全排列中的下一个序列，该函数在到达全排列的最后一个时会返回false</p>
<p><code>fill(a,a+4,233)</code> ,赋相同值，对于<code>G[maxn] [maxn]</code>二维数组<code>fill(G[0],G[0]+maxn*maxn,INF);</code></p>
<p><code>sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填)）</code>,无比较函数，默认递增排序。</p>
<p><code>sort(a, a+n, greater());</code>  从大到小排序(要用<code>iostream</code>头文件)</p>
<p><code>lower_bound(first,last,val)</code>  <code>upper_bound(first,last,val)</code> ,用于有序数组或容器，前者用来寻找[first,last)范围内第一个值大于等于val的元素的位置，后者寻找第一个值大于val的元素位置.若是数组，这两个函数返回的是地址，如<code>int* right=upper_bound(num, num+n, k)</code>，返回num数组中第一个大于k的元素所在地址，其下标=<code>right-num</code></p>
<p><code>max_element(a, a+len)</code>返回序列中最大元素地址（迭代器）,可用其减去数组首地址(即数组名)获取其下标,若要获取该元素值，<em><em>直接在前面加一个</em>,表示取地址即可</em>*</p>
<p><code>min_element(begin, end)</code> 返回序列中最小元素地址</p>
</li>
<li>
<p><code>string.h</code> 头文件(<code>cstring</code>头文件)</p>
<p><code>memset(数组名,-1或0,sizeof(数组名))</code></p>
<p><code>strlen(字符数组)</code> 得到字符数组中第一个\0前的字符个数</p>
<p><code>strcmp(字符数组1，字符数组2)</code>返回两个字符串大小比较结果，按字典序。字符数组1&lt;2 ,返回负整数;1=2，返回0;1&gt;2，返回正整数</p>
<p><code>strcpy(字符数组1，字符数组2)</code>，把字符数组2复制给字符数组1，包括\0</p>
<p><code>strcat(字符数组1，字符数组2)</code> ,把2接在1后面</p>
</li>
<li>
<p><code>cctype</code>头文件</p>
<p>1.不仅仅能判断字⺟，还能判断数字、⼩写字⺟、⼤写字⺟等</p>
<p><code>isalpha</code>字⺟（包括⼤写、⼩写）</p>
<p><code>islower</code> （⼩写字⺟）</p>
<p><code>isupper</code>（⼤写字⺟）</p>
<p><code>isalnum</code> （字⺟⼤写⼩写+数字）</p>
<p><code>isblank</code>（space和 \t ）</p>
<p><code>isspace</code>（ space 、 \t 、 \r 、 \n ）</p>
<p><code>isdigit</code>(数字)</p>
<p>2 .<code>tolower (char c)</code>和 <code>toupper(char c)</code> 将某个字符转为⼩写或⼤写</p>
</li>
<li>
<p><code>string</code></p>
<p><code>str.insert(pos,str1)</code> 在原字符串的pos号位插入一个新的字符串str1</p>
<p><code>str.erase(first,last)</code> first为需要删除的区间的起始迭代器，last是区间末尾迭代器的下一个地址</p>
<p><code>str.erase(pos,length)</code> pos为需要开始删除的起始位置，length是删除的字符个数</p>
<p><code>str.clear()</code> 清空string中的数据</p>
<p><code>str.substr(pos,len)</code> 返回从pos号开始，长度是len 的子串</p>
<p><code>string::npos</code>是一个常数，可以作为find函数匹配失败的返回值</p>
<p><code>str.find(str1,pos)</code>  从str的pos号位开始匹配str1，返回str1第一次出现的位置</p>
<p><code>str.find(str1)</code>  从str的pos号位开始匹配str1，返回str1第一次出现的位置</p>
</li>
</ul>
<h3 id="10进制转换">10.进制转换</h3>
<ul>
<li>十进制转化为其他进制</li>
</ul>
<pre><code>1.数组形式
int z[maxn],num=0;
do{
z[num++]=n%b;
n/=b;
}while(n!=0);
2.数字形式(将十进制数n转化为任意b进制数，将结果存在数组中)
vector change(int n,int b){
	vector&lt;int&gt; v;
	int ans=0;
	while(n!=0){
		v.push_back(n%b);
		n/=b;
	}//注意在数组中存储的顺序(下标从0开始)是反的
	return ans;
}
3.
void change(int n,int b){
	if(n&gt;0){
		int i=0;
		change(n/b,b);
		a.push_back(n%b);
	}
	else return;
}
</code></pre>
<ul>
<li>
<p>其他进制转化为十进制</p>
<pre><code>for(int i=0;i&lt;v.size();i++) ans+=v[i]*pow(b,i);
</code></pre>
</li>
<li>
<p>给定⼀个数值和⼀个进制，将它转化为10进制。转化过程中可能产⽣溢出,数值中只有小写字母和数字</p>
<pre><code>long long convert(string n, long long radix) {
 long long sum = 0;
 int index = 0, temp = 0;
 for (auto it = n.rbegin(); it != n.rend(); it++) {
   temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
   sum += temp * pow(radix, index++);
 }
 return sum;
}
</code></pre>
</li>
</ul>
<h3 id="11-ascll-码表">11. <code>ASCLL</code> 码表</h3>
<p>A-Z对应十进制65-90</p>
<p>a-z对应十进制97-122</p>
<h3 id="12回文串">12.回文串</h3>
<pre><code>bool judge(int arr[],int index){//index为数组元素个数
    for(int i = 0; i &lt;index / 2; i++) {
       if(arr[i] != arr[index-i-1]) {
           return false;
     }
   }
   return true;
}

</code></pre>
<h3 id="13数字-字符数组相互转换">13.数字、字符数组相互转换</h3>
<pre><code>1.数字存到数组中
void to_array(int n,int a[]){
    int j=0;
    while(n){
        a[j++]=n%10;
        n/=10;
    }
}
2.数组变为数字
int exp=0;
for(int i=0;i&lt;len;i++){
    exp=exp*10+(str[i]-'0');
}
或

</code></pre>
<h3 id="14-排序-找最值">14 排序、找最值</h3>
<ul>
<li>
<pre><code>int best=0;
for (int j = 0; j &lt; 4; j++) {
	if (a[j] &lt; a[best])
	best = j;
}
找出数组a中最小元素的位置
</code></pre>
</li>
<li>
<p>结构体内重载运算符</p>
<p>运算符重载的格式如下：</p>
<p>函数类型 operator 运算符名称（形参表列）{对运算符的重载处理},例如：</p>
<pre><code>struct node {
	int id;
	int freq;
	bool operator &lt; (const node&amp; a) const {
		return (freq != a.freq) ? freq &gt; a.freq:id &lt; a.id;
	}
};
</code></pre>
</li>
<li>
<p>使用sort()对char数组排序</p>
<p>正确方法：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[3][4] = {&quot;wu&quot;,&quot;jia&quot;,&quot;jun&quot;};//二维数组保存n个字符串 
bool cmp(int a,int b){
    return strcmp(name[a],name[b]) &lt; 0;
}
int main(){
    int arr[3] = {0,1,2};//与字符串数组下标一一对应 
    sort(arr,arr+3,cmp);//排列的实际是标号 ，这么做更快 
    for(int i = 0;i &lt;3 ;i++){
        printf(&quot;%s &quot;,name[arr[i]]);
    }
}
</code></pre>
<p>错误方法：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
char stu[6][6] = { &quot;ahda&quot;,&quot;jwnd&quot;,&quot;djsh&quot;,&quot;yrhw&quot;,&quot;JWJs&quot; };
bool cmp(int a, int  b) { return strcmp(stu[a], stu[b]) &lt; 0; }
int main() {
	sort(stu, stu + 5, cmp);
	for (int i = 0; i &lt; 5; i++)
		printf(&quot;%s&quot;, stu[i]);
	return 0;
}
</code></pre>
</li>
<li>
<pre><code> testee[0].rank=1;
  	for(int k=1;k&lt;total;k++){
  		if(testee[k].grade==testee[k-1].grade) testee[k].rank=testee[k-1].rank;
  		else testee[k].rank=k+1;
  	}
确保排名为 1 1 3 3 4...的形式
</code></pre>
</li>
<li>
<p>A1062 ,A1075,A1012,A1016,A1025,A1028,A1055,A1075,A1083,A1080,A1095,A1109,A1141(注意1080中cmp的写法和使用)</p>
<p>思路：</p>
<p>定义结构体，cmp函数，初始化结构体内的变量，for循环中边输入边处理</p>
<p>排序时注意是否能用学号等信息作为数组下标，因为排序后下标会改变，所以可以在结构体中设置id变量</p>
<p>平均数作为最后成绩可以不用除，直接用总和比较</p>
<p>有些题要找出有效记录(比如常出现的配对问题)</p>
</li>
<li>
<p>各种排序算法</p>
<ul>
<li>
<p>选择排序</p>
<pre><code>void selectsort(){
    for(int i=0;i&lt;n;i++){
        int k=i;
        for(int j=k;j&lt;n;j++){
            if(A[j]&lt;A[k]){
                k=j;
            }
        }
        int temp=A[K];
        A[k]=A[i];
        A[i]=temp;
    }
}
</code></pre>
</li>
<li>
<p>插入排序</p>
<pre><code>void insertSort(){
   for(int i=2;i&lt;=n;i++){
      int temp=a[i],j=i;
      while(j&gt;1&amp;&amp;a[j-1]&gt;temp){
         a[j]=a[j-1];
         j--;
      }
      a[j]=temp;
   }
}
</code></pre>
</li>
<li>
<p>归并排序 (此处为2路归并) (合并两个有序序列时，注意其中一个数列先扫描完的情况)</p>
<pre><code>void merge(int A[],int L1,int R1,int L2,int R2){
//将数组A的[L1,R1]与[L2,R2]区间合并为有序区间(此处L2=R1+1)
    int i=L1,j=L2,temp[maxn],index=0;
    while(i&lt;=R1&amp;&amp;j&lt;=R2){
    if(A[i]&lt;=A[j]) temp[index++]=A[i++];
    else temp[index++]=A[j++];
    }
    while(i&lt;=R1) temp[index++]=A[i++];
    while(j&lt;=R2) temp[index++]=A[j++];
    for(i=0;i&lt;index;i++) A[L1+i]=temp[i];
}
void mergeSort(int A[],int left,int right){
    if(left&lt;right){
        int mid=(left+right)/2;
        mergeSort(A,left,mid);
        mergeSort(A,mid+1,right);
        merge(A,left,mid,mid+1,right);
    }
}
</code></pre>
</li>
<li>
<p>快排(递归法)</p>
<pre><code>int partition(int A[],int left,int right){
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
<p>快排(改进后)</p>
<p>生成随机数需要添加stdlib.h与time.h头文件，mian函数内开头加上srand((unsigned)time(NULL));</p>
<pre><code>int partition(int A[],int left,int right){//只改进该函数
    int p=(int)(round(1.0*rand()/RAND_MAX*(right-left)+left));
    //生成[left,right]范围内的随机数
    swap(A[left],A[p]);
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){//该函数不变
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
</li>
<li>
<p>堆排序</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
void createheap() {//建堆
	for (int i = n / 2; i &gt;= 1; i--) {
		downadjust(i, n);
	}
}
void heapsort(){
    createheap();
    for(int i=n;i&gt;1;i--){
        swap(heap[1],heap[i]);
        upadjust(1,i-1);
    }
}
</code></pre>
</li>
<li>
<p>拓扑排序</p>
<pre><code>vector&lt;int&gt; G[maxn]; //邻接表
int n,m,indegree[maxn]; //顶点数，入度 
</code></pre>
</li>
</ul>
<p>bool topologicalSort(){<br>
int num=0;<br>
queue<int> q;<br>
for(int i=0;i&lt;n;i++){<br>
if(indegree[i])==0 q.push(i);<br>
}<br>
while(!q.empty()){<br>
int u=q.front();//取队首结点<br>
q.pop();<br>
for(int i=0;i&lt;G[u].size();i++){<br>
int v=G[u][i];//u的后继结点<br>
indegree[v]--;<br>
if(indegree[v]<mark>0) q.push(v);<br>
}<br>
G[u].clear();//清空u的所有出边，如无必要可不写<br>
num++;<br>
}<br>
if(num</mark>n) return true;//加入拓扑排序的顶点数为n，说明拓扑排序成功<br>
else return false; //顶点数小于n，失败<br>
}</p>
<pre><code>




</code></pre>
</li>
</ul>
<h3 id="15-计算时长">15 计算时长</h3>
<ul>
<li>
<p>对已知的起止时间，不断将起始时间加1，判断是否到达终止时间</p>
<pre><code>void get_ans(int on, int off, int&amp; time, int&amp; money) {
	temp = rec[on];
  while (temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) {
		time++;
		money += toll[temp.hh];
		temp.mm++;
		if (temp.mm &gt;= 60) {
			temp.mm = 0;
			temp.hh++;
		}
		if (temp.hh &gt;= 24) {
			temp.hh = 0;
			temp.dd++;
		}
	}
}
</code></pre>
</li>
<li>
<p>对于<code>hh:mm:ss</code>类型的时间处理：可以<code>hh * 3600 + mm * 60 + ss</code> 转化成秒，方便处理</p>
</li>
</ul>
<h3 id="16数据类型问题">16.数据类型问题</h3>
<ul>
<li>且C++把所有⾮零值解释为 true ，零值解 释为 false ～所以直接赋值⼀个数字给 <code>bool</code> 变量也是可以的，它会⾃动根据 int 值是不是零来决定 给 <code>bool</code> 变量赋值 true 还是 false ～</li>
</ul>
<pre><code>bool flag = true;//flag为1，若是flase则为0
bool flag2 = -2; // flag2为true
bool flag3 = 0; // flag3为false
</code></pre>
<h3 id="17栈-队列-链表">17.栈、队列、链表</h3>
<p>在使用栈的pop()和top()函数前必须使用empty()判断栈是否非空。</p>
<p>栈：A1051</p>
<p>记得清空栈</p>
<pre><code>while(!st.empty()){
    st.pop();
}
</code></pre>
<p>队列：A1056</p>
<p>链表：A1074，A1032，A1052, A1097 A1133(链表  重新排列)</p>
<pre><code>for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;node[address].key,&amp;node[address].next);
		node[address].address=address;
	}
</code></pre>
<p>当结点的地址是比较小的整数(比如5位数的整数),可以使用静态链表，没有必要建立动态链表。</p>
<p>注意初始化，排除无效结点(可以结合sort，cmp中针对order)。用count计数有效结点</p>
<p>某些情况下的最后一个结点要特殊处理(比如令next为-1)。</p>
<p>注意链表结构体元素order的使用</p>
<h3 id="18贪心">18.贪心</h3>
<p>A1070 ,<strong>A1033</strong> ,A1037,A1067 A1125(简单贪心 排序)</p>
<h3 id="19-二分">19 二分</h3>
<p>A1085,A1010,A1044 A1048</p>
<p>注意二分法的几种写法,以及非严格递增序列的处理,可以使用<code>lower_bound</code>和<code>upper_bouned</code></p>
<ul>
<li>
<p>查找给定的数x</p>
<pre><code>int binarySearch(int A[],int left,int right,int x){
    int mid;
    while(left&lt;=right){
        mid=(left+right)/2;
        if(A[mid]==x) return mid;
        else if(A[mid]&gt;x) right=mid-1;
        else left=mid+1;
    }
    return -1;//查找失败，返回-1
}
</code></pre>
</li>
<li>
<p>求第一个大于等于x的元素的位置</p>
<pre><code>int lower_bound(int A[],int left,int right,int x){
    int mid;
    while(left&lt;right){
        mid=(left+right)/2;
        if(A[mid]&gt;=x) right=mid;
        else left=mid+1;
    }
    return left;
}
</code></pre>
</li>
<li>
<p>求第一个大于x的元素的位置</p>
<pre><code>int upper_bound(int A[],int left,int right,int x){
    int mid;
    while(left&lt;right){
        mid=(left+right)/2;
        if(A[mid]&gt;x) right=mid;
        else left=mid+1;
    }
    return left;
}
</code></pre>
</li>
</ul>
<h3 id="20-two-points">20 two points</h3>
<p>A1085,A1089,A1029</p>
<h3 id="21-数学问题">21 数学问题</h3>
<ul>
<li>
<p>求最大公约数,(最小公倍数：a和b的最大公约数为d，则a和b的最小公倍数为ab/d)</p>
<pre><code>long long gcd(long long a, long long b) {
     return b == 0 ? abs(a) : gcd(b, a %b);
 }
</code></pre>
</li>
<li>
<p>分数化简</p>
<pre><code>struct node{
	long long up, down;
}
node reduction(node res){
	if(res.down&lt;0){
		res.up=-res.up;
		res.down=-res.down;
	}
	if(res.up==0) res.down=1;
	else{
		long long d=gcd(abs(res.up),abs(res.down));
		res.up/=d;
		res.down/=d;
	}
	return res;
}
</code></pre>
</li>
<li>
<p>分数的四则运算</p>
<pre><code>node add(node f1,node f2){//分数相加
	node res;
	res.up=f1.down*f2.up+f1.up*f2.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node minu(node f1,node f2){//分数相减
	node res;
	res.up=f1.up*f2.down-f2.up*f1.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node multi(node f1,node f2){//分数相乘
	node res;
	res.up=f1.up*f2.up;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node divide(node f1,node f2){//分数相除
	node res;
	res.up=f1.up*f2.down;
	res.down=f1.down*f2.up;
	return reduction(res);
}
</code></pre>
</li>
<li>
<p>分数输出</p>
<pre><code>void showres(node res){
	res=reduction(res);
	if(res.down==1) printf(&quot;%lld\n&quot;,res.up);
	else if(abs(res.up)&gt;abs(res.down)){
		printf(&quot;%lld %lld/%lld\n&quot;,res.up/res.down,abs(res.up%res.down),res.down);
	}else printf(&quot;%lld/%lld\n&quot;,res.up,res.down);
}
</code></pre>
</li>
<li>
<p>判断是否为素数</p>
<pre><code>bool isprime(int n) {
	if (n &lt;= 1) return false;
    int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}

</code></pre>
</li>
<li>
<p>建立素数表</p>
<pre><code>
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
</code></pre>
</li>
<li>
<p>大整数运算</p>
<ul>
<li>
<p>以字符串方式存储、运算</p>
<pre><code>string add(string s1, string s2) {//加法运算，十进制，两个数位数相同
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
<li>
<p>以结构体方式存储运算</p>
<pre><code>struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
	a.d[i] = str[a.len - 1 - i]-'0';//整数的高位会变成数组的低位
	}
	return a;
}

bign add(bign a, bign b) {//加法
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len||i&lt;b.len; i++) {
		int temp = a.d[i] +b.d[i] + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	if(carry != 0) {
		c.d[c.len++] = carry;
	}
	return c;
}

bign sub(bign a, bign b) {//加法
	bign c;
	for (int i = 0; i &lt; a.len||i&lt;b.len; i++) {
	    if(a.d[i]&lt;b.d[i]){//如果不够减
	       a.d[i+1]--;//向高位结尾
	       a.d[i]+=10;//当前位加10
	    }
	    c.d[c.len++]=a.d[i]-b.d[i];
	}
	while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0) c.len--;
	//去除高位的0，同时至少保留一位最低位
	return c;
}

bign multi(bign a, int b) {//乘法
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {//乘法的进位可能不止一位
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}

bign divide(bign a,int b,int&amp; r){//r为余数
    bign c;
    c.len=a.len;
    for(int i=a.len-1;i&gt;=0;i--){//从高位开始
       r=r*10+a.d[i];//和上一位遗留的余数组合
       if(r&lt;b) c.d[i]=0;//不够除,改位为0
       else{
          c.d[i]=r/b;//商
          r=r%b; //获得新的余数
       }
    }
    while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)  c.len--;//去除高位的0，同时至少保留一位最低位
    return c;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<p>A1069,A1049,A1088,A1015,A1078,A1096,A1023,A1024</p>
<h3 id="22入门模拟">22.入门模拟</h3>
<p>A1042(洗扑克牌) ，A1046(环形两点间距离) ，A1065(两数相加判断大小)， A1002(多项式相加)，A1009(多项式相乘)，A1011，A1006(签到签离) ，A1036(找最值)，A1031(输出图形)，A1019(回文串)，A1027(进制转换)，A1058(加法进位)，A1061(字符串问题)，***A1073(科学计数法)***，A1001(a+b)，A1005,A1035,A1077(公共后缀)，<strong>A1082(用汉语读数字)</strong></p>
<h3 id="23技巧-逻辑">23.技巧、逻辑</h3>
<p>A1093,A1101, A1113 A1117(逻辑)  A1148(狼人杀 找到两个狼人)</p>
<h3 id="24-dfs-bfs">24 DFS BFS</h3>
<ul>
<li>
<p>DFS用递归实现，A1103</p>
<pre><code>void DFS(int index, int nowk, int sum, int facsum) {
	if (sum == n &amp;&amp; nowk == k) {
		if (facsum &gt; maxfacsum) {
			ans = temp;//更新最优序列
			maxfacsum = facsum;
		}
		return;
	}
	if (nowk &gt; k || sum &gt; n) return;
	if (index - 1 &gt;= 0) {
		temp.push_back(index);
		DFS(index, nowk + 1, sum + fac[index], facsum + index);
		temp.pop_back();
		DFS(index - 1, nowk, sum, facsum);
	}
}
</code></pre>
</li>
<li>
<p>BFS用队列实现    A1091</p>
<pre><code>void BFS(int s){
    queue&lt;int&gt; q;
    q.push(s);
    while(!q.empty()){
        取出队首元素top;
        访问队首元素top;
        将队首元素出队;
        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;
    }
}
</code></pre>
<pre><code>int BFS(int z,int x,int y){
	int total=0;
	Node.x = x;
	Node.y = y;
	Node.z = z;
	inq[z][x][y] = true;
	queue&lt;node&gt; q;
	q.push(Node);
	while (!q.empty()) {
		node topp = q.front();
		q.pop();
		total++;
		int newx, newy, newz;
		for (int i = 0; i &lt; 6; i++) {
			newz = topp.z + Z[i];
			newx = topp.x + X[i];
			newy = topp.y + Y[i];
			if (judge(newz, newx, newy)) {
				Node.x = newx;
				Node.y = newy;
				Node.z = newz;
				q.push(Node);
				inq[Node.z][Node.x][Node.y] = true;
			}
		}
	}
	if (total &gt;= T) return total;
	else return 0;
}
</code></pre>
</li>
</ul>
<h3 id="25-树">25 树</h3>
<p>A1020,A1086,A1102 , A1151(二叉树LCA)，A1143(二叉搜索树LCA) 、A1119(前序和后序求中序)</p>
<p>A1123(30 AVL 、层序遍历、判断是否是完全二叉树) 、 A1110(判断是否为完全二叉树)</p>
<p>A1127(30 中序后序建树，dfs，输出z字形层序遍历)   A1130(dfs二叉树 输出中缀表达式)</p>
<p>A1155(30 完全二叉树  判断大顶堆小顶堆 dfs 打印路径)    A1147(30  判断大顶堆小顶堆 后序遍历)</p>
<p>A1135(30 判断红黑树 递归判断)</p>
<ul>
<li>
<p>二叉树</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node{
    typename data;
    node* lchild;
    node* rchild;
}//动态
struct node{
  typename data;
    int left,right;
</code></pre>
</li>
</ul>
<p>}//静态</p>
<p>//对于不是二叉树的树<br>
struct node{<br>
typename data;<br>
vector<int> child;<br>
}</p>
<pre><code>
</code></pre>
</li>
<li>
<p>新建结点</p>
<pre><code>  node* newNode(int v){
      node* root=new node;
      Node-&gt;data=v;
      Node-&gt;lchild=Node-&gt;rchild=NULL;
      return Node;
  }
</code></pre>
</li>
<li>
<p>中序遍历</p>
<pre><code>  void inorder(node* root){
      if(root==NULL) return;
      inorder(root-&gt;lchild);
      printf(&quot;%d&quot;,root-&gt;data);
      inorder(root-&gt;rchild);
  }
</code></pre>
<ul>
<li>
<p>二叉树的层序遍历(BFS)</p>
<pre><code>1.void layerorder(node* root) {
	queue&lt;node*&gt; q;
    q.push(root);
	while (!q.empty()) {
	node* now = q.front();
		q.pop();
		printf(&quot;%d&quot;, now-&gt;data);
		if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);
	if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);
	}
}

2.//层序遍历用当前队列的元素个数统计每层节点
vector&lt;int&gt; level[31];
struct node{
	int v;
	node* left,*right;
};
void bfs(node*root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		int count=q.size();
		while(count--){
			node* t=q.front();
			q.pop();
			level[depth].push_back(t-&gt;v);
			if(t-&gt;left!=NULL) q.push(t-&gt;left);
			if(t-&gt;right!=NULL) q.push(t-&gt;right);
		}
		depth++;
	}
}

3.//层序遍历用结构体统计每层结点
vector&lt;int&gt; level[35];
struct node{
	int v,depth;
	node* left,*right;
};
void bfs(node*root){
	queue&lt;node&gt; q;
	q.push(node{root-&gt;v,1,root-&gt;left,root-&gt;right});
	while(!q.empty()){
		node t=q.front();
		q.pop();
		level[t.depth].push_back(t.v);
		if(t.left!=NULL) q.push(node{t.left-&gt;v,t.depth+1,t.left-&gt;left,t.left-&gt;right});
		if(t.right!=NULL) q.push(node{t.right-&gt;v,t.depth+1,t.right-&gt;left,t.right-&gt;right});
	}
}
</code></pre>
</li>
<li>
<p>用已知的两个序列构建唯一二叉树</p>
<pre><code>node* create(int postL, int postR, int inL, int inR) {//后序加中序
	if (postL &gt; postR) return NULL;
	node* root = new node;
	root-&gt;data = postorder[postR];
	int k;
	for (int i = inL; i &lt;= inR; i++) {
		if (inorder[i] == root-&gt;data) {
			k = i;
		break;
		}
	}
	int leafnum = k - inL;
	root-&gt;lchild = create(postL, postL + leafnum - 1, inL, k - 1);
	root-&gt;rchild = create(postL + leafnum, postR - 1, k + 1, inR);
	return root;
}

</code></pre>
<p>层序加中序建树</p>
<pre><code>typedef struct node{				//结点定义 
	int data;
	struct node *right,*left;
}Node;
vector&lt;int&gt; inor,layor;				//中序和层序序列 
unordered_map&lt;int,int&gt; inmp,laymp;	//序列与其下标的映射，（建立映射可以减少递归时候查找序列的次数） 
Node *creat(int il,int ir){			//建树函数 ，il表示中序序列的左端，ir便是中序序列的右端 
	if(il&gt;ir) return NULL;			//如果树中序列长度为0，表示到了空结点 
	int min=INF,id;					//min表示中序序列中的元素在层序中下标最小的那个，其中序的下标 
	for(int i=il;i&lt;=ir;i++){		//遍历中序序列，找出对应层序中下边最小的元素 
		if(laymp[inor[i]]&lt;min){
			min=laymp[inor[i]];
		}
	}
	Node *root=new node;			
	root-&gt;data=layor[min];			//中序序列中 层序中下标最小的便是根 
	id=inmp[root-&gt;data];			//获得根在中序的位置，划分为左子树和右子树 
	root-&gt;left=creat(il,id-1);		//递归左子树 
	root-&gt;right=creat(id+1,ir);		//递归右子树 
	return root;					//返回当前子树的根 
}
void preorder(Node *root){			//递归的先序遍历函数 
	if(root==NULL) return;
	printf(&quot;%d &quot;,root-&gt;data);
	preorder(root-&gt;left);
	preorder(root-&gt;right);
}
int main(void){

	int n;
	cin&gt;&gt;n;
	inor.resize(n); layor.resize(n);//读入元素个数并初始化 
	for(int i=0;i&lt;n;i++){			//读入中序序列并完成映射 
		cin&gt;&gt;inor[i];
		inmp[inor[i]]=i;
} 
	for(int i=0;i&lt;n;i++){			//读入层序序列并完成映射 
	cin&gt;&gt;layor[i];
		laymp[layor[i]]=i;
	} 
	Node *root=creat(0,n-1);		//建树 
	preorder(root);					//先序遍历，验证树的结构 
	return 0;
} 
</code></pre>
<p>前序加后序建树</p>
<pre><code>node* create(int prel,int prer,int postl,int postr){//1119
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;v=pre[prel];
	int k=prel+1;
	while(k&lt;=prer&amp;&amp;pre[k]!=post[postr-1]) k++;
	if(prel+1&lt;n&amp;&amp;postr-1&gt;=0&amp;&amp;pre[prel+1]==post[postr-1]) unique=false;
	int numleft=k-prel-1;
	root-&gt;left=create(prel+1,k-1,postl,postl+numleft-1);
	root-&gt;right=create(k,prer,postl+numleft,postr-1);
	return root;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>静态二叉树(如果题目中直接给出结点序号之间的父子关系，可以用静态)</p>
<pre><code>struct node{
    typename data;
    int lchild;
    int rchild;
}Node[maxn];
</code></pre>
</li>
<li>
<p>二叉树反转(静态)</p>
<pre><code>  void postorder(int root) {//注意是后序遍历
	if (root == -1) return;
  	postorder(Node[root].lchild);
	postorder(Node[root].rchild);
  	swap(Node[root].lchild, Node[root].rchild);
  }
</code></pre>
<ul>
<li>
<p>完全二叉树</p>
<p>1.判断是否是完全二叉树</p>
<p>判断是不是完全⼆叉树，就看在出现了⼀个孩⼦为空的结点之后是否还会出现孩⼦结点不为空的结 点，如果出现了就不是完全⼆叉树。</p>
<pre><code>int iscomplete = 1, after = 0;
vector&lt;int&gt; levelorder(node* root) {//层序遍历中
	queue&lt;node*&gt; q;
	vector&lt;int&gt; v;
	q.push(root);
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		v.push_back(temp-&gt;data);
		if (temp-&gt;lchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;lchild);
		}
	else after = 1;
		if (temp-&gt;rchild != NULL) {
		if (after) iscomplete = 0;
			q.push(temp-&gt;rchild);
	}
		else after = 1;
}
	return v;
}
</code></pre>
<p>2.给出⼀个n表示有n个结点，这n个结点为0~n-1，给出这n个结点的左右孩⼦，求问这棵树是 不是完全⼆叉树</p>
<p>分析：递归出最⼤的下标值，完全⼆叉树⼀定把前⾯的下标充满： 最⼤的下标值 == 最⼤的节点数； 不完全⼆叉树前满⼀定有位置是空，会往后挤： 最⼤的下标值 &gt; 最⼤的节点数</p>
<p>3.完全二叉搜索树，将待插入数据a[]从小到大排序，利用中序建树，存放到CBT数组中，依次输出CBT数组的元素即为完全二叉搜索树的层序遍历序列</p>
<pre><code>void inorder(int root){
	if(root&gt;n) return;
	inorder(root*2);
	CBT[root]=a[index++];
	inorder(root*2+1);
}
</code></pre>
</li>
<li>
<p>注意点</p>
<ul>
<li>完全二叉树的存储中，如果根节点下标为1，则该树中任何一个结点i，其左孩子编号为2i，右孩子编号为2i+1，父亲节点为下取整(i/2);如果根节点下标为0，对树中某结点i,父亲结点为下取整((i-1)/2);左孩子为2i+1，右孩子为2i+2</li>
<li>函数参数中，对指针指向的结点内容进行修改是不需要加引用的，。如果函数中需要新建结点，即对二叉树的结构做出修改，就需要加引用(如insert，)，如果是修改当前已有结点的内容，或者是遍历树，就不需要加引用。</li>
<li>无论是先序还是后序，都必须知道中序序列才能唯一确定一棵树</li>
<li>对于题目中给出左右孩子结点编号的情况，没有被当做孩子结点的结点编号即为根结点，可以用一个数组来判断</li>
</ul>
</li>
</ul>
</li>
<li>
<p>普通树</p>
<p>深度遍历，递归边界为无孩子结点，根节点深度为0</p>
<pre><code>void DFS(int index,int depth){
	if(Node[index].child.size()==0){
		ans+=Node[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;Node[index].child.size();i++){
		DFS(Node[index].child[i],depth+1);
	}
}
</code></pre>
<p>广度遍历</p>
<pre><code>void BFS() {
  	level[1] = 1;
  	queue&lt;int&gt; q;
  	q.push(1);
  	while (!q.empty()) {
  		int now = q.front();
  		q.pop();
  		if (child[now].size() == 0) {
  			hashtable[level[now]]++;
  			maxlevel = max(maxlevel, level[now]);
  		}
  		for (int i = 0; i &lt; child[now].size(); i++) {
  			level[child[now][i]] = level[now] + 1;
  			q.push(child[now][i]);
  		}
  	}
  }`
</code></pre>
<p>二叉查找树BST</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node{
	int data;
	node* lchild;
	node* rchild;
};
</code></pre>
</li>
<li>
<p>插入</p>
<pre><code>void insert(node*&amp; root, int x) {
	if (root == NULL) {
		root = new node;
		root-&gt;data = x;
		root-&gt;lchild = NULL;
		root-&gt;rchild = NULL;
		return;
	}
	if (x &lt; root-&gt;data) insert(root-&gt;lchild, x);
	else insert(root-&gt;rchild, x);
}
</code></pre>
</li>
<li>
<p>完全二叉查找树</p>
<p>用数组存放完全二叉查找树时，可以先将待插入的权值递增排列，然后用中序遍历的方式将其插入到树中，并且要注意结点序号的关系</p>
<pre><code>void inorder(int root) {
	if (root &gt; n) return;
	inorder(root * 2);
	CBT[root] = number[index++];
	inorder(root * 2 + 1);
}
</code></pre>
</li>
<li>
<p>注意点：对二叉查找树进行中序遍历，其结果是有序的</p>
</li>
</ul>
</li>
<li>
<p>平衡二叉树(AVL)</p>
<p>A1066</p>
<p>任意结点左子树与右子树的高度之差的绝对值不超过1</p>
<p>某结点左子树与右子树的高度之差成为该结点的平衡因子。</p>
<p>在对AVL进行插入操作时，只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡。</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node {
	int data, height;
	node* lchild, * rchild;
};
</code></pre>
</li>
<li>
<p>生成一个新结点</p>
<pre><code>node* newNode(int v) {
	node* Node = new node;
	Node-&gt;v = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
</code></pre>
</li>
<li>
<p>获取结点root所在子树当前高度</p>
<pre><code>int getheight(node* root) {
    if (root == NULL) return 0;
	return root-&gt;height;
}
</code></pre>
</li>
<li>
<p>更新高度</p>
<pre><code>void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
</code></pre>
</li>
<li>
<p>计算平衡因子</p>
<pre><code>int getbalancefactor(node* root) {
	return getheight(root-&gt;lchild) - getheight(root-&gt;rchild);
	//注意是左减右
}
</code></pre>
</li>
<li>
<p>左旋</p>
<pre><code>void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>右旋</p>
<pre><code>void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>建树</p>
<pre><code>void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newnode(v);
		return;
	}
	if (root-&gt;data &gt; v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalance(root) == 2) {
			if (getbalance(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalance(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild, v);
		updateheight(root);
		if (getbalance(root) == -2) {
			if (getbalance(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalance(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>堆(完全二叉树(大顶堆、小顶堆))，下面以大顶堆为例</p>
<ul>
<li>
<p>向下调整</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>删除堆顶元素</p>
<pre><code>void deletetop() {
	heap[1] = heap[n--];
	downadjust(1, n);
}
</code></pre>
</li>
<li>
<p>向上调整</p>
<pre><code>void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>插入元素</p>
<pre><code>void insert(int x) {
	heap[++n] = x;
	upadjust(1, n);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>红黑树</p>
<p>定义：红黑树是每个节点都带有颜色属性的平衡二叉查找树 ，颜色为红色或黑色。除了二叉查找树一般要求以外，对于任何有效的红黑树增加了如下的额外要求:</p>
<p>（1） 节点是要么红色或要么是黑色。</p>
<p>（2） 根一定是黑色节点。</p>
<p>（3） 每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</p>
<p>（4） 每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</p>
<p>（5） 从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点</p>
<pre><code>void create(node*&amp;root,int v){//创建BST
	if(root==NULL){
		root=new node;
		root-&gt;v=v;
		root-&gt;left=root-&gt;right=NULL;
		return;
	}
	if(abs(v)&lt;=abs(root-&gt;v)) create(root-&gt;left,v);
	else create(root-&gt;right,v);
}
//负点权代表红，正点权代表黑
bool judge1(node*root){//判断红结点的孩子结点是否都为黑
	if(root==NULL) return true;
	if(root-&gt;v&lt;0){
		if(root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;v&lt;0) return false;
		if(root-&gt;right!=NULL&amp;&amp;root-&gt;right-&gt;v&lt;0) return false;
	}
	return judge1(root-&gt;left)&amp;&amp;judge1(root-&gt;right);
}

int getnum(node*root){
	if(root==NULL) return 0;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	return root-&gt;v&gt;0? max(l,r)+1 :max(l,r);
}
bool judge2(node*root){//判断从任意结点到叶⼦结点的路径中，黑色结点的个数是否相同
	if(root==NULL) return true;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	if(l!=r) return false;
	return judge2(root-&gt;left)&amp;&amp;judge2(root-&gt;right);
}
</code></pre>
<p>1135(30 判断红黑树 递归判断)</p>
</li>
</ul>
<h3 id="26-并查集">26 并查集</h3>
<p>A1107 A1114 A1118</p>
<ul>
<li>
<p>初始化</p>
<pre><code>for(int i=0;i&lt;N;i++){//初始化，千万不要忘了
    father[i]=i;
}
</code></pre>
</li>
<li>
<p>找根结点</p>
<pre><code>int findfather(int x){//普通版找根节点
    while(x!=father[x]){
      x=father[x];
    }
    return x;
}

int findfather(int x){//路径压缩版找根结点(非递归写法)
    int a=x;
    while(x!=father[x]) x=father[x];
    while(a!=father[a]){
        int z=a;
        a=father[a];//a回溯到其父亲节点
        father[z]=x;//将原先的结点a的父亲节点改为根节点
    }
    return x;
}

int findfather(int v){//路径压缩版找根结点(递归写法)
	if(father[v]==v) return v;
	else{
		int F=findfather(father[v]);
		father[v]=F;//把路径上所有结点的父节点都变为根节点
		return F;
	}
}
</code></pre>
</li>
<li>
<p>合并两个集合</p>
<pre><code>void union(int a,int b){
    int fatherA=findfather(a);
    int fatherB=findfather(b);
    if(fatherA!=fatherB) father[fatherA]=fatherB;
    //可以自己设定，比如序号小的为根节点
}
</code></pre>
</li>
</ul>
<h3 id="27-图">27 图</h3>
<p>A1013 A1021, A1034 <strong>A1076</strong> A1003 <strong>A1018</strong> A1030 A1072 A1087，A1126(欧拉图)  A1134(图  结点与边的问题)</p>
<p>A1146(判断是否为拓扑排序序列 )    A1154(25 图  边的两端点的判断 )    A1142(25 无向完全图 最大子图  两点相连)</p>
<p>A1150(25 判断循环图 输出最小路径)    A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</p>
<ul>
<li>
<p>存储方式</p>
<p>邻接表或邻接矩阵</p>
<p>G[maxn] [maxn] 或者vector&lt; vector <int> &gt; G 或vector<int> G[maxn] 等等</p>
<pre><code>struct node{
   int id;
   int layer;
}
vector&lt;node&gt; adj[amxn];
</code></pre>
</li>
<li>
<p>深度遍历</p>
<pre><code>void DFS(u) {//访问顶点u所在的连通块
	vis[u] = true;
	......
	for (从u出发能到达的所有顶点v) {
        ......
		if (vis[i] == false) {
			DFS(v);
		}
	}
}
void DFStrave(G) {//遍历图G
	for (G的所有顶点u) {
		if (vis[u] == false) {
			......
			DFS(u);
		    ......
		}
	}
}
</code></pre>
</li>
<li>
<p>广度遍历</p>
<pre><code>BFS(u){
   queue q;
   inq[u]=true;
   while(q非空){
     取出队首元素u进行访问；
     for(从u出发可以到达的所有顶点v){
       if(inq[v]==false){
         将v入队;
       inq[v]=true;
       }
     }
}
BFStrave(G){
   for(G的所有结点u){
      if(inq[u]==false){
         BFS(u);
      }
   }
}
</code></pre>
</li>
<li>
<p>判断是否为连通图的两种方法</p>
<ul>
<li>
<p>深度搜索记录访问结点的数量，如果记录的访问的节点数等于总结点数，则为连通图</p>
<pre><code>void dfs(int index) {
 visit[index] = true;
 cnt++;
 for (int i = 0; i &lt; v[index].size(); i++)
 if (visit[v[index][i]] == false)
 dfs(v[index][i]);
}
</code></pre>
</li>
<li>
<p>深度搜索记录连通块数量</p>
</li>
</ul>
<pre><code>for(int j=1;j&lt;=n;j++){
	if(vis[j]==false){
		DFS(j);
		block++;
	}
}
</code></pre>
</li>
<li>
<p>最短路径dijkstra</p>
<ul>
<li>
<p>dijkstra函数内首先进行初始化</p>
<p>包括fill(vis,vis+maxn,false);//某个结点是否访问<br>
fill(d,d+maxn,INF);//到某个结点的最短路径<br>
fill(w,w+maxn,0);//到某个结点路径上的总点权(一般为最大值)<br>
fill(pt,pt+maxn,0);//路径上的结点个数<br>
fill(num,num+maxn,0);//最短路径条数，</p>
<p>​     for(int i=0;i&lt;n;i++) pre[i]=i;//每个结点的前驱结点设为其本身</p>
<p>最后在main函数中还有对临接矩阵或临接链表的初始化，即设为INF</p>
</li>
<li>
<p>输出路径</p>
<pre><code>void printpath(int v){
	if(v==0){//到达起始节点，开始输出，并逐层返回
		cout&lt;&lt;inttostring[v];
		return;
	}
	printpath(pre[v]);
	cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;inttostring[v];
}
</code></pre>
</li>
<li>
<p>dijkstra示例代码</p>
<pre><code>void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(w,w+maxn,0);
	fill(pt,pt+maxn,0);
	fill(num,num+maxn,0);
    for(int i=0;i&lt;n;i++) pre[i]=i;
	d[s]=0;
	w[s]=weight[s];
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];	
					num[v]=num[u];
					pt[v]=pt[u]+1;
					pre[v]=u;
				}else if(d[v]==d[u]+G[u][v]){
					num[v]+=num[u];
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
						pt[v]=pt[u]+1;
						pre[v]=u;
					}else if(w[v]==weight[v]+w[u]){
						double avgfun1=w[v]*1.0/pt[v];
						double avgfun2=(weight[v]+w[u])*1.0/(pt[u]+1);
						if(avgfun2&gt;avgfun1){
							pt[v]=pt[u]+1;
							pre[v]=u;
						}
					}
				}
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>哈密顿问题</p>
<p>A1122(哈密顿回路 set)</p>
</li>
<li>
<p>笔记</p>
<ul>
<li>
<p>连通的、且边数为N-1的具有N个结点的图一定是棵树。在这N个结点中选择合适的根节点，使树的高度最大的办法是：先任意选择一个结点，从该结点出发遍历整个树，获取能达到的最深的结点(记为集合A)，然后从集合A中任意一个结点出发遍历整个树，获取能达到的最深的结点(记为集合B)，集合A与集合B的并集即为所求的使树的高度最大的根结点。</p>
</li>
<li>
<p>删除图中某个顶点及其相连的边时，不用真的删除，可以在DFS访问到该顶点时返回即可,如下</p>
<pre><code>void DFS(int v){
	if(v==deletepoint) return;//访问到删除的结点时返回
	vis[v]=true;
	for(int i=0;i&lt;G[v].size();i++){
		if(vis[G[v][i]]==false){
			DFS(G[v][i]);
		}
	}
}
</code></pre>
</li>
<li>
<p>结点标号为字符串时，可以用map进行和数字间的转化</p>
</li>
<li>
<p>对于每个结点只能访问一次的情况，可以优先考虑BFS(A1076)</p>
</li>
<li>
<p>不论是DFS、BFS、djkst都要先初始化传入参数(即起始结点)的相关信息</p>
</li>
<li>
<p>删除图中某个点i，可以设置该结点vis[i]=true实现“删除”</p>
</li>
</ul>
</li>
</ul>
<h3 id="28-动态规划">28 动态规划</h3>
<ul>
<li>
<p>最大连续子序列和  A1007</p>
<p>状态转移方程:<code>dp[i]=max{a[i],dp[i-1]+a[i]}</code></p>
<p>注意边界初始条件</p>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};//s数组记录最大连续子序列的起始元素
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
    dp[0]=a[0];//边界初始条件--------------------------------------------------------
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){//题目要求输出i，j最小的序列，所以这里的判断是&gt;而不是&gt;=
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长不下降子序列 (LIS) A1045</p>
<p>状态转移方程:<code>dp[i]=max{1,dp[j]+1}</code></p>
<p>如果存在a[i]之前的元素a[j] (j&lt;i)，使得a[j]&lt;=a[i]并且dp[j]+1&gt;dp[i],那么就把a[i]跟在以a[j]为结尾的LIS后面，形成一条更长的不下降子序列(令dp[i]=dp[j]+1)</p>
<p>如果a[i]之前的元素都比a[i]大，那么a[i]就只好自己形成一条LIS，长度为1</p>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;//边界初始条件--------------------------------------
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
  	ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长公共子序列 A1045</p>
<ul>
<li>经典LCS模型，两个序列的元素匹配必须一一对应：</li>
</ul>
<p>​      状态转移方程:如果a[i]==b[j],<code>dp[i] [j]=dp[i-1] [j-1]+1</code>,</p>
<p>​      如果a[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
<ul>
<li>
<p>本题中允许公共部分产生重复元素</p>
<p>状态转移方程修改为:</p>
<p>如果a[i]==b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}+1</code></p>
<p>如果a[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
</li>
</ul>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;//边界起始条件
    for(int i=0;i&lt;L;i++) dp[0][i]=0;//边界起始条件
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;                   
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长回文子串 A1040</p>
<p>dp[i] [j]表示s[i]至s[j]表示的子串是否为回文子串</p>
<p>状态转移方程: 如果s[i]==s[j],<code>dp[i] [j]=dp[i+1] [j-1]</code></p>
<p>如果s[i]!=s[j], <code>dp[i] [j]=0</code></p>
</li>
</ul>
<p>​       边界：<code>dp[i] [i] =1;dp[i] [i+1]=(s[i]==s[i+1])? 1 : 0</code></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){//边界初始化
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;//初始化时注意最长回文子串的长度
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<ul>
<li>
<p>背包问题</p>
<ul>
<li>
<p>01背包 A1068</p>
<p>dp[i] [v]=max{dp[i-1] [v],dp[i-1] [v-w[i]]+c[i]}(1&lt;=i&lt;=n, w[i]&lt;=v&lt;=V)</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="29-分块-实时查询问题">29 分块  (实时查询问题)</h3>
<p>A1057</p>
<p>某非负整数序列元素的取值范围为0到N，则每块中元素个数是根号N(向下取整)，块数是根号N(向上取整)</p>
<p>例如所有元素都不超过100000，则可以将序列分为317块，每块316个元素，并用table[]数组记录每个元素出现的次数，用block[]数组记录每块中的元素个数</p>
<h3 id="30-树状数组bit-实时查询">30 树状数组(BIT) (实时查询)</h3>
<p><code>#define lowbit(i) ((i) &amp; (-i))</code></p>
<p>C[i]的覆盖长度是<code>lowbit(i)</code>,树状数组的下标必须从1开始</p>
<pre><code>int getsum(int x)//返回前x个整数之和{
   int sum=0;
   for(int i=x;i&gt;0;i-=lowbit(i)){
      sum+=c[i];
   }
   return sum;
}
</code></pre>
<pre><code>void update(int x,int v){
   for(int i=x;i&lt;=N;i+=lowbit(i)){
      c[i]+=v;
   }
}
</code></pre>
<h3 id="31-可怕模拟">31 可怕模拟</h3>
<p>A1017(25 )   A1153( 25 模拟 排序引用传参 vector unordered_map)</p>
<p>A1014(30 模拟  难题)</p>
<h3 id="32-n皇后">32 n皇后</h3>
<p>A1128(20)</p>
<h3 id="33堆">33.堆</h3>
<p>堆是一棵完全二叉树，可以用heap[1]~heap[n]数组存储，</p>
<ul>
<li>
<p>堆排序</p>
<pre><code>//大顶堆为例
void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
void createheap() {//建堆
	for (int i = n / 2; i &gt;= 1; i--) {
		downadjust(i, n);
	}
}
void heapsort(){
    createheap();
    for(int i=n;i&gt;1;i--){
        swap(heap[1],heap[i]);
        upadjust(1,i-1);
    }
}
</code></pre>
</li>
<li>
<p>删除堆顶元素</p>
<pre><code>void deleteTop(){
    heap[1]=heap[n--];//用最后一个元素覆盖堆顶元素，并让元素个数减一
    downadjust(1,n);
}
</code></pre>
</li>
<li>
<p>在堆的最后插入新元素</p>
<pre><code>void upadjust(int low, int high) {//
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
void insert(int x){
    heap[++n]=x;
    upadjust(1,n);
}
</code></pre>
</li>
</ul>
<h1 id="注意">注意</h1>
<p>1.= 与 ==</p>
<p>2.变量初始化赋值时有时必须赋值为0或1</p>
<p>3.注意全局变量与局部变量</p>
<p>4.<code>s1[i]-'0'</code>，字符数组变为整型数字</p>
<p>5.<code>s1[i]&gt;='0' &amp;&amp; s1[1]&lt;='9'</code>，字符数组中寻找0到9之间的数字</p>
<p>6.注意输出结果为0时的特殊情况，隐藏的测试点等</p>
<p>7.段错误很可能是数组越界，可能是定义的数组长度不符合题目限制的最大范围</p>
<p>8.注意if 和else if 的搭配使用， 注意函数传入值node* root ，下面对应root=new node,而不是node*root=new node,输出格式<code>printf(&quot;\n&quot;)</code>,<code>printf(&quot; &quot;)</code>是否正确</p>
<p>9.如果想要在 Dev-Cpp ⾥⾯使⽤C++11, 在菜单栏中⼯具-编译选项-编译器-编译时加⼊ -std=c++11 这句命令即可</p>
<p>11.有时并不一定真的要实现出正确的算法，最后不管用什么方式，只要能输出正确的格式就好</p>
<p>12.注意设置bool型的变量用于判断</p>
<p>13.注意输入的例子中可能有无效的数据，要找出有效的数据进行处理</p>
<p>14.<code>cmp</code>中写按字母大小排序，注意写成<code>strcmp()&lt;0</code>......的形式</p>
<p>15.看题目中的数据是整数还是浮点数，注意题目中数据的保留位数</p>
<p>16.注意是使用while还是if，不要忘了break或continue，注意区分是用break还是continue</p>
<p>17.<code>long long k=(long long)p*num[i]</code>;    若新声明的变量为long long 型，右边为int乘int型，最好在右边带上强制转换(long long)，其他情况也这样吧....</p>
<p>18.注意是多个if并列 还是if与else if结合使用</p>
<p>19.int上限为<code>0x7fffffff</code>, 即2^31 -1,可以用<code>const int INF=0x7fffffff</code>,也可以写成<code>(1&lt;&lt;31)-1</code></p>
<p>​     int下限为-2^31。const double eps=1e-8(即10的-8次方，注意是数字1不是字母l)，const double     INF=1e12(即10^12)</p>
<p>20.字符数组变为数字时要注意减'0',<code>res.d[i] = str[res.len - 1 - i]-'0'</code></p>
<p>21.函数的参数前有时需要加引用&amp;</p>
<p>22.操作放在花括号内还是花括号外，注意条件的判断</p>
<p>23.注意DFS的下一层进行DFS时，要写DFS(i,height+1)  不要写height++</p>
<p>24.涉及到排序问题时，可以考虑使用set或map内部自动排序的容器，也可以先把题目中给出的数据先排序再处理</p>
<p>25.提交时出现“运行时发生错误”的情况，一般是开的数组太小，没有达到题目要求的最大值</p>
<p>26.不要忘了一些算法的初始化，比如使用并查集千万不要忘了初始化<code>father[i]=i</code></p>
<p>27一些题目处理的是五位数的格式，(比如id号)，所以输出时注意<code>printf(&quot;%05d&quot;)</code></p>
<p>28.四舍五入为整数<code>int(v[temp].gm * 0.4 + v[temp].gf * 0.6 + 0.5);</code></p>
<p>​      <strong>在最后加上0.5并强制转换为int型即为四舍五入</strong></p>
<p>29.A1139邻接矩阵的巧妙写法</p>
<pre><code>unordered_map&lt;int ,bool&gt; isfri;
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
10000为超过最大范围的整数
</code></pre>
<p>30.题目中数据量大的时候最好不用<code>cin</code>和<code>cout</code></p>
<p>31.数据量大时sort的cmp函数可以用引用传值，以防超时</p>
<p>比如</p>
<pre><code>bool cmp2(cosnt node&amp; a,const node&amp; b){
	return a.id&lt;b.id;
}
</code></pre>
<p>32.题目中同时有int型和浮点型格式的数据，最好统一定义成浮点型</p>
<ol start="33">
<li>某个测试点不过有可能是数据类型有问题，比如需要强制类型转换等等，换成数据表示范围更大的64位数据类型</li>
</ol>
<ul>
<li>
<p>层序遍历中队列里存放的是结点的地址，动态的就是node*类型，静态的就是root(int型)结点编号</p>
</li>
<li>
<p>将图当做树去处理时，注意无向图是双向的，可能会回溯已经访问的结点，要注意避免；在统计图的边权和或者点权和等信息时，为了避免重复访问或者累加，可以在访问后将点权或边权设为0</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://liuxbo.github.io/post/hello-gridea/</id>
        <link href="https://liuxbo.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>