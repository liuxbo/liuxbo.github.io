<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="菜鸡成长之路">
<meta name="theme-color" content="#000">
<title>PAT题解 | lxb&#39;blog</title>
<link rel="shortcut icon" href="https://liuxbo.github.io/favicon.ico?v=1606870490807">
<link rel="stylesheet" href="https://liuxbo.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="PAT题解" />
    <meta name="keywords" content="PAT" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>lxb&#39;blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">左手蓝银右手锤</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://liuxbo.github.io/images/avatar.png"/>
    <p class="site-author-name">lxb&#39;blog</p>
    <p class="site-description right-motion">铅华洗尽</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://liuxbo.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#a100120-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">A1001(20  两数相加)</a></li>
<li><a href="#a1002%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C">A1002(多项式求和)</a></li>
<li><a href="#a100325-dijkstra-%E7%82%B9%E6%9D%83-%E8%BE%B9%E6%9D%83">A1003(25 Dijkstra、点权、边权)</a></li>
<li><a href="#a1004">A1004</a></li>
<li><a href="#a100520-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1005(20 字符串)</a></li>
<li><a href="#a1006">A1006</a></li>
<li><a href="#a1007">A1007</a></li>
<li><a href="#a100820-%E6%B0%B4%E9%A2%98">A1008(20 水题)</a></li>
<li><a href="#a1009-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E4%B9%98">A1009 多项式相乘</a></li>
<li><a href="#a101025-%E4%BA%8C%E5%88%86">A1010(25 二分)</a></li>
<li><a href="#a1011">A1011</a></li>
<li><a href="#a101225-%E6%9D%A1%E4%BB%B6%E6%8E%92%E5%BA%8F">A1012(25 条件排序)</a></li>
<li><a href="#a101325-%E5%9B%BE%E7%9A%84dfs%E9%81%8D%E5%8E%86%E8%AE%A1%E7%AE%97%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AA%E6%95%B0">A1013(25 图的dfs遍历，计算连通块个数)</a></li>
<li><a href="#a101430-%E6%A8%A1%E6%8B%9F-%E9%9A%BE%E9%A2%98">A1014(30 模拟  难题)</a></li>
<li><a href="#a101520-%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%8E%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD">A1015(20 进制转化与素数判断)</a></li>
<li><a href="#a101625-%E6%8E%92%E5%BA%8F-%E5%A4%84%E7%90%86%E5%A4%9A%E6%9D%A1%E9%80%9A%E8%AF%9D%E6%97%B6%E9%97%B4%E8%AE%B0%E5%BD%95">A1016(25 排序 处理多条通话时间记录)</a></li>
<li><a href="#a1017-25-%E6%A8%A1%E6%8B%9F-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86-%E6%8E%92%E5%BA%8F">A1017 （25 模拟 ，时间处理、排序、）</a></li>
<li><a href="#a101830-dijkstdfs">A1018(30 dijkst+dfs)</a></li>
<li><a href="#a1019">A1019</a></li>
<li><a href="#a102025-%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%BB%BA%E6%A0%91%E8%BE%93%E5%87%BA%E5%B1%82%E5%BA%8F">A1020(25 后序+中序建树，输出层序)</a></li>
<li><a href="#a102125-%E6%89%BE%E5%87%BA%E5%9B%BE%E4%B8%AD%E4%BD%BF%E6%B7%B1%E5%BA%A6%E6%9C%80%E6%B7%B1%E7%9A%84%E7%BB%93%E7%82%B9%E9%A6%96%E5%85%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%83%BD%E7%9C%8B%E6%88%90%E6%A0%91">A1021(25 找出图中使深度最深的结点(首先判断是否能看成树))</a></li>
<li><a href="#a1022">A1022</a></li>
<li><a href="#a102320-%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%982">A1023(20 大整数乘2)</a></li>
<li><a href="#a102425-%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%E7%9B%B8%E5%8A%A0%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0">A1024(25 大整数反转相加，判断回文数)</a></li>
<li><a href="#a102525-%E6%9D%A1%E4%BB%B6%E6%8E%92%E5%BA%8F">A1025(25 条件排序)</a></li>
<li><a href="#a1027">A1027</a></li>
<li><a href="#a102825-%E6%8E%92%E5%BA%8F">A1028(25  排序)</a></li>
<li><a href="#a102925-%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0-twopoints">A1029(25 求中位数 twopoints)</a></li>
<li><a href="#a103030-dijkst%E8%B7%9D%E7%A6%BB%E6%9C%80%E7%9F%AD%E5%8A%A0%E8%8A%B1%E8%B4%B9%E6%9C%80%E5%B0%91">A1030(30 dijkst,距离最短加花费最少)</a></li>
<li><a href="#a1031">A1031</a></li>
<li><a href="#a103225-%E9%93%BE%E8%A1%A8-%E6%89%BE%E5%85%AC%E5%85%B1%E5%90%8E%E7%BC%80">A1032(25 链表  找公共后缀)</a></li>
<li><a href="#a1033">A1033</a></li>
<li><a href="#a103430-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86-map-%E8%BF%9E%E9%80%9A%E5%9D%97-%E8%BE%B9%E6%9D%83%E5%92%8C%E7%82%B9%E6%9D%83">A1034(30 图的深度遍历、map、连通块、边权和点权)</a></li>
<li><a href="#a103520-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1035(20 字符串)</a></li>
<li><a href="#a1036">A1036</a></li>
<li><a href="#a103725-%E8%B4%AA%E5%BF%83">A1037(25 贪心)</a></li>
<li><a href="#a103830-%E8%B4%AA%E5%BF%83-%E6%B1%82%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%8F%E5%88%97">A1038(30 贪心  求最小字符串序列)</a></li>
<li><a href="#a103925-vector">A1039(25 vector)</a></li>
<li><a href="#a1040">A1040</a></li>
<li><a href="#a104120-hash">A1041(20 hash)</a></li>
<li><a href="#a1042">A1042</a></li>
<li><a href="#a104325-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%8F%8D%E8%BD%AC">A1043(25 二叉搜索树的遍历与反转)</a></li>
<li><a href="#a104425-%E4%BA%8C%E5%88%86">A1044(25 二分)</a></li>
<li><a href="#a1045">A1045</a></li>
<li><a href="#a1046">A1046</a></li>
<li><a href="#a104725-vector">A1047(25 vector)</a></li>
<li><a href="#a104825">A1048(25 )</a></li>
<li><a href="#a104930-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%981%E7%9A%84%E4%B8%AA%E6%95%B0">A1049(30  数学问题：&quot;1&quot;的个数)</a></li>
<li><a href="#a105020-hash">A1050(20 hash)</a></li>
<li><a href="#a105125-%E6%A0%88">A1051(25 栈)</a></li>
<li><a href="#a105225-%E9%93%BE%E8%A1%A8%E6%8C%89key%E6%8E%92%E5%BA%8F">A1052(25 链表按key排序)</a></li>
<li><a href="#a105330-%E8%BE%93%E5%87%BA%E6%9D%83%E5%80%BC%E6%80%BB%E5%92%8C%E5%90%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84dfs">A1053(30 输出权值总和同为给定值的路径(dfs))</a></li>
<li><a href="#a105420-map">A1054(20 map)</a></li>
<li><a href="#a105525-%E6%8C%89%E6%9D%A1%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%BE%93%E5%87%BA">A1055(25 按条件查找并排序输出)</a></li>
<li><a href="#a105625-queue%E9%98%9F%E5%88%97">A1056(25 queue队列)</a></li>
<li><a href="#a105730-%E5%88%86%E5%9D%97-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">A1057(30 分块、树状数组)</a></li>
<li><a href="#a105820-%E6%B0%B4%E9%A2%98">A1058(20 水题)</a></li>
<li><a href="#a105925-%E5%BB%BA%E7%AB%8B%E7%B4%A0%E6%95%B0%E8%A1%A8-%E6%B1%82%E7%B4%A0%E6%95%B0%E5%9B%A0%E6%95%B0">A1059(25 建立素数表 求素数因数)</a></li>
<li><a href="#a106025-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">A1060(25 字符串 科学计数法)</a></li>
<li><a href="#a106120-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1061(20 字符串)</a></li>
<li><a href="#a1062">A1062</a></li>
<li><a href="#a106325-set">A1063(25 set)</a></li>
<li><a href="#a106430-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BB%BA%E6%A0%91">A1064(30 完全二叉树(中序遍历建树))</a></li>
<li><a href="#a1065">A1065</a></li>
<li><a href="#a106625-%E5%BB%BA%E7%AB%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">A1066(25 建立平衡二叉树)</a></li>
<li><a href="#a106725-%E8%B4%AA%E5%BF%83-swap%E6%8E%92%E5%BA%8F%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0">A1067(25  贪心 swap排序，求最小交换次数)</a></li>
<li><a href="#a1068">A1068</a></li>
<li><a href="#a106920-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E">A1069(20 数字黑洞)</a></li>
<li><a href="#a107025-%E8%B4%AA%E5%BF%83">A1070(25 贪心)</a></li>
<li><a href="#a107125-map-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1071(25 map  字符串)</a></li>
<li><a href="#a107230-%E5%A4%9A%E6%BA%90dijkst%E6%B1%82%E6%9C%80%E4%BD%B3%E6%BA%90">A1072(30 多源dijkst求最佳源)</a></li>
<li><a href="#a1073-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">A1073 科学计数法</a></li>
<li><a href="#a107425-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">A1074(25 反转链表)</a></li>
<li><a href="#a107525-%E6%8E%92%E5%BA%8F">A1075(25 排序)</a></li>
<li><a href="#a107630-%E5%9B%BE%E7%9A%84bfs-%E8%AE%B0%E5%BD%95%E7%BB%99%E5%AE%9A%E6%9C%80%E5%A4%A7%E5%B1%82%E6%95%B0%E4%B8%8A%E7%9A%84%E7%BB%93%E7%82%B9%E5%92%8C">A1076(30 图的bfs、记录给定最大层数上的结点和)</a></li>
<li><a href="#a107720-%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%BE%E5%85%AC%E5%85%B1%E5%90%8E%E7%BC%80">A1077(20  多个字符串找公共后缀)</a></li>
<li><a href="#a107825-hash-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5">A1078(25 hash 平方探查)</a></li>
<li><a href="#a107925-%E6%A0%91%E7%9A%84dfs">A1079(25 树的dfs)</a></li>
<li><a href="#a108030-%E6%8E%92%E5%BA%8F">A1080(30 排序)</a></li>
<li><a href="#a108120-%E5%88%86%E6%95%B0%E7%9B%B8%E5%8A%A0">A1081(20 分数相加)</a></li>
<li><a href="#a108225-%E5%88%86%E6%AE%B5%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2">A1082(25 分段处理字符串)</a></li>
<li><a href="#a108325-%E6%8E%92%E5%BA%8F">A1083(25 排序)</a></li>
<li><a href="#a108420-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1084(20 字符串)</a></li>
<li><a href="#a108525-%E4%BA%8C%E5%88%86-twopoints-%E5%A4%9A%E8%A7%A3%E6%B3%95">A1085(25 二分 twopoints 多解法)</a></li>
<li><a href="#a108625-%E6%A0%88%E6%A8%A1%E6%8B%9F%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%85%88%E5%BA%8F%E5%BB%BA%E6%A0%91%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F">A1086(25 栈模拟中序和先序建树，输出后序)</a></li>
<li><a href="#a108730-dijkstdfs%E8%BE%B9%E6%9D%83%E7%82%B9%E6%9D%83-%E6%80%BB%E8%BE%B9%E6%9D%83-%E5%B9%B3%E5%9D%87%E7%82%B9%E6%9D%83">A1087(30 dijkst+dfs,边权点权、总边权、平均点权)</a></li>
<li><a href="#a108820-%E5%88%86%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4">A1088(20  分数的加减乘除)</a></li>
<li><a href="#a1089-25-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">A1089  (25 插入排序和归并排序)</a></li>
<li><a href="#a109025-%E6%A0%91%E7%9A%84dfs%E6%B1%82%E6%B7%B1%E5%BA%A6">A1090(25 树的dfs求深度)</a></li>
<li><a href="#a109130-%E7%BB%8F%E5%85%B8bfs%E6%B1%82%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0">A1091(30 经典BFS求矩阵中块的个数)</a></li>
<li><a href="#a1092%E5%AD%97%E7%AC%A6%E4%B8%B2-hash">A1092(字符串 hash)</a></li>
<li><a href="#a109325-%E9%80%BB%E8%BE%91%E9%A2%98">A1093(25 逻辑题)</a></li>
<li><a href="#a109425-%E6%A0%91%E7%9A%84dfs">A1094(25 树的dfs)</a></li>
<li><a href="#a109530-%E6%A0%A1%E5%9B%AD%E5%81%9C%E8%BD%A6-%E6%8E%92%E5%BA%8F-%E4%B8%A4%E8%BE%86%E9%85%8D%E5%AF%B9-%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2%E8%BE%93%E5%87%BA">A1095(30 校园停车 排序  两辆配对  时间查询输出)</a></li>
<li><a href="#a109620-%E6%89%BE%E5%87%BA%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%9B%A0%E6%95%B0">A1096(20 找出连续的因数)</a></li>
<li><a href="#a109725-%E9%93%BE%E8%A1%A8%E5%88%86%E7%A6%BB">A1097(25 链表分离)</a></li>
<li><a href="#a109825-%E5%88%A4%E6%96%AD%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F">A1098(25 判断插入排序和堆排序)</a></li>
<li><a href="#a109930-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">A1099(30 中序遍历建立二叉搜索树)</a></li>
<li><a href="#a110020-%E5%AD%97%E7%AC%A6%E4%B8%B2-string-map">A1100(20 字符串 string map)</a></li>
<li><a href="#a110125-%E9%80%BB%E8%BE%91%E9%A2%98">A1101(25 逻辑题)</a></li>
<li><a href="#a110225-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8D%E8%BD%AC">A1102(25 二叉树反转)</a></li>
<li><a href="#a110330-dfs-%E5%88%86%E8%A7%A3%E5%9B%A0%E5%BC%8F">A1103(30 DFS 分解因式)</a></li>
<li><a href="#a110420-%E7%89%87%E6%AE%B5%E5%92%8C-%E9%80%BB%E8%BE%91%E9%A2%98">A1104(20 片段和 逻辑题)</a></li>
<li><a href="#a110525-%E9%A1%BA%E6%97%B6%E9%92%88%E8%9E%BA%E6%97%8B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%B3%A8%E6%84%8F%E5%88%A4%E6%96%AD%E4%B8%8B%E6%A0%87%E8%B6%8A%E7%95%8C">A1105(25 顺时针螺旋二维数组，注意判断下标越界)</a></li>
<li><a href="#a110625-%E6%A0%91%E7%9A%84dfs">A1106(25 树的dfs)</a></li>
<li><a href="#a110730-%E7%BB%8F%E5%85%B8%E5%B9%B6%E6%9F%A5%E9%9B%86">A1107(30 经典并查集)</a></li>
<li><a href="#a110820-%E5%AD%97%E7%AC%A6%E4%B8%B2-sscanf-sprintf">A1108(20 字符串 sscanf、sprintf)</a></li>
<li><a href="#a110925-%E6%8E%92%E5%BA%8F">A1109(25 排序)</a></li>
<li><a href="#a111025-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-dfs">A1110(25 判断是否是完全二叉树 dfs)</a></li>
<li><a href="#a111130-%E4%B8%A4%E6%AC%A1dijkst%E5%8A%A0dfs%E6%9C%80%E7%9F%AD-%E6%9C%80%E5%BF%AB%E8%B7%AF%E5%BE%84-%E7%BB%93%E7%82%B9%E6%9C%80%E5%B0%91%E8%B7%AF%E5%BE%84">A1111(30 两次dijkst加dfs,最短、最快路径、结点最少路径)</a></li>
<li><a href="#a111220-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%89%BE%E5%87%BA%E5%9D%8F%E9%94%AE">A1112(20 字符串、找出“坏键”)</a></li>
<li><a href="#a111325-%E6%B0%B4%E9%A2%98">A1113(25 水题)</a></li>
<li><a href="#a1114-25-%E5%B9%B6%E6%9F%A5%E9%9B%86">A1114 (25 并查集)</a></li>
<li><a href="#a111530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8Edfs">A1115(30 二叉搜索树建立与DFS)</a></li>
<li><a href="#a111620-%E6%B0%B4%E9%A2%98">A1116(20 水题)</a></li>
<li><a href="#a111725-%E9%80%BB%E8%BE%91%E9%A2%98">A1117(25 逻辑题)</a></li>
<li><a href="#a111825-%E5%B9%B6%E6%9F%A5%E9%9B%86">A1118(25 并查集)</a></li>
<li><a href="#a1119-30-%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F-%E6%B1%82%E4%B8%AD%E5%BA%8F">A1119 (30 树的前序和后序 求中序)</a></li>
<li><a href="#a112020-%E6%B0%B4%E9%A2%98">A1120(20 水题)</a></li>
<li><a href="#a1121-25-map-set%E5%BA%94%E7%94%A8">A1121 (25 map、set应用)</a></li>
<li><a href="#a112225-%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF-set">A1122(25 哈密顿回路  set)</a></li>
<li><a href="#a112330-avl-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">A1123(30 AVL 、层序遍历、判断是否是完全二叉树)</a></li>
<li><a href="#a1124-20-%E9%80%BB%E8%BE%91%E9%A2%98">A1124  20 逻辑题</a></li>
<li><a href="#a112525-%E8%B4%AA%E5%BF%83-%E6%8E%92%E5%BA%8F">A1125(25 贪心 排序)</a></li>
<li><a href="#a112625-%E6%AC%A7%E6%8B%89%E5%9B%BE-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84">A1126(25 欧拉图 欧拉回路 欧拉路径)</a></li>
<li><a href="#a112730-%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E5%BB%BA%E6%A0%91dfs%E8%BE%93%E5%87%BAz%E5%AD%97%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">A1127(30 中序后序建树，dfs，输出z字形层序遍历)</a></li>
<li><a href="#a112820-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">A1128(20  n皇后问题)</a></li>
<li><a href="#a1129-25-set%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">A1129 (25 set的应用 结构体内运算符重载)</a></li>
<li><a href="#a1130%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BE%93%E5%87%BA%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">A1130(中序遍历二叉树 输出中缀表达式)</a></li>
<li><a href="#a113130-dfs-unordered_map%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E9%9A%BE%E9%A2%98">A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</a></li>
<li><a href="#a113220-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%B0%B4%E9%A2%98">A1132(20 字符串 水题)</a></li>
<li><a href="#a1133%E9%93%BE%E8%A1%A8-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97">A1133(链表  重新排列)</a></li>
<li><a href="#a113425-hash%E6%95%A3%E5%88%97">A1134(25 hash散列)</a></li>
<li><a href="#a113530-%E5%88%A4%E6%96%AD%E7%BA%A2%E9%BB%91%E6%A0%91-%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD">A1135(30 判断红黑树 递归判断)</a></li>
<li><a href="#a1136-20-%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1136 (20 回文串 字符串)</a></li>
<li><a href="#a113725-map-%E6%8E%92%E5%BA%8F">A1137(25 map 排序)</a></li>
<li><a href="#a113825-%E6%A0%91-%E5%89%8D%E5%BA%8F%E5%8A%A0%E4%B8%AD%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F">A1138(25 树 前序加中序输出后序)</a></li>
<li><a href="#a113930-%E9%80%BB%E8%BE%91%E9%A2%98-unordered_map">A1139(30 逻辑题 unordered_map)</a></li>
<li><a href="#a114020-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1140(20 字符串)</a></li>
<li><a href="#a114125-stl-%E6%8E%92%E5%BA%8F">A1141(25 stl、排序)</a></li>
<li><a href="#a114225-%E6%97%A0%E5%90%91%E5%AE%8C%E5%85%A8%E5%9B%BE-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%9B%BE-%E4%B8%A4%E7%82%B9%E7%9B%B8%E8%BF%9E">A1142(25 无向完全图 最大子图  两点相连)</a></li>
<li><a href="#a114330-%E6%A0%91-lca-%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">A1143(30 树 LCA 最低公共祖先)</a></li>
<li><a href="#a114525-hash-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5">A1145(25 hash 平方探查)</a></li>
<li><a href="#a114420-%E6%89%BE%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0">A1144(20 找丢失的最小正数)</a></li>
<li><a href="#a114525-hash-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5%E6%B3%95%E6%8F%92%E5%85%A5%E4%B8%8E%E6%9F%A5%E6%89%BE">A1145(25 hash 平方探查法插入与查找)</a></li>
<li><a href="#a114625-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%BA%8F%E5%88%97">A1146(25 判断是否为拓扑排序序列)</a></li>
<li><a href="#a114730-%E5%88%A4%E6%96%AD%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%B0%8F%E9%A1%B6%E5%A0%86-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">A1147(30  判断大顶堆小顶堆 后序遍历)</a></li>
<li><a href="#a1148%E7%8B%BC%E4%BA%BA%E6%9D%80-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E7%8B%BC%E4%BA%BA">A1148(狼人杀 找到两个狼人)</a></li>
<li><a href="#a114925-map">A1149(25 map)</a></li>
<li><a href="#a115025-%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%9B%BE-%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84">A1150(25 判断循环图 输出最小路径)</a></li>
<li><a href="#a115130-%E6%A0%91-%E4%B8%AD%E5%BA%8F%E5%8A%A0%E5%85%88%E5%BA%8F%E6%B1%82lca">A1151(30  树 中序加先序求LCA)</a></li>
<li><a href="#a115220-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AAk%E4%BD%8D%E7%B4%A0%E6%95%B0">A1152(20 字符串中找第一个k位素数)</a></li>
<li><a href="#a115325-%E6%A8%A1%E6%8B%9F-%E6%8E%92%E5%BA%8F%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82-unordered_map">A1153(25 模拟 排序引用传参  unordered_map)</a></li>
<li><a href="#a115425-%E5%9B%BE-%E8%BE%B9%E7%9A%84%E4%B8%A4%E7%AB%AF%E7%82%B9%E7%9A%84%E5%88%A4%E6%96%AD">A1154(25 图  边的两端点的判断  )</a></li>
<li><a href="#a115530-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%A4%E6%96%AD%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%B0%8F%E9%A1%B6%E5%A0%86-dfs-%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84">A1155(30 完全二叉树  判断大顶堆小顶堆 dfs  打印路径)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://liuxbo.github.io/post/pat-ti-jie/">
      PAT题解
    </a>
  </h1>
  <div class="post-meta">
    
      <span class="meta-item">
        <i class="fa fa-thumb-tack"></i>
        <span>置顶</span>
        <span class="post-meta-divider">|</span>
      </span>
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-05-06</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
      <span class="meta-item">
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://liuxbo.github.io/tag/a8Kpb5X9y/">
              <span>PAT</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>191分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>31124<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <h3 id="a100120-两数相加">A1001(20  两数相加)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	int a,b;
	cin&gt;&gt;a&gt;&gt;b;
	string s=to_string(a+b);
	int len=s.length();
	for(int i=0;i&lt;len;i++){
		cout&lt;&lt;s[i];
		if(s[i]=='-') continue;
		if((i+1)%3==len%3&amp;&amp;i!=len-1) cout&lt;&lt;&quot;,&quot;;
	}
	return 0;
}
</code></pre>
<h3 id="a1002多项式求和">A1002(多项式求和)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=1001;
int count1,count2;
double coe[maxn]={},a;
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
	while(count1--){
		int i;
	    scanf(&quot;%d%lf&quot;,&amp;i,&amp;a);
		coe[i]=coe[i]+a;
	}
	scanf(&quot;%d&quot;,&amp;count2);
	while(count2--){
        int k;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		coe[k]=coe[k]+a;
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0) printf(&quot; %d %.1f&quot;,k,coe[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a100325-dijkstra-点权-边权">A1003(25 Dijkstra、点权、边权)</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=510;
const int INF=0x7fffffff;
int n,m,c1,c2,weight[maxn],g[maxn][maxn],d[maxn],w[maxn],num[maxn]={0};
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(vis,vis+maxn,false);
	fill(w,w+maxn,0);
	d[s]=0;
	num[s]=1;
	w[s]=weight[s];
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int j=0;j&lt;n;j++){
			if(g[u][j]!=INF&amp;&amp;vis[j]==false){
				if(d[u]+g[u][j]&lt;d[j]){
					d[j]=d[u]+g[u][j];
					num[j]=num[u];
				    w[j]=w[u]+weight[j];
				}else if(d[u]+g[u][j]==d[j]){
					num[j]+=num[u];
					if(w[u]+weight[j]&gt;w[j]) w[j]=w[u]+weight[j];
				}
			}
		}
	}
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i];
	fill(g[0],g[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int v1,v2,t;
		cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;t;
		g[v1][v2]=g[v2][v1]=t;
	}
	dijkst(c1);
	printf(&quot;%d %d&quot;,num[c2],w[c2]);
	return 0;
}
</code></pre>
<h3 id="a1004">A1004</h3>
<pre><code>1.DFS法
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		level[depth]++;
		if(depth&gt;maxdepth)	maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		while(k--){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,0);
	for(int i=0;i&lt;=maxdepth;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,level[i]);
	}
	return 0;
}

2.BFS法
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int hashtable[maxn] = { 0 };
vector&lt;int&gt; child[maxn];
int n, m, level[maxn] = { 0 },maxlevel=0;
void BFS() {
	level[1] = 1;
	queue&lt;int&gt; q;
	q.push(1);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		if (child[now].size() == 0) {
			hashtable[level[now]]++;
			maxlevel = max(maxlevel, level[now]);
		}
		for (int i = 0; i &lt; child[now].size(); i++) {
			level[child[now][i]] = level[now] + 1;
			q.push(child[now][i]);
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int father,num,temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father, &amp;num);
		while (num--) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[father].push_back(temp);
		}
	}
	BFS();
	for (int i = 1; i &lt;= maxlevel; i++) {
		printf(&quot;%d&quot;, hashtable[i]);
		if (i &lt; maxlevel) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a100520-字符串">A1005(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n,spell[10]={&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;};
	cin&gt;&gt;n;
	int sum=0;
	for(int i=0;i&lt;n.size();i++) sum+=(n[i]-'0');
	string ans=to_string(sum);
	cout&lt;&lt;spell[ans[0]-'0'];
	for(int i=1;i&lt;ans.size();i++) cout&lt;&lt;&quot; &quot;&lt;&lt;spell[ans[i]-'0'];
	return 0;
}
</code></pre>
<h3 id="a1006">A1006</h3>
<pre><code>#include&lt;cstdio&gt; 

struct person {
	char id[16];
	int hh, mm, ss;
}temp,first,last;
bool great(person node1, person node2) {
	if (node1.hh != node2.hh) return node1.hh &gt; node2.hh;
	if (node2.mm != node2.mm) return node1.mm &gt; node2.mm;
	return node1.ss &gt; node2.ss;
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	first.hh = 24, first.mm = 60, first.ss = 60;
	last.hh = 0, last.mm = 0, last.ss = 0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %d:%d:%d&quot;, temp.id, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, first) == false)  first = temp;
		scanf(&quot;%d:%d:%d&quot;, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, last))   last = temp;
	}
	printf(&quot;%s %s&quot;, first.id, last.id);
	return 0;
}
</code></pre>
<h3 id="a1007">A1007</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
	dp[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
<h3 id="a100820-水题">A1008(20 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,ans=0;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1,0);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;v[i];
		if(v[i]&gt;v[i-1]) ans+=(v[i]-v[i-1])*6;
		else ans+=(v[i-1]-v[i])*4;
		ans+=5;
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1009-多项式相乘">A1009 多项式相乘</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=2001;
int count1,count2;
struct poly{
	int exp;
	double coef;
}coe[1001];
double result[maxn];
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
for(int i =0;i&lt;count1;i++){
	scanf(&quot;%d%lf&quot;,&amp;coe[i].exp,&amp;coe[i].coef);
    }
	scanf(&quot;%d&quot;,&amp;count2);
for(int i=0;i&lt;count2;i++){
	int k;
	double a;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		for(int i=0;i&lt;count1;i++){
			result[k+coe[i].exp]+=(a*coe[i].coef);
		}
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0) printf(&quot; %d %.1f&quot;,k,result[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a101025-二分">A1010(25 二分)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
long long convert(string n,long long radix){
	long long sum=0,index=0,temp;
	for(auto it=n.rbegin();it!=n.rend();it++){
		temp=isdigit(*it)? (*it)-'0' : (*it)-'a'+10;
		sum+=temp*pow(radix,index++);
	}
	return sum;
}
long long findradix(string n,long long num){
	char it=*max_element(n.begin(),n.end());
	long long low=(isdigit(it)? (it)-'0' : (it)-'a'+10)+1;
	long long high=max(low,num);
	while(low&lt;=high){
		long long mid=(low+high)/2;
		long long temp=convert(n,mid);
		if(temp&lt;0||temp&gt;num) high=mid-1;//小于0的情况是进制太大导致溢出 
		else if(temp==num) return mid;
		else low=mid+1;
	}
	return -1;
}
int main(){
	string n1,n2;
	long long tag,radix,ans;
	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;tag&gt;&gt;radix;
	ans=tag==1?findradix(n2,convert(n1,radix)) : findradix(n1,convert(n2,radix));
	if(ans==-1) cout&lt;&lt;&quot;Impossible&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a1011">A1011</h3>
<pre><code>#include&lt;cstdio&gt; 
char s[4] = &quot;WTL&quot;;
double a,res=1;
int main() {
	for (int i = 0; i &lt; 3; i++) {
		int imax;
		double temp = 0;
		for (int i = 0; i &lt; 3; i++) {
			scanf_s(&quot;%lf&quot;, &amp;a);
			if (a &gt; temp) {
				temp = a;
				imax = i;
			}
		}
		res *= temp;
		printf(&quot;%c &quot;, s[imax]);
	}
	printf(&quot;%.2f&quot;, (res * 0.65 - 1) * 2);
	return 0;
}
</code></pre>
<h3 id="a101225-条件排序">A1012(25 条件排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
struct node{
	int id;
	int score[4];
}stu[2000];
int now,rk[1000000][4];
bool cmp(node a,node b){
	return a.score[now]&gt;b.score[now];
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	map&lt;int,bool&gt; mp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;stu[i].id,&amp;stu[i].score[1],&amp;stu[i].score[2],&amp;stu[i].score[3]);
		stu[i].score[0]=(int)((stu[i].score[1]+stu[i].score[2]+stu[i].score[3])*1.0/3+0.5);
		mp[stu[i].id]=true;
	}
	for(now=0;now&lt;=3;now++){
		sort(stu,stu+n,cmp);
		rk[stu[0].id][now]=1;
		for(int i=1;i&lt;n;i++){
			if(stu[i].score[now]==stu[i-1].score[now]) rk[stu[i].id][now]=rk[stu[i-1].id][now];
			else rk[stu[i].id][now]=i+1;
		}
	}
	char course[4]={'A','C','M','E'};
	for(int i=0;i&lt;m;i++){
		int query,bestrank=9999,index=0;
		scanf(&quot;%d&quot;,&amp;query);
		if(mp.count(query)==0){
			printf(&quot;N/A\n&quot;);
			continue;
		}
		for(int j=0;j&lt;4;j++){
			if(rk[query][j]&lt;bestrank){
				bestrank=rk[query][j];
				index=j;
			}
		}
		printf(&quot;%d %c\n&quot;,rk[query][index],course[index]);
	}
	return 0;
}
</code></pre>
<h3 id="a101325-图的dfs遍历计算连通块个数">A1013(25 图的dfs遍历，计算连通块个数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int n,m,k,G[maxn][maxn],cnt=0;
bool vis[maxn];
void dfs(int v){
	vis[v]=true;
	for(int i=1;i&lt;=n;i++){
		if(G[v][i]==1&amp;&amp;vis[i]==false) dfs(i);
	}
}
int main(){
	int a,b;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		G[a][b]=G[b][a]=1;
	}
	while(k--){
		int cnt=0;
		fill(vis,vis+maxn,false);
		scanf(&quot;%d&quot;,&amp;a);
		vis[a]=true;
		for(int i=1;i&lt;=n;i++){
			if(vis[i]==false){
				dfs(i);
				cnt++;
			}
		}
		printf(&quot;%d\n&quot;,cnt-1);//需要添加的路径为连通块个数减1 
	}
	return 0;
}
</code></pre>
<h3 id="a101430-模拟-难题">A1014(30 模拟  难题)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node {
	int poptime, endtime;
	queue&lt;int&gt; q;
};
int main() {
	int n, m, k, Q, index = 1, query;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;Q);
	vector&lt;int&gt; time(k + 1), ans(k + 1);
	for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;time[i]);
	vector&lt;node&gt;window(n + 1);
	vector&lt;bool&gt;sorry(k + 1, false);
	for (int i = 1; i &lt;= m; i++) {
		for (int j = 1; j &lt;= n; j++) {
			if (index &lt;= k) {
				window[j].q.push(time[index]);
				if (window[j].endtime &gt;= 540) sorry[index] = true;
				window[j].endtime += time[index];
				if (i == 1) window[j].poptime = window[j].endtime;
				ans[index] = window[j].endtime;
				index++;
			}
		}
	}
	while (index &lt;= k) {
		int minpoptime = window[1].poptime, tempwindow = 1;
		for (int i = 2; i &lt;= n; i++) {
			if (window[i].poptime &lt; minpoptime) {
				minpoptime = window[i].poptime;
				tempwindow = i;
			}
		}
		window[tempwindow].q.pop();
		window[tempwindow].poptime += window[tempwindow].q.front();
		window[tempwindow].q.push(time[index]);
		if (window[tempwindow].endtime &gt;= 540) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		ans[index] = window[tempwindow].endtime;
		index++;
	}
	while (Q--) {
		scanf(&quot;%d&quot;, &amp;query);
		if (sorry[query] == true) printf(&quot;Sorry\n&quot;);
		else printf(&quot;%02d:%02d\n&quot;, (ans[query] + 480) / 60, (ans[query] + 480) % 60);
	}
	return 0;
}
</code></pre>
<h3 id="a101520-进制转化与素数判断">A1015(20 进制转化与素数判断)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int change(int n,int b){
	vector&lt;int&gt; v;
	int ans=0;
	while(n!=0){
		v.push_back(n%b);
		n/=b;
	}
	for(int i=v.size()-1;i&gt;=0;i--) ans+=v[i]*pow(b,v.size()-1-i);
	return ans;
}
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int n,b;
	while(1){
		scanf(&quot;%d&quot;,&amp;n);
		if(n&lt;0) return 0;
		scanf(&quot;%d&quot;,&amp;b);
		if(isprime(n)&amp;&amp;isprime(change(n,b))) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
}
</code></pre>
<h3 id="a101625-排序-处理多条通话时间记录">A1016(25 排序 处理多条通话时间记录)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt; 
using namespace std;
struct node{
	string name;
	int status,time,month,day,hour,minute;
};
bool cmp(node a,node b){
	return a.name!=b.name? a.name&lt;b.name : a.time&lt;b.time;
}
double billfromzero(node a,int *rate){
	double total=a.minute*rate[a.hour]+a.day*60*rate[24];
	for(int i=0;i&lt;a.hour;i++) total+=60*rate[i];
	return total/100.0;
}
 int main(){
 	int n,rate[25]={0};
 	for(int i=0;i&lt;24;i++){
 		scanf(&quot;%d&quot;,&amp;rate[i]);
 		rate[24]+=rate[i];
	 }
	 cin&gt;&gt;n;
	 vector&lt;node&gt; v(n);
	 for(int i=0;i&lt;n;i++){
	 	cin&gt;&gt;v[i].name;
	 	scanf(&quot;%d:%d:%d:%d&quot;,&amp;v[i].month,&amp;v[i].day,&amp;v[i].hour,&amp;v[i].minute);
	 	v[i].time=v[i].day*24*60+v[i].hour*60+v[i].minute;
	 	string temp;
	 	cin&gt;&gt;temp;
	 	v[i].status=(temp==&quot;on-line&quot;)? 1 : 0 ;
	 } 
	 sort(v.begin(),v.end(),cmp);
	 map&lt;string,vector&lt;node&gt; &gt;mp;
	 for(int i=1;i&lt;n;i++){
	 	if(v[i].name==v[i-1].name&amp;&amp;v[i-1].status==1&amp;&amp;v[i].status==0){
	 		mp[v[i-1].name].push_back(v[i-1]);
	 		mp[v[i].name].push_back(v[i]);
		 }
	 }
	 for(auto it:mp){
	 	cout&lt;&lt; it.first;
	 	vector&lt;node&gt; temp=it.second;
	 	printf(&quot; %02d\n&quot;,temp[0].month);
	 	double total=0.0;
	 	for(int i=1;i&lt;temp.size();i+=2){
	 		double t=billfromzero(temp[i],rate)-billfromzero(temp[i-1],rate);
	 		printf(&quot;%02d:%02d:%02d&quot;,temp[i-1].day,temp[i-1].hour,temp[i-1].minute);
			printf(&quot; %02d:%02d:%02d %d&quot;,temp[i].day,temp[i].hour,temp[i].minute,temp[i].time-temp[i-1].time);
			printf(&quot; $%.2f\n&quot;,t);
			total+=t;
		 }
		 printf(&quot;Total amount: $%.2f\n&quot;,total);
	 } 
	 return 0;
 }
</code></pre>
<h3 id="a1017-25-模拟-时间处理-排序">A1017 （25 模拟 ，时间处理、排序、）</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int cometime,servetime;
}; 
bool cmp(node a,node b){
	return a.cometime&lt;b.cometime;
}
int main(){
	int n,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	double ans=0.0;
	node temp;
	vector&lt;node&gt; v;
	for(int i=0;i&lt;n;i++){
		int hh,mm,ss,serve;
		scanf(&quot;%d:%d:%d %d&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;serve);
		temp.cometime=hh*3600+mm*60+ss;
		temp.servetime=serve*60;
		if(temp.cometime&gt;61200) continue;
		v.push_back(temp);
	}
	sort(v.begin(),v.end(),cmp);
	vector&lt;int&gt; window(k,28800);
	for(int i=0;i&lt;v.size();i++){
		int minend=window[0],index=0;
		for(int j=1;j&lt;k;j++){
			if(window[j]&lt;minend){
				minend=window[j];
				index=j;
			}
		}
		if(v[i].cometime&gt;window[index]) window[index]=v[i].cometime+v[i].servetime;
		else if(v[i].cometime&lt;=window[index]){
			ans+=(window[index]-v[i].cometime);
			window[index]+=v[i].servetime; 
		}
	}
	if(v.size()==0) printf(&quot;0.0&quot;);
	else printf(&quot;%.1f&quot;,(ans/60.0)/v.size());
	return 0;
}
</code></pre>
<h3 id="a101830-dijkstdfs">A1018(30 dijkst+dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=520;
const int INF=0x7fffffff;
int cmax,n,sp,m,minneed=INF,minremain=INF;
int weight[maxn],G[maxn][maxn],d[maxn];
bool vis[maxn]={false};
vector&lt;int&gt;pre[maxn];
vector&lt;int&gt;temp,path;
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;=n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;=n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int j=0;j&lt;=n;j++){
			if(G[u][j]!=INF&amp;&amp;vis[j]==false){
				if(G[u][j]+d[u]&lt;d[j]){
					d[j]=G[u][j]+d[u];
					pre[j].clear();
					pre[j].push_back(u);
				}else if(G[u][j]+d[u]==d[j]) pre[j].push_back(u);
			}
		}
	}
}
void dfs(int s){
	if(s==0){
		temp.push_back(s);//注意 
		int need=0,remain=0;
		for(int i=temp.size()-1;i&gt;=0;i--){
			if(weight[temp[i]]&gt;0) remain+=weight[temp[i]];
			if(weight[temp[i]]&lt;0){
				if(abs(weight[temp[i]])&gt;remain){
					need+=abs(weight[temp[i]])-remain;
				    remain=0;
				}else remain-=abs(weight[temp[i]]);
			}
		}
		if(need&lt;minneed){
			minneed=need;
			minremain=remain;//注意
			path=temp;
		}else if(need==minneed&amp;&amp;remain&lt;minremain){
			minremain=remain;
			path=temp;
		}
		temp.pop_back();//注意
		return;
	}
	temp.push_back(s);
	for(int i=0;i&lt;pre[s].size();i++) dfs(pre[s][i]);
	temp.pop_back();
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;cmax,&amp;n,&amp;sp,&amp;m);
	for(int i=1;i&lt;=n;i++) {
		scanf(&quot;%d&quot;,&amp;weight[i]);
		weight[i]-=cmax/2;
	}
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int a,b,c;
		scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
		G[a][b]=G[b][a]=c;
	}
	dijkst(0);
	dfs(sp);
	printf(&quot;%d &quot;,minneed);
	for(int i=path.size()-1;i&gt;=0;i--){
		printf(&quot;%d&quot;,path[i]);
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	printf(&quot; %d&quot;,minremain);
	return 0;
}
</code></pre>
<h3 id="a1019">A1019</h3>
<pre><code>#include&lt;cstdio&gt;
 int main(){
 	int n,b,ans[50],index=0;
 	scanf(&quot;%d%d&quot;,&amp;n,&amp;b);
 	while(n!=0){
 		ans[index++]=n%b;
 		n/=b;
	 }
	 bool flag=true;
	 for(int i=0;i&lt;=index/2;i++){
	 	if(ans[i]!=ans[index-i-1]) flag=false;
	 }
	 if(flag==false) printf(&quot;No\n&quot;);
	 else printf(&quot;Yes\n&quot;);
	 for(int i=index-1;i&gt;=0;i--){
	 	if(i!=index-1) printf(&quot; &quot;);
	 	printf(&quot;%d&quot;,ans[i]);
	 }
	 return 0; 
 }
</code></pre>
<h3 id="a102025-后序中序建树输出层序">A1020(25 后序+中序建树，输出层序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=31;
struct node{
	int data;
	node *left,*right;
};
int post[maxn],in[maxn],n,num=0;
node * create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;data=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root;
}
void layerorder(node *root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		node* Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top-&gt;data);
		num++;
		if(num&lt;n) printf(&quot; &quot;);
		if(Top-&gt;left!=NULL) q.push(Top-&gt;left);
		if(Top-&gt;right!=NULL) q.push(Top-&gt;right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	node*root=create(0,n-1,0,n-1);
	layerorder(root);
	return 0;
}
</code></pre>
<h3 id="a102125-找出图中使深度最深的结点首先判断是否能看成树">A1021(25 找出图中使深度最深的结点(首先判断是否能看成树))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
bool vis[10010]; 
int n,maxheight=-1;
vector&lt;int&gt; ans,G[10010];
void dfs(int index,int height){
	vis[index]=true;
	if(height&gt;maxheight){
		maxheight=height;
		ans.clear();
		ans.push_back(index);
	}else if(height==maxheight) ans.push_back(index);
	for(int i=0;i&lt;G[index].size();i++){
		if(vis[G[index][i]]==false) dfs(G[index][i],height+1); 
	} 
}
int main(){
	int v1,v2,cnt=0,st;
	set&lt;int&gt; res;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n-1;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		G[v1].push_back(v2);
		G[v2].push_back(v1);
	} 
	fill(vis,vis+10010,false);
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			dfs(i,0);
			if(i==1){
				if(ans.size()!=0) st=ans[0];
				for(int j=0;j&lt;ans.size();j++) res.insert(ans[j]);
			} 
			cnt++;
		}
	}
	if(cnt&gt;1) printf(&quot;Error: %d components&quot;,cnt);
	else{
		ans.clear(); 
		fill(vis,vis+10010,false);
		maxheight=-1;
		dfs(st,0);
		for(int i=0;i&lt;ans.size();i++) res.insert(ans[i]);
		for(auto it=res.begin();it!=res.end();it++) printf(&quot;%d\n&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1022">A1022</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string, set&lt;int&gt; &gt; mptitle, mpautor, mpkey, mppublish, mpyear;
void query(map&lt;string, set&lt;int&gt; &gt;&amp; mp, string&amp; str) {
	if (mp.count(str) == 0) cout &lt;&lt; &quot;Not Found\n&quot;;
	else {
		for (auto it = mp[str].begin(); it != mp[str].end(); it++) {
			printf(&quot;%07d\n&quot;, *it);
		}
	}
}
int main() {
	int n,m,id;
	cin &gt;&gt; n;
	string title, autor, keyword, publish, year;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		char c = getchar();
		getline(cin, title);
		mptitle[title].insert(id);
		getline(cin, autor);
		mpautor[autor].insert(id);
		while (cin &gt;&gt; keyword) {
			mpkey[keyword].insert(id);
			 c = getchar();
			if (c == '\n') break;
		}
		getline(cin, publish);
		mppublish[publish].insert(id);
		getline(cin, year);
		mpyear[year].insert(id);
	}
	cin &gt;&gt; m;
	while(m--){
		int type;
		string temp;
		scanf(&quot;%d: &quot;, &amp;type);
		getline(cin, temp);
		cout &lt;&lt; type &lt;&lt; &quot;:&quot; &lt;&lt; &quot; &quot; &lt;&lt; temp&lt;&lt;endl;
		if (type == 1) query(mptitle, temp);
		if (type == 2) query(mpautor, temp);
		if (type == 3) query(mpkey, temp);
		if (type == 4) query(mppublish, temp);
		if (type == 5) query(mpyear, temp);
	}
	return 0;
}
</code></pre>
<h3 id="a102320-大整数乘2">A1023(20 大整数乘2)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
bool judge(bign a, bign b) {
	if (a.len != b.len) return false;
	else {
		int count[10] = { 0 };
		for (int i = 0; i &lt; a.len; i++) {
			count[a.d[i]]++;
			count[b.d[i]]--;
		}
		for (int i = 0; i &lt; 10; i++) {
			if (count[i] != 0) {
				return false;
			}
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
}
int main() {
	string str;
	cin &gt;&gt; str;
	bign a, ans;
	a=change(str);
	ans = multi(a, 2);
	if (judge(a, ans)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	print(ans);
	return 0;
}


方法二:
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt; 
using namespace std;
string Double(string s){
	string ans=s;
	int carry=0;
	for(int i=s.size()-1;i&gt;=0;i--){
		ans[i]=(((s[i]-'0')*2+carry)%10)+'0';
		carry=((s[i]-'0')*2+carry)/10;
	}
	if(carry&gt;0) ans=&quot;1&quot;+ans;
	return ans;
}
int main(){
	string s,res;
	map&lt;char,int&gt;mp;
	cin&gt;&gt;s;
	for(int i=0;i&lt;s.size();i++) mp[s[i]]++;
	res=Double(s);
	for(int i=0;i&lt;res.size();i++) mp[res[i]]--;
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second!=0){
			cout&lt;&lt;&quot;No\n&quot;&lt;&lt;res;
			return 0;
		}
	}
	cout&lt;&lt;&quot;Yes\n&quot;&lt;&lt;res;
	return 0;
}
</code></pre>
<h3 id="a102425-大整数反转相加判断回文数">A1024(25 大整数反转相加，判断回文数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
string rev(string s) {
	reverse(s.begin(),s.end());
	return s;
}
string add(string s1,string s2) {
	string ans=s1;
	int carry=0;
	for(int i=ans.size()-1; i&gt;=0; i--) {
		ans[i]=((s1[i]-'0')+(s2[i]-'0')+carry)%10+'0';
		carry=((s1[i]-'0')+(s2[i]-'0')+carry)/10;
	}
	if(carry!=0) ans=&quot;1&quot;+ans;
	return ans;
}
bool judge(string s) {
	for(int i=0; i&lt;s.size()/2; i++) {
		if(s[i]!=s[s.size()-i-1]) return false;
	}
	return true;
}
int main() {
	string s;
	int step;
	cin&gt;&gt;s&gt;&gt;step;
	if(s.size()==1||judge(s)) cout&lt;&lt;s&lt;&lt;endl&lt;&lt;&quot;0&quot;;
	else {
		for(int i=1; i&lt;=step; i++) {
			s=add(s,rev(s));
			if(judge(s)||i==step) {
				cout&lt;&lt;s&lt;&lt;endl&lt;&lt;i;
				break;
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a102525-条件排序">A1025(25 条件排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string id;
	int localid,score,frank,lrank;
};
bool cmp(node a,node b){
	return a.score!=b.score? a.score&gt;b.score : a.id&lt;b.id;
}
int main(){
	int n,k;
	cin&gt;&gt;n;
	vector&lt;node&gt; total;
	for(int j=1;j&lt;=n;j++){
		scanf(&quot;%d&quot;,&amp;k);
		vector&lt;node&gt; v(k);
		for(int i=0;i&lt;k;i++) {
			cin&gt;&gt;v[i].id&gt;&gt;v[i].score;
			v[i].localid=j;
		}
		sort(v.begin(),v.end(),cmp);
		v[0].lrank=1;
		for(int i=1;i&lt;k;i++) {
			if(v[i].score==v[i-1].score) v[i].lrank=v[i-1].lrank;
			else v[i].lrank=i+1;
		}
		for(int i=0;i&lt;k;i++) total.push_back(v[i]);
	}
	sort(total.begin(),total.end(),cmp);
	total[0].frank=1;
	for(int i=1;i&lt;total.size();i++) {
		if(total[i].score==total[i-1].score) total[i].frank=total[i-1].frank;
		else total[i].frank=i+1;
	}
	cout&lt;&lt;total.size()&lt;&lt;endl;
	for(int i=0;i&lt;total.size();i++){
		printf(&quot;%s %d %d %d\n&quot;,total[i].id.c_str(),total[i].frank,total[i].localid,total[i].lrank);
	}
	return 0;
}
</code></pre>
<h3 id="a1027">A1027</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	char c[14]={&quot;0123456789ABC&quot;};
	printf(&quot;#&quot;);
	for(int i=0;i&lt;3;i++){
		int n;
		scanf(&quot;%d&quot;,&amp;n);
		printf(&quot;%c%c&quot;,c[n/13],c[n%13]);
	}
	return 0;
}
</code></pre>
<h3 id="a102825-排序">A1028(25  排序)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	int id,grade;
	string name;
};
bool cmp1(node a,node b){
	return a.id&lt;b.id;
}
bool cmp2(node a,node b){
	return a.name!=b.name? a.name&lt;b.name :a.id&lt;b.id;
}
bool cmp3(node a,node b){
	return a.grade!=b.grade? a.grade&lt;b.grade : a.id&lt;b.id;
}
int main(){
	int n,c;
	cin&gt;&gt;n&gt;&gt;c;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i].id&gt;&gt;v[i].name&gt;&gt;v[i].grade;
	if(c==1) sort(v.begin(),v.end(),cmp1);
	else if(c==2) sort(v.begin(),v.end(),cmp2);
	else if(c==3)sort(v.begin(),v.end(),cmp3);
	for(int i=0;i&lt;n;i++) printf(&quot;%06d %s %d\n&quot;,v[i].id,v[i].name.c_str(),v[i].grade);
	return 0;
}
</code></pre>
<h3 id="a102925-求中位数-twopoints">A1029(25 求中位数 twopoints)</h3>
<pre><code>1.直接暴力
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
int main(){
    int n1,n2;
    long long a[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    int i;
    for( i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for( i=n1;i&lt;n2+n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    sort(a,a+n1+n2);
    printf(&quot;%d&quot;,a[(n1+n2-1)/2]);
    return 0;
}

2.two points

#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
const int INF=(1&lt;&lt;31)-1;
int main(){
    int n1,n2;
    long long a[maxn],b[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    for(int i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for(int i=0;i&lt;n2;i++){
        scanf(&quot;%lld&quot;,&amp;b[i]);
    }
    a[n1]=INF;
    b[n2]=INF;
    int midpos=(n1+n2-1)/2;
    int count=0,j=0,i=0;
    while(count&lt;midpos){
        if(a[i]&lt;b[j]) i++;
        else j++;
        count++;
    }
    if(a[i]&lt;b[j]) printf(&quot;%lld&quot;,a[i]);
    else printf(&quot;%lld&quot;,b[j]);
    return 0;
}
</code></pre>
<h3 id="a103030-dijkst距离最短加花费最少">A1030(30 dijkst,距离最短加花费最少)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=510;
const int INF=0x7fffffff;
int G[maxn][maxn],n,m,st,ed,cost[maxn][maxn],d[maxn],c[maxn],pre[maxn];
bool vis[maxn];
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(c,c+maxn,INF);
	fill(vis,vis+maxn,false);
	d[s]=0;
	c[s]=0;
	for(int i=0;i&lt;n;i++) pre[i]=i;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					d[v]=d[u]+G[u][v];
					c[v]=cost[u][v]+c[u];
					pre[v]=u;
				}else if(d[u]+G[u][v]==d[v]){
					if(c[v]&gt;c[u]+cost[u][v]){
						c[v]=cost[u][v]+c[u];
						pre[v]=u;
					}
				}
			}
		}
	} 
}
void dfs(int ed){
	if(ed==st){
        printf(&quot;%d &quot;,ed);
        return;
    } 
	dfs(pre[ed]);
	printf(&quot;%d &quot;,ed);
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;ed);
	fill(G[0],G[0]+maxn*maxn,INF);
	while(m--){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		scanf(&quot;%d%d&quot;,&amp;G[v1][v2],&amp;cost[v1][v2]);
		G[v2][v1]=G[v1][v2];
		cost[v2][v1]=cost[v1][v2];
	}
	dijkst(st);
	dfs(ed);
	printf(&quot;%d %d&quot;,d[ed],c[ed]);
	return 0;
}
</code></pre>
<h3 id="a1031">A1031</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
int main() {
	char str[100], uu[40][40];
    scanf(&quot;%s&quot;,str); 
	int N = strlen(str);
	int n1=(N+2)/3;
	int n3=(N+2)/3;
	int n2=N-n1-n3+2;
	int pos=0;
    memset(uu,' ',sizeof(uu));
	for(int i=0;i&lt;n1-1;i++){
		uu[i][0]=str[pos++];
	} 
	for(int j=0;j&lt;n2;j++){
		uu[n1-1][j]=str[pos++];
	}
	for(int k=n3-2;k&gt;=0;k--){
		uu[k][n2-1]=str[pos++];
	}
	for(int i=0;i&lt;n1;i++){
		for(int j=0;j&lt;n2;j++){
			printf(&quot;%c&quot;,uu[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a103225-链表-找公共后缀">A1032(25 链表  找公共后缀)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	char data;
	bool flag;
	int next;
}list[maxn];
int main(){
	int address,begin1,begin2,n;
	scanf(&quot;%d%d%d&quot;,&amp;begin1,&amp;begin2,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot; %c %d&quot;,&amp;list[address].data,&amp;list[address].next);
	}
	while(begin1!=-1){
		list[begin1].flag=true;
		begin1=list[begin1].next;
	}
	while(begin2!=-1){
		if(list[begin2].flag==true) {
			printf(&quot;%05d&quot;,begin2);
			return 0;
		}
		begin2=list[begin2].next;
	}
	printf(&quot;-1&quot;);
	return 0;
}
</code></pre>
<h3 id="a1033">A1033</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 510;
const int INF = 1000000000;
struct node{
	double price;
	double distance;
}station[maxn];
bool cmp(node a, node b) {
	return a.distance &lt; b.distance;
}
int main() {
	double cmax, d, davg;
	int n;
	scanf(&quot;%lf%lf%lf%d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%lf%lf&quot;, &amp;station[i].price, &amp;station[i].distance);
	}
	station[n].distance = d;
	station[n].price = 0;
	sort(station, station + n + 1, cmp);
	if (station[0].distance != 0) {
		printf(&quot;The maximum travel distance = 0.00&quot;);
		return 0;
	}
	int now = 0;
	double nowtank = 0, expend = 0,  canrun = cmax * davg;
	while (now &lt; n) {
        int k=-1;
        double minprice=INF;
		for (int i = now + 1; (station[i].distance - station[now].distance) &lt;= canrun &amp;&amp; i &lt;= n; i++) {
			if (station[i].price &lt; minprice) {
				minprice = station[i].price;
				k = i;
				if (minprice &lt; station[now].price) {
					break;
				}
			}
		}
		if (k == -1) break;
		double need = (station[k].distance - station[now].distance) / davg;
		if (station[k].price &lt; station[now].price) {
			if (nowtank &lt; need) {
				expend += (need - nowtank) * station[now].price;
				nowtank = 0;
			}
			else {
				nowtank -= need;
			}
		}
		else {
			expend += (cmax - nowtank) * station[now].price;
			nowtank = cmax - need;
		}
		now = k;
	}
	if (now == n) printf(&quot;%.2f&quot;, expend);
	else printf(&quot;The maximum travel distance = %.2f&quot;, station[now].distance + canrun);
	return 0;
}
</code></pre>
<h3 id="a103430-图的深度遍历-map-连通块-边权和点权">A1034(30 图的深度遍历、map、连通块、边权和点权)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string,int&gt; strtoint;
map&lt;int,string&gt; inttostr;
map&lt;string,int&gt; ans;
bool vis[2020];
int G[2020][2020],weight[2020],n,k,index=1;
int Stringtoint(string s){
	if(strtoint.count(s)==0){
		strtoint[s]=index;
		inttostr[index]=s;
		index++;//同时计数总的结点个数 
	}
	return strtoint[s];
}
void dfs(int id,int &amp;totaltime,int&amp;head,int &amp;num){
	vis[id]=true;
	num++;
	if(weight[id]&gt;weight[head]) head=id;
	for(int i=1;i&lt;index;i++){
		if(G[id][i]!=0){
			totaltime+=G[id][i];
			G[id][i]=G[i][id]=0;
			if(vis[i]==false) dfs(i,totaltime,head,num);
		} 
	}
}
int main(){
	string s1,s2;
	cin&gt;&gt;n&gt;&gt;k;
	int id1,id2,calltime;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;calltime;
		id1=Stringtoint(s1),id2=Stringtoint(s2);
		G[id1][id2]+=calltime;
		G[id2][id1]+=calltime;
		weight[id1]+=calltime;
		weight[id2]+=calltime;
	}
	fill(vis,vis+2020,false);
	for(int i=1;i&lt;index;i++){
		if(vis[i]==false){
			int totaltime=0,head=i,num=0;
			dfs(i,totaltime,head,num);
			if(num&gt;2&amp;&amp;totaltime&gt;k) ans[inttostr[head]]=num;
		}
	}
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(auto it=ans.begin();it!=ans.end();it++){
		cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a103520-字符串">A1035(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;string&gt; v;
	for(int j=0;j&lt;n;j++){
		bool flag=false;
		string name,password,ans;
		cin&gt;&gt;name&gt;&gt;password;
		for(int i=0;i&lt;password.length();i++){
			switch(password[i]){
				case '1':password[i]='@';flag=true;break;
				case '0':password[i]='%';flag=true;break;
				case 'l':password[i]='L';flag=true;break;
				case 'O':password[i]='o';flag=true;break;
			}
		}
		if(flag==true) v.push_back(name+&quot; &quot;+password);
	}
	if(n==1) printf(&quot;There is 1 account and no account is modified\n&quot;);
	else if(v.size()==0) printf(&quot;There are %d accounts and no account is modified\n&quot;,n);
	else{
		printf(&quot;%d\n&quot;,v.size());
		for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1036">A1036</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
struct student {
	char name[11];
	char gender;
	char id[11];
	int score;
}male,female,temp;
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	female.score = -1;
	male.score = 101;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %c %s %d&quot;, temp.name, &amp;temp.gender, temp.id, &amp;temp.score);
		if (temp.gender == 'F') {
			if (temp.score &gt; female.score) {
				female = temp;
			}
		}
		if (temp.gender == 'M') {
			if (temp.score &lt; male.score) {
				male = temp;
			}
		}
	}
	if (female.score == -1) printf(&quot;Absent\n&quot;);
	if (female.score &gt; -1) printf(&quot;%s %s\n&quot;, female.name, female.id);
	if (male.score == 101) printf(&quot;Absent\n&quot;);
	if (male.score &lt;101) printf(&quot;%s %s\n&quot;, male.name, male.id);
	if (female.score == -1 || male.score == 101) printf(&quot;NA&quot;);
	if (female.score &gt; -1 &amp;&amp; male.score &lt; 101) printf(&quot;%d&quot;, female.score - male.score);
	return 0;
}
</code></pre>
<h3 id="a103725-贪心">A1037(25 贪心)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b){return a&gt;b;}
int main(){
 	int nc,np,c,p,ans=0;
 	vector&lt;int&gt;c1,c2,p1,p2;
 	scanf(&quot;%d&quot;,&amp;nc);
 	for(int i=0;i&lt;nc;i++){
 		scanf(&quot;%d&quot;,&amp;c);
 		if(c&gt;=0) c1.push_back(c);
 		else c2.push_back(c);
	 }
	 scanf(&quot;%d&quot;,&amp;np);
	 for(int i=0;i&lt;np;i++){
 		scanf(&quot;%d&quot;,&amp;p);
 		if(p&gt;=0) p1.push_back(p);
 		else p2.push_back(p);
	 }
	 sort(c1.begin(),c1.end(),cmp);
	 sort(p1.begin(),p1.end(),cmp);
	 sort(c2.begin(),c2.end());
	 sort(p2.begin(),p2.end());
	 for(int i=0;i&lt;c1.size()&amp;&amp;i&lt;p1.size();i++)	ans+=c1[i]*p1[i];
	 for(int i=0;i&lt;c2.size()&amp;&amp;i&lt;p2.size();i++)	ans+=c2[i]*p2[i];
	 printf(&quot;%d&quot;,ans);
	 return 0;
}
</code></pre>
<h3 id="a103830-贪心-求最小字符串序列">A1038(30 贪心  求最小字符串序列)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
bool cmp(string &amp;a,string &amp;b){
	return a+b&lt;b+a;
}
int main(){
	int n;
	cin&gt;&gt;n;
	string ans;
	vector&lt;string&gt; v(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i];
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++) ans+=v[i];
	while(ans[0]=='0') ans.erase(0,1);
	if(ans.size()==0) cout&lt;&lt;&quot;0&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a103925-vector">A1039(25 vector)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=26*26*26*10+10;
int getid(char *name){
	int id=0;
	for(int i=0;i&lt;3;i++) id=26*id+(name[i]-'A');
	id=id*10+(name[3]-'0');
	return id;
}
int main(){
	int n,k,courseid,num;
	char name[4];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	vector&lt;int&gt; v[maxn];
	for(int i=0;i&lt;k;i++){
		scanf(&quot;%d%d&quot;,&amp;courseid,&amp;num);
		for(int j=0;j&lt;num;j++){
			scanf(&quot;%s&quot;,name);
			v[getid(name)].push_back(courseid);
		}
	}
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s&quot;,name);
		printf(&quot;%s %d&quot;,name,v[getid(name)].size());
		sort(v[getid(name)].begin(),v[getid(name)].end());
		for(int j=0;j&lt;v[getid(name)].size();j++) printf(&quot; %d&quot;,v[getid(name)][j]);
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1040">A1040</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a104120-hash">A1041(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	int n,flag[100001]={0},j;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;v[i]);
		flag[v[i]]++;
	}
	for(j=0;j&lt;n;j++){
		if(flag[v[j]]==1) {
			cout&lt;&lt;v[j];
			break;
		}
	}
	if(j==n) cout&lt;&lt;&quot;None&quot;;
	return 0;
}
</code></pre>
<h3 id="a1042">A1042</h3>
<pre><code>#include&lt;cstdio&gt;
const int N = 55;
int main()
{
	char mp[5] = { 'S','H','C','D','J' };
	int start[N], next[N], end[N];
	int times;
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 1; i &lt;= 54; i++) {
		scanf(&quot;%d&quot;, &amp;next[i]);
	}
	for (int i = 1; i &lt;= 54; i++) {
		start[i] = i;
	}
	for (int step = 0; step &lt; times; step++) {
		for (int i = 1; i &lt;= 54; i++) {
			end[next[i]] = start[i];
		}
		for (int i = 1; i &lt;= 54; i++) {
			start[i] = end[i];
		}
	}
	for (int i = 1; i &lt;= 54; i++) {
		if (i != 1) printf(&quot; &quot;);
		start[i]--;
		printf(&quot;%c%d&quot;, mp[start[i] / 13], start[i] % 13+1);
	}
	return 0;
}
</code></pre>
<h3 id="a104325-二叉搜索树的遍历与反转">A1043(25 二叉搜索树的遍历与反转)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node*left,*right;
};
void insert(node*&amp;root,int data){
	if(root==NULL){
		root=new node;
		root-&gt;data=data;
		root-&gt;left=NULL;
		root-&gt;right=NULL;
		return;
	}
	if(root-&gt;data&lt;=data) insert(root-&gt;right,data);
	else if(root-&gt;data&gt;data) insert(root-&gt;left,data);
}
void preorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorder(root-&gt;left,v);
	preorder(root-&gt;right,v);
}
void preorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	v.push_back(root-&gt;data);
	preorderM(root-&gt;right,v);
	preorderM(root-&gt;left,v);
}
void postorder(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorder(root-&gt;left,v);
	postorder(root-&gt;right,v);
	v.push_back(root-&gt;data);
}
void postorderM(node*root,vector&lt;int&gt;&amp;v){
	if(root==NULL) return;
	postorderM(root-&gt;right,v);
	postorderM(root-&gt;left,v);
	v.push_back(root-&gt;data);
}
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n),pre,preM,post,postM;
	node*root=NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		insert(root,v[i]);
	}
	preorder(root,pre);
	preorderM(root,preM);
	if(pre==v){
		printf(&quot;YES\n&quot;);
		postorder(root,post);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,post[i]);
		}
	}else if(preM==v){
		printf(&quot;YES\n&quot;);
		postorderM(root,postM);
		for(int i=0;i&lt;n;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,postM[i]);
		}
	}else printf(&quot;NO&quot;);
	return 0;
}
</code></pre>
<h3 id="a104425-二分">A1044(25 二分)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; sum,ans;
int n,m;
void func(int i,int &amp;j,int &amp;tempsum){
	int low=i,high=n;
	while(low&lt;high){
		int mid=(low+high)/2;
		if(sum[mid]-sum[i-1]&gt;=m) high=mid;
		else low=mid+1;
	}
	j=high;
	tempsum=sum[j]-sum[i-1];
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	sum.resize(n+1);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
	}
	int minans=sum[n];
	for(int i=1;i&lt;=n;i++){
		int j,tempsum;
		func(i,j,tempsum);
		if(tempsum&gt;minans) continue;
		if(tempsum&gt;=m){
			if(tempsum&lt;minans){
				ans.clear();
				minans=tempsum;
			}
			ans.push_back(i);
			ans.push_back(j);
		}
	}
	for(int i=0;i&lt;ans.size();i+=2)	printf(&quot;%d-%d\n&quot;,ans[i],ans[i+1]);
	return 0;
}
</code></pre>
<h3 id="a1045">A1045</h3>
<pre><code>方法一:最长不下降子序列LIS
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
		ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
方法二:最长公共子序列
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;
    for(int i=0;i&lt;L;i++) dp[0][i]=0;
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
<h3 id="a1046">A1046</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int dis[maxn], A[maxn];
int main() {
	int n,times,left,right,sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		sum += A[i];
        dis[i] = sum;
	}
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 0; i &lt; times; i++) {
		scanf(&quot;%d%d&quot;, &amp;left, &amp;right);
		if (left &gt; right)  swap(left, right);
		int distance = dis[right - 1] - dis[left - 1];
			printf(&quot;%d\n&quot;, min(distance,sum-distance));
	}
	return 0;
}
</code></pre>
<h3 id="a104725-vector">A1047(25 vector)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[40010][5];
vector&lt;int&gt; v[2510];
bool cmp(int a,int b){
	return strcmp(name[a],name[b])&lt;0;
}
int main(){
	int n,k,c,courseid;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%s%d&quot;,name[i],&amp;c);
		while(c--){
			scanf(&quot;%d&quot;,&amp;courseid);
			v[courseid].push_back(i);
		}
	}
	for(int i=1;i&lt;=k;i++){
		printf(&quot;%d %d\n&quot;,i,v[i].size());
		sort(v[i].begin(),v[i].end(),cmp);
		for(int j=0;j&lt;v[i].size();j++) printf(&quot;%s\n&quot;,name[v[i][j]]);
	}
	return 0;
}
</code></pre>
<h3 id="a104825">A1048(25 )</h3>
<pre><code>1.哈希散列解法
#include&lt;cstdio&gt;
int main(){
	int n,pay,flag[100010]={0},a[100010];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;pay);
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for(int i=1;i&lt;pay;i++){
		if(flag[i]&gt;0&amp;&amp;flag[pay-i]&gt;0){
			if((i==pay-i&amp;&amp;flag[i]&gt;1)||i!=pay-i){
				printf(&quot;%d %d&quot;,i,pay-i);
			    return 0;
			}
		}
	} 
	printf(&quot;No Solution&quot;);
	return 0;
}


2.二分法解法
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num, num + n);
	int j,i;
	for ( i = 0; i &lt; n; i++) {
		 j = lower_bound(num + i, num +n, m - num[i]) - num;
		if ( (num[j] + num[i] == m&amp;&amp;j!=i)||(num[i]==num[i+1]&amp;&amp;num[i]*2==m)) {
			printf(&quot;%d %d&quot;, num[i], num[j]);
			break;
		}
	}
	if (i &gt;= n) printf(&quot;No Solution&quot;);
	return 0;
}

3.two points
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int a[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	sort(a, a + n);
	int j=n-1,i=0;
    while(i&lt;j){
        if(a[i]+a[j]==m){
            printf(&quot;%d %d&quot;,a[i],a[j]);
            return 0;
        }
        else if(a[i]+a[j]&gt;m) j--;
        else i++;
    }
	printf(&quot;No Solution&quot;);
	return 0;
}
</code></pre>
<h3 id="a104930-数学问题1的个数">A1049(30  数学问题：&quot;1&quot;的个数)</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int main(){
	int n,left=0,right=0,a=1,now=1,ans=0;
	cin&gt;&gt;n;
	while(n/a){
		left=n/(a*10),right=n%a,now=n/a%10;
		if(now==0) ans+=left*a;
		else if(now==1) ans+=left*a+right+1;
		else ans+=(left+1)*a;
		a*=10; 
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a105020-hash">A1050(20 hash)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	vector&lt;int&gt; v(128,0);
	getline(cin,s1);
	getline(cin,s2);
	for(int i=0;i&lt;s2.length();i++) v[s2[i]]++;
	for(int i=0;i&lt;s1.length();i++){
		if(v[s1[i]]==0) ans+=s1[i];
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a105125-栈">A1051(25 栈)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k);
	while(k--){
		vector&lt;int&gt; v(n+1);
		stack&lt;int&gt; st;
		bool flag=true;
		int current=1;
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
		for(int i=1;i&lt;=n;i++){
			st.push(i);
			if(st.size()&gt;m){
				flag=false;
				break;
			}
			while(!st.empty()&amp;&amp;st.top()==v[current]){
				st.pop();
				current++;
			}
		}
		if(current!=n+1) flag=false;
		if(flag) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a105225-链表按key排序">A1052(25 链表按key排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=100010;
struct node{
	int data,address,next;
}list[maxn]; 
bool cmp(node a,node b){return a.data&lt;b.data;}
int main(){
	int n,begin,address;
	vector&lt;node&gt; v;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;begin);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		v.push_back(list[begin]);
		begin=list[begin].next;
	}
    if(v.size()==0) printf(&quot;0 -1&quot;);
    else{
        sort(v.begin(),v.end(),cmp);
	    printf(&quot;%d %05d\n&quot;,v.size(),v[0].address);
	    for(int i=0;i&lt;v.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,v[i].address,v[i].data,v[i+1].address);
	    printf(&quot;%05d %d -1\n&quot;,v[v.size()-1].address,v[v.size()-1].data);
    }
    return 0;
}
</code></pre>
<h3 id="a105330-输出权值总和同为给定值的路径dfs">A1053(30 输出权值总和同为给定值的路径(dfs))</h3>
<pre><code>1.#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,s,sum=0,path[101];
struct node{
	int w;
	vector&lt;int&gt; child;
}tree[101];
bool cmp(int a,int b){return tree[a].w&gt;tree[b].w;}
void dfs(int index,int nodenum,int sum){
	if(sum&gt;s) return;
	if(sum==s){
		if(tree[index].child.size()!=0) return;
		for(int i=0;i&lt;nodenum;i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,tree[path[i]].w);
		}
		printf(&quot;\n&quot;);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++){
		int child=tree[index].child[i];
		path[nodenum]=child;
		dfs(child,nodenum+1,sum+tree[child].w);
	} 
}
int main(){
	int id,k,c;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;tree[i].w);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;c);
			tree[id].child.push_back(c);
		}
		sort(tree[id].child.begin(),tree[id].child.end(),cmp);
	}
	path[0]=0;
	dfs(0,1,tree[0].w);
	return 0;
}

2.
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=110;
int n,m,s,weight[maxn],notroot[maxn]={0};
vector&lt;int&gt; tree[maxn];
vector&lt;int&gt; t,path;
bool cmp(int a,int b){
	return weight[a]&gt;weight[b];
} 
void dfs(int root,int sum){
	if(tree[root].size()!=0&amp;&amp;sum&gt;s)	return;
	if(tree[root].size()==0&amp;&amp;sum==s){
		t.push_back(root);
		path=t;
		for(int i=0;i&lt;path.size();i++){
			if(i&gt;0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,weight[path[i]]);
		}
		printf(&quot;\n&quot;);
		path.clear();
		t.pop_back();
		return;
	}
	t.push_back(root);
	for(int i=0;i&lt;tree[root].size();i++) dfs(tree[root][i],sum+weight[tree[root][i]]);
	t.pop_back();
}
int main(){
	int root=0;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i];
	for(int i=0;i&lt;m;i++){
		int id,k,temp;
		cin&gt;&gt;id&gt;&gt;k;
		while(k--){
			cin&gt;&gt;temp;
			notroot[temp]=1;
			tree[id].push_back(temp);
		}
		sort(tree[id].begin(),tree[id].end(),cmp);
	} 
	while(notroot[root]!=0&amp;&amp;root&lt;n) root++;
	dfs(root,weight[root]);
	return 0;
}
</code></pre>
<h3 id="a105420-map">A1054(20 map)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int m,n,temp;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	map&lt;int,int&gt; mp;
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;m;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			mp[temp]++;
		}
	}
	int times=-1,ans;
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;times){
			times=it-&gt;second;
			ans=it-&gt;first;
		} 
	} 
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a105525-按条件查找并排序输出">A1055(25 按条件查找并排序输出)</h3>
<pre><code>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
struct node{
	char name[10];
	int age,worth;
};
bool cmp(node a,node b){
	if(a.worth!=b.worth) return a.worth&gt;b.worth;
	else if(a.age!=b.age) return a.age&lt;b.age;
	else return strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,m,k,amin,amax;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; t(n),v;
    vector&lt;int&gt; book(201,0);
	for(int i=0;i&lt;n;i++)  scanf(&quot;%s%d%d&quot;,t[i].name,&amp;t[i].age,&amp;t[i].worth);
    sort(t.begin(),t.end(),cmp);   
    for(int i=0;i&lt;n;i++){
        if(book[t[i].age]&lt;100){
            v.push_back(t[i]);
            book[t[i].age]++;
        }
    }
	for(int i=1;i&lt;=m;i++) {
		printf(&quot;Case #%d:\n&quot;,i);
		vector&lt;node&gt; ans;
        scanf(&quot;%d%d%d&quot;,&amp;k,&amp;amin,&amp;amax);
		for(int j=0;j&lt;v.size();j++) {
			if(v[j].age&gt;=amin&amp;&amp;v[j].age&lt;=amax) ans.push_back(v[j]);
		}
		if(ans.size()==0) printf(&quot;None\n&quot;);
		else if(k&gt;=ans.size()){
			for(int j=0;j&lt;ans.size();j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}else if(k&lt;ans.size())  {
			for(int j=0;j&lt;k;j++) printf(&quot;%s %d %d\n&quot;,ans[j].name,ans[j].age,ans[j].worth);
		}   
	}
	return 0;
} 
</code></pre>
<h3 id="a105625-queue队列">A1056(25 queue队列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int w,rank;
};
int main(){
	int np,ng,orderid;
	queue&lt;int&gt; q;
	scanf(&quot;%d%d&quot;,&amp;np,&amp;ng);
	vector&lt;node&gt; v(np);
	for(int i=0;i&lt;np;i++) scanf(&quot;%d&quot;,&amp;v[i].w);
	for(int i=0;i&lt;np;i++) {
		scanf(&quot;%d&quot;,&amp;orderid);
		q.push(orderid);
	}
	int temp=np,group;
	while(q.size()!=1){
		if(temp%ng==0) group=temp/ng;
		else group=temp/ng+1;
		for(int i=0;i&lt;group;i++){
			int k=q.front();
			for(int j=1;j&lt;=ng;j++){
				if(i*ng+j&gt;temp) break;
				int front=q.front();
				if(v[front].w&gt;v[k].w) k=front;
				v[front].rank=group+1;
				q.pop();
			}
			q.push(k); 
		}
		temp=group; 
	}
	v[q.front()].rank=1;
	for(int i=0;i&lt;np;i++){
		if(i!=0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,v[i].rank);
	}
	return 0;
} 
</code></pre>
<h3 id="a105730-分块-树状数组">A1057(30 分块、树状数组)</h3>
<pre><code>1.分块
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int table[100010],block[317];
stack&lt;int&gt; st;
void Peekmedian(int x) {
	int sum = 0, block_id = 0;
	while (sum + block[block_id] &lt; x) {
		sum += block[block_id++];
	}
	int num = block_id * 316;
	while (sum + table[num] &lt; x) sum+=table[num++];
	printf(&quot;%d\n&quot;, num);
}
void Push(int x) {
	st.push(x);
	table[x]++;
	block[x / 316]++;
}
void Pop() {
	int top = st.top();
	st.pop();
	table[top]--;
	block[top / 316]--;
	printf(&quot;%d\n&quot;, top);
}
int main() {
	int n, temp;
	char cmd[15];
	scanf(&quot;%d&quot;, &amp;n);
	memset(table, 0, sizeof(table));
	memset(block, 0, sizeof(block));
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, cmd);
		if (strcmp(cmd, &quot;Pop&quot;)==0) {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else Pop();
		}
		else if (strcmp(cmd, &quot;Push&quot;)==0) {
			scanf(&quot;%d&quot;, &amp;temp);
			Push(temp);
		}
		else {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else {
				int k = st.size();
				if (k % 2 == 0) k = k / 2;
				else k = k / 2 + 1;
				Peekmedian(k);
			}
		}
	}
	return 0;
}
2.树状数组

</code></pre>
<h3 id="a105820-水题">A1058(20 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	int a,b,c,d,e,f,ans[3];
	scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);
	ans[2]=(c+f)%29;
	ans[1]=(b+e+(c+f)/29)%17;
	ans[0]=a+d+(b+e+(c+f)/29)/17;
	for(int i=0;i&lt;3;i++){
		if(i!=0) printf(&quot;.&quot;);
		printf(&quot;%d&quot;,ans[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a105925-建立素数表-求素数因数">A1059(25 建立素数表 求素数因数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=105000;
vector&lt;int&gt; prime;
long long n;
bool isprime(int n) {
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2; i&lt;=sqr; i++) {
		if(n%i==0) return false;
	}
	return true;
}
int main() {
	int index=0;
	scanf(&quot;%lld&quot;,&amp;n);
	printf(&quot;%lld=&quot;,n);
	for(int i=2; i&lt;=maxn; i++) {
		if(isprime(i)) prime.push_back(i);
	}
	if(n==1) printf(&quot;1&quot;);
	else {
		int hasprint=0;
		for(int i=0; n&gt;=2; i++) {
			int cnt=0,flag=0;
			while(n%prime[i]==0) {
				n/=prime[i];
				cnt++;
				flag=1;
			}
			if(flag){
				if(hasprint) printf(&quot;*&quot;);
				printf(&quot;%lld&quot;,prime[i]);
				hasprint=1;
			}
			if(cnt&gt;=2) printf(&quot;^%d&quot;,cnt);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a106025-字符串-科学计数法">A1060(25 字符串 科学计数法)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int n;
string deal(string s,int &amp;e){
	int k=0;
	while(s[0]=='0'&amp;&amp;s.length()&gt;0) s.erase(s.begin());//去除前导0 
	if(s[0]=='.'){//若去除后是小数点，说明是小于1的数 
		s.erase(s.begin());
		while(s[0]=='0'&amp;&amp;s.length()&gt;0) {
			s.erase(s.begin());//去除小数点后非零位前的所有0 
			e--;
		}
	}else{
		while(s[k]!='.'&amp;&amp;k&lt;s.length()){//寻找小数点 
			k++;
			e++;
		}
		if(k&lt;s.length()) s.erase(s.begin()+k);//删除小数点 
	}
	if(s.length()==0) e=0;
	int num=0;
	k=0;
	string ans;
	while(num&lt;n){
		if(k&lt;s.length()) ans+=s[k++];
		else ans+='0';
		num++;
	}	
	return ans; 
}		
int main(){
	string s1,s2,s3,s4;
	cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;
	int e1=0,e2=0;
	s3=deal(s1,e1);
	s4=deal(s2,e2);
	if(s3==s4&amp;&amp;e1==e2) cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1;	
	else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot; 0.&quot;&lt;&lt;s3&lt;&lt;&quot;*10^&quot;&lt;&lt;e1&lt;&lt;&quot; 0.&quot;&lt;&lt;s4&lt;&lt;&quot;*10^&quot;&lt;&lt;e2;
	return 0;
}
</code></pre>
<h3 id="a106120-字符串">A1061(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	int i=0,pos=0;
	char ans[2];
	string a,b,c,d;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;(a[i]&gt;='A'&amp;&amp;a[i]&lt;='G')){
			ans[0]=a[i];
			break;
		}
		i++;
	}
	++i;
	while(i&lt;a.length()&amp;&amp;i&lt;b.length()){
		if(a[i]==b[i]&amp;&amp;((a[i]&gt;='A'&amp;&amp;a[i]&lt;='N')||isdigit(a[i]))){
			ans[1]=a[i];
			break;
		}
		i++;
	}
	while(pos&lt;c.length()&amp;&amp;pos&lt;d.length()){
		if(c[pos]==d[pos]&amp;&amp;isalpha(c[pos])) break;
		pos++;
	}
	string weekday[7]={&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;};
	printf(&quot;%s %02d:%02d&quot;,weekday[ans[0]-'A'].c_str(),isdigit(ans[1])?ans[1]-'0':ans[1]-'A'+10,pos);
	return 0;
} 
</code></pre>
<h3 id="a1062">A1062</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
struct node{
	int num;
	int de,cai,rank;
}temp;
bool cmp( node a,node b){
	if(a.rank!=b.rank) return a.rank&lt;b.rank;
	else if((a.de+a.cai)!=(b.de+b.cai)) return (a.de+a.cai)&gt;(b.de+b.cai);
	else if(a.de!=b.de) return a.de&gt;b.de;
	else return a.num&lt;b.num;
}
int main(){
	int n,L,H;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;H);
	vector&lt;node&gt; v;
	for(int i=0;i&lt;n;i++){
		int id,a,b,rank;
		scanf(&quot;%d%d%d&quot;,&amp;id,&amp;a,&amp;b);
		if(a&lt;L||b&lt;L) continue;
		if(a&gt;=H&amp;&amp;b&gt;=H) rank=1;
		else if(a&gt;=H&amp;&amp;b&lt;H) rank=2;
		else if(a&lt;H&amp;&amp;b&lt;H&amp;&amp;a&gt;=b) rank=3;
		else rank=4;
		v.push_back(node{id,a,b,rank});
	}
	sort(v.begin(),v.end(),cmp);
	printf(&quot;%d\n&quot;,v.size());
	for(int i=0;i&lt;v.size();i++) printf(&quot;%08d %d %d\n&quot;,v[i].num,v[i].de,v[i].cai);
	return 0;
} 
</code></pre>
<h3 id="a106325-set">A1063(25 set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int maxn = 51;
set&lt;int&gt; v[maxn];
int main() {
	int n,m,temp,k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[i].insert(temp);
		}
	}
	int a, b;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		int nc=0, nt=v[b-1].size();
		for (auto it = v[a - 1].begin(); it != v[a - 1].end(); it++) {
			if (v[b - 1].find(*it) != v[b - 1].end())  nc++;
			else nt++;
		}
		printf(&quot;%.1f%%\n&quot;, (nc * 100.0) / nt);
	}
}
</code></pre>
<h3 id="a106430-完全二叉树中序遍历建树">A1064(30 完全二叉树(中序遍历建树))</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1001;
int CBT[maxn],a[maxn],n,index=0;
void inorder(int root){
	if(root&gt;n) return;
	inorder(root*2);
	CBT[root]=a[index++];
	inorder(root*2+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(1);
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,CBT[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a1065">A1065</h3>
<pre><code>#include&lt;cstdio&gt;
int main() {
	long long a, b, c;
	int n,times=1;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
		bool flag;
		long long sum = a + b;
		if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0)
			flag = true;
		else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)
			flag = false;
		else if (sum &gt; c)
			flag = true;
		else flag = false;
		if (flag == true)
			printf(&quot;Case #%d:true&quot;, times++);
		if (flag == false)
			printf(&quot;Case #%d:false&quot;, times++);
	}
	return 0;
}
</code></pre>
<h3 id="a106625-建立平衡二叉树">A1066(25 建立平衡二叉树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v,height;
	node*left,*right;
};
node* newnode(int v){
	node* Node=new node;
	Node-&gt;v=v;
	Node-&gt;height=1;
	Node-&gt;left=Node-&gt;right=NULL;
	return Node;
}
int getheight(node*root){
	if(root==NULL) return 0;
	return root-&gt;height; 
}
void updateheight(node *root){
	root-&gt;height=max(getheight(root-&gt;right),getheight(root-&gt;left))+1;
}
int getbalance(node* root){
	return getheight(root-&gt;left)-getheight(root-&gt;right);
}
void L(node*&amp;root){
	node*temp=root-&gt;right;
	root-&gt;right=temp-&gt;left;
	temp-&gt;left=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void R(node*&amp;root){
	node*temp=root-&gt;left;
	root-&gt;left=temp-&gt;right;
	temp-&gt;right=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void insert(node*&amp;root,int v){
	if(root==NULL){
		root=newnode(v);
		return;
	}
	if(v&lt;root-&gt;v){
		insert(root-&gt;left,v);
		updateheight(root);
		if(getbalance(root)==2){
			if(getbalance(root-&gt;left)==1) R(root);
			else if(getbalance(root-&gt;left)==-1){
				L(root-&gt;left);
				R(root);
			}
		}
	}
	else{
		insert(root-&gt;right,v);
		updateheight(root);
		if(getbalance(root)==-2){
			if(getbalance(root-&gt;right)==-1) L(root);
			else if(getbalance(root-&gt;right)==1){
				R(root-&gt;right);
				L(root);
			}
		}
	}
}
int main(){
	int n,temp;
	node* root=NULL;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		insert(root,temp);
	}
	printf(&quot;%d&quot;,root-&gt;v);
	return 0;
}
</code></pre>
<h3 id="a106725-贪心-swap排序求最小交换次数">A1067(25  贪心 swap排序，求最小交换次数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n,t,cnt=0,a[100001];
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;t;
		a[t]=i;
	}
	for(int i=1;i&lt;n;i++){
		while(a[0]!=0){
			swap(a[0],a[a[0]]);
			cnt++;
		}
		if(a[i]!=i){
			swap(a[i],a[0]);
			cnt++;
		}
	} 
	cout&lt;&lt;cnt;
	return 0;
}
</code></pre>
<h3 id="a1068">A1068</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a106920-数字黑洞">A1069(20 数字黑洞)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
string strsort(string s){
	sort(s.begin(),s.end());
	s.insert(0,4-s.size(),'0');
	return s;
}
string rev(string s){
	reverse(s.begin(),s.end());
	return s;
}
int main(){
	string s;
	cin&gt;&gt;s;
	s.insert(0, 4 - s.length(), '0');
	if(rev(s)==s){
		cout&lt;&lt;s&lt;&lt;&quot; - &quot;&lt;&lt;s&lt;&lt;&quot; = &quot;&lt;&lt;&quot;0000&quot;;
		return 0;
	}
	int ans=1;
	while(1){
		s=strsort(s);
		string s1=rev(s);
		ans=stoi(s1)-stoi(s);
		printf(&quot;%s - %s = %04d\n&quot;,s1.c_str(),s.c_str(),ans);
		if(ans==6174) return 0;
		s=to_string(ans);
	}
	return 0;
}
</code></pre>
<h3 id="a107025-贪心">A1070(25 贪心)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	double inventory,price;
};
bool cmp(node &amp;a,node &amp;b){ return a.price&gt;b.price;};
int main(){
	int n,D;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;D);
	double prices,profit=0.0;
	vector&lt;node&gt; v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%lf&quot;,&amp;v[i].inventory);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%lf&quot;,&amp;prices);
		v[i].price=prices/v[i].inventory;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i&lt;n;i++){
		if(v[i].inventory&gt;=D){
			profit+=D*v[i].price;
			break;
		}else{
			profit+=v[i].inventory*v[i].price;
			D-=v[i].inventory;
		}
	}
	printf(&quot;%.2f&quot;,profit);
	return 0;
}
</code></pre>
<h3 id="a107125-map-字符串">A1071(25 map  字符串)</h3>
<pre><code>#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
	map&lt;string,int&gt; mp;
	string s,temp,ans;
	getline(cin,s);
	int maxtimes=-1;
	for(int i=0;i&lt;s.length();i++){
		if(isalnum(s[i])){
			if(isupper(s[i])) s[i]=tolower(s[i]);
			temp+=s[i];
		}
		if(!isalnum(s[i])||i==s.length()-1){
			if(!temp.empty()) mp[temp]++;
			temp.clear();
		}
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second&gt;maxtimes) {
			ans=it-&gt;first;
			maxtimes=it-&gt;second;
		}
	}
	cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;maxtimes;
	return 0;
}
</code></pre>
<h3 id="a107230-多源dijkst求最佳源">A1072(30 多源dijkst求最佳源)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt; 
#include&lt;map&gt;
using namespace std;
const int maxn=1100;
const int INF=0x7fffffff;
int n,m,k,ds,G[maxn][maxn],d[maxn],index_g=n+1;
bool vis[maxn];
map&lt;string,int&gt; mp;
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	fill(vis,vis+maxn,false);
	for(int i=1;i&lt;=n+m;i++){
		int u=-1,MIN=INF;
		for(int j=1;j&lt;=n+m;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=1;v&lt;=n+m;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]) d[v]=d[u]+G[u][v];
			}
		}
	}
}
int getid(string s){
	if(s[0]=='G'){
		s.erase(s.begin());
		if(mp.count(s)==0) mp[s]=stoi(s)+n;
		return mp[s];
	}
	else return stoi(s);
}
int main(){
	int ansid=-1;
	double ansavg=INF,ansmindis=-1;
	string s1,s2;
	fill(G[0],G[0]+maxn*maxn,INF);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;ds);
	while(k--){
		cin&gt;&gt;s1&gt;&gt;s2;
		int v1=getid(s1);
		int v2=getid(s2);
		cin&gt;&gt;G[v1][v2];
		G[v2][v1]=G[v1][v2];
	}
	for(int i=n+1;i&lt;=n+m;i++){
		double mindis=INF,avg=0,sum=0;
		dijkst(i);
		for(int j=1;j&lt;=n;j++){
			if(d[j]&gt;ds){
				mindis=-1;
				break;
			}
			if(d[j]&lt;mindis) mindis=d[j];
			avg+=1.0*d[j]/n;
		}
		if(mindis==-1) continue;
		if(mindis&gt;ansmindis){
			ansid=i;
			ansmindis=mindis;
			ansavg=avg;
		}else if(mindis==ansmindis&amp;&amp;ansavg&gt;avg){
			ansid=i;
			ansavg=avg;
		}
	}
	if(ansid==-1) printf(&quot;No Solution&quot;);
	else{
		printf(&quot;G%d\n&quot;,ansid-n);
	    printf(&quot;%.1f %.1f&quot;,ansmindis,ansavg);
	}
	return 0;
}
</code></pre>
<h3 id="a1073-科学计数法">A1073 科学计数法</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	string s,t;
	int n,i=0;
	cin&gt;&gt;s;
	while(s[i]!='E') i++;
	t=s.substr(1,i-1);
	n=stoi(s.substr(i+1,s.length()-i-1));
	if(s[0]=='-') cout&lt;&lt;&quot;-&quot;;
	if(n&lt;0){
		cout&lt;&lt;&quot;0.&quot;;
		for(int j=0;j&lt;abs(n)-1;j++) cout&lt;&lt;&quot;0&quot;;
		for(int j=0;j&lt;t.size();j++) 
		    if(t[j]!='.') cout&lt;&lt;t[j];
	}else{
		cout&lt;&lt;t[0];
		int cnt,j;
		for(j=2,cnt=0;j&lt;t.length()&amp;&amp;cnt&lt;n;j++,cnt++) cout&lt;&lt;t[j];
		if(j==t.length()) {
			for(int k=0;k&lt;n-cnt;k++) cout&lt;&lt;&quot;0&quot;;
		} else{
			cout&lt;&lt;&quot;.&quot;;
			for(int k=j;k&lt;t.size();k++) cout&lt;&lt;t[k];
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107425-反转链表">A1074(25 反转链表)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	int address,data,next;
	int order;
}list[maxn];
bool cmp(node &amp;a,node &amp;b){
	return a.order&lt;b.order;
}
int main(){
	int begin,n,k,address,cnt=0;
	for(int i=0;i&lt;maxn;i++想·) list[i].order=maxn;
	scanf(&quot;%d%d%d&quot;,&amp;begin,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	int p=begin;
	while(p!=-1){
		list[p].order=cnt++;
		p=list[p].next;
	}
	sort(list,list+maxn,cmp);
	for(int i=0;i&lt;cnt/k;i++){
		for(int j=(i+1)*k-1;j&gt;i*k;j--){
			printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j-1].address);
		}
		printf(&quot;%05d %d &quot;,list[i*k].address,list[i*k].data);
		if(i&lt;cnt/k-1) printf(&quot;%05d\n&quot;,list[(i+2)*k-1].address);
		else{
			if(cnt%k==0) printf(&quot;-1\n&quot;);
			else{
				printf(&quot;%05d\n&quot;,list[(i+1)*k].address);
				for(int j=(i+1)*k;j&lt;cnt-1;j++){
				    printf(&quot;%05d %d %05d\n&quot;,list[j].address,list[j].data,list[j+1].address);
				}
				printf(&quot;%05d %d -1&quot;,list[cnt-1].address,list[cnt-1].data);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a107525-排序">A1075(25 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int rank,id,total=0;
	vector&lt;int&gt; score;
	int passnum=0;
	bool isshown=false;
}; 
bool cmp(node a,node b){
	if(a.total!=b.total) return a.total&gt;b.total;
	else if(a.passnum!=b.passnum) return a.passnum&gt;b.passnum;
	else return a.id&lt;b.id;
}
int main(){
	int n,k,m,id,index,grade;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);
	vector&lt;node&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) v[i].score.resize(k+1,-1);
	vector&lt;int&gt; p(k+1);
	for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;p[i]);
	for(int i=0;i&lt;m;i++){
	    scanf(&quot;%d%d%d&quot;,&amp;id,&amp;index,&amp;grade);
	    v[id].id=id;
	    v[id].score[index]=max(grade, v[id].score[index]);
	    if(grade!=-1) v[id].isshown=true;
	    else if(v[id].score[index]==-1) v[id].score[index]=-2;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=k;j++){
			if(v[i].score[j]!=-1&amp;&amp;v[i].score[j]!=-2) v[i].total+=v[i].score[j];
			if(v[i].score[j]==p[j]) v[i].passnum++;
		}
	}
	sort(v.begin()+1,v.end(),cmp);
	v[1].rank=1;
	for(int i=2;i&lt;=n;i++){
		if(v[i].total==v[i-1].total) v[i].rank=v[i-1].rank;
		else v[i].rank=i;
	}
	for(int i=1;i&lt;=n;i++){
		if(v[i].isshown==true){
			printf(&quot;%d %05d %d&quot;,v[i].rank,v[i].id,v[i].total);
			for(int j=1;j&lt;=k;j++) {
				if(v[i].score[j]==-1) printf(&quot; -&quot;);
				else if(v[i].score[j]==-2) printf(&quot; 0&quot;);
				else printf(&quot; %d&quot;,v[i].score[j]);
			}
			printf(&quot;\n&quot;);
		}
	}
	return 0;
} 
</code></pre>
<h3 id="a107630-图的bfs-记录给定最大层数上的结点和">A1076(30 图的bfs、记录给定最大层数上的结点和)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int n,l,k;
bool inq[1010];
vector&lt;vector&lt;int&gt; &gt; v;
struct node{
	int id,level;
};
int bfs(node a){
	fill(inq,inq+1010,false);
	int cnt=0;
	queue&lt;node&gt; q;
	q.push(a);
	inq[a.id]=true;
	while(!q.empty()){
		node t=q.front();
		q.pop();
		int tid=t.id;
		for(int i=0;i&lt;v[tid].size();i++){
			int nextid=v[tid][i];
			if(inq[nextid]==false&amp;&amp;t.level&lt;l){
				cnt++;
				node nextnode={nextid,t.level+1};
				q.push(nextnode);
				inq[nextid]=true;
			}
		}
	}
	return cnt;
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;l);
	v.resize(n+1);
	int num,temp;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;num);
		while(num--){
			scanf(&quot;%d&quot;,&amp;temp);
			v[temp].push_back(i);
		}
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;temp);
		node tnode={temp,0};
		printf(&quot;%d\n&quot;,bfs(tnode));
	}
	return 0;
}
</code></pre>
<h3 id="a107720-多个字符串找公共后缀">A1077(20  多个字符串找公共后缀)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	scanf(&quot;%d\n&quot;,&amp;n);
	string ans;
	int minlen;
	for(int i=0;i&lt;n;i++){
		string s;
		getline(cin,s);
		reverse(s.begin(),s.end());
		if(i==0){
			ans=s;
			minlen=ans.length();
		}else{
			int len=s.length();
			minlen=min(minlen,len);
			for(int j=0;j&lt;minlen;j++){
				if(s[j]!=ans[j]) {
					ans=s.substr(0,j);
					break;
				}
			}
		}
	}
	reverse(ans.begin(),ans.end());
	if(ans.size()==0) cout&lt;&lt;&quot;nai&quot;;
	else cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a107825-hash-平方探查">A1078(25 hash 平方探查)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(1.0*n);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,temp,cnt=0;
	scanf(&quot;%d%d&quot;,&amp;msize,&amp;n);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize,0);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		int flag=0,ans;
		for(int j=0;j&lt;msize;j++){
			int pos=(temp+j*j)%msize;
			if(v[pos]==0){
				v[pos]=temp;
				flag=1;
				ans=pos;
				break;
			}
		}
		if(cnt!=0) printf(&quot; &quot;);
		cnt++;
		if(flag) printf(&quot;%d&quot;,ans);
		else printf(&quot;-&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a107925-树的dfs">A1079(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n;
double p,r,ans=0.0;
struct node{
	int data;
	vector&lt;int&gt; child;
}tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].child.size()==0){
		ans+=tree[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;tree[index].child.size();i++) dfs(tree[index].child[i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int num,root,ischild[100010]={0},temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;num);
		if(num==0){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].data=temp;
		}else{
			for(int j=0;j&lt;num;j++) {
				scanf(&quot;%d&quot;,&amp;temp);
				ischild[temp]=1;
				tree[i].child.push_back(temp);
			}	
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		}
	}
	dfs(root,0);
	printf(&quot;%.1f&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a108030-排序">A1080(30 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int ge,gi,sum,rank,id;
	vector&lt;int&gt; choice;
};
bool cmp1(node&amp; a,node&amp; b){
	if(a.sum!=b.sum) return a.sum&gt;b.sum;
	else return a.ge&gt;b.ge;
}
bool cmp2(node&amp; a,node&amp; b){
	return a.id&lt;b.id;
}
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	vector&lt;int&gt; sch_need(m);
	vector&lt;node&gt; stu(n);
	for(int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;sch_need[i]);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;stu[i].ge,&amp;stu[i].gi);
		stu[i].sum=stu[i].ge+stu[i].gi;
		stu[i].id=i;
		stu[i].choice.resize(k);
		for(int j=0;j&lt;k;j++) scanf(&quot;%d&quot;,&amp;stu[i].choice[j]);
	}
	sort(stu.begin(),stu.end(),cmp1);
	vector&lt;node&gt; ans[m];
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;k;j++){
			int temp=stu[i].choice[j];
			if(ans[temp].size()&lt;sch_need[temp]||
			(ans[temp][ans[temp].size()-1].sum==stu[i].sum&amp;&amp;ans[temp][ans[temp].size()-1].ge==stu[i].ge)) {
				ans[temp].push_back(stu[i]);
				break;
			}
		}
	}
	for(int i=0;i&lt;m;i++){
		sort(ans[i].begin(),ans[i].end(),cmp2);
		for(int j=0;j&lt;ans[i].size();j++){
			if(j!=0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,ans[i][j].id);
		}
		printf(&quot;\n&quot;);	
	}
	return 0;
}
</code></pre>
<h3 id="a108120-分数相加">A1081(20 分数相加)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
long long gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	long long a2 = 0, b2 = 1,gcdvalue;
	for (int i = 0; i &lt; n; i++) {
		long long a, b;
		scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);
		gcdvalue = gcd(a, b);
		a /= gcdvalue;
		b /= gcdvalue;
		a2 = a * b2 + b * a2;
		b2 = b * b2;
		gcdvalue = gcd(a2, b2);
		a2 /= gcdvalue;
		b2 /= gcdvalue;
	}
	long long integer = a2 / b2;
	a2 = a2 - integer * b2;
	if (integer != 0) {
		printf(&quot;%lld&quot;, integer);
		if (a2 &gt; 0) printf(&quot; %lld/%lld&quot;,a2,b2);
		else if (a2 &lt; 0) printf(&quot; %lld/%lld&quot;, -a2, b2);
	}
	if (integer == 0 &amp;&amp; a2 != 0) printf(&quot;%lld/%lld&quot;, a2, b2);
	if (integer == 0 &amp;&amp; a2 == 0) printf(&quot;0&quot;);
	return 0;
}
方法二:
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	long long up,down;
};
long long gcd(long long a,long long b){
	return b==0? abs(a) : gcd(b,a%b);
}
node reduction(node res){
	if(res.down&lt;0){
		res.up=-res.up;
		res.down=-res.down;
	}
	if(res.up==0) res.down=1;
	else{
		long long d=gcd(abs(res.up),abs(res.down));
		res.up/=d;
		res.down/=d;
	}
	return res;
}
node add(node f1,node f2){
	node res;
	res.up=f1.down*f2.up+f1.up*f2.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
void showres(node res){
	res=reduction(res);
	if(res.down==1) printf(&quot;%lld\n&quot;,res.up);
	else if(abs(res.up)&gt;abs(res.down)){
		printf(&quot;%lld %lld/%lld\n&quot;,res.up/res.down,abs(res.up%res.down),res.down);
	}else printf(&quot;%lld/%lld\n&quot;,res.up,res.down);
}
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	node temp,ans;
	ans.up=0,ans.down=1;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%lld/%lld&quot;,&amp;temp.up,&amp;temp.down);
		ans=add(ans,temp);
	} 
	showres(ans);
	return 0;
}
</code></pre>
<h3 id="a108225-分段处理字符串">A1082(25 分段处理字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string n;
	cin&gt;&gt;n;
	int len=n.length();
	int left=0,right=len-1;
	string num[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};
	string wei[5]={&quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Yi&quot;};
	if(n[0]=='-') {
		cout&lt;&lt;&quot;Fu&quot;;
		left++;
	}
	while(left+4&lt;=right){
		right-=4;
	}
	while(left&lt;len){
		bool flag=false;
		bool hasprint=false;
		while(left&lt;=right){
			if(left&gt;0&amp;&amp;n[left]=='0') flag=true;
			else{
				if(flag==true){
					cout&lt;&lt;&quot; &quot;&lt;&lt;&quot;ling&quot;;
					flag=false;
				}
				if(left&gt;0) cout&lt;&lt;&quot; &quot;;
				cout&lt;&lt;num[n[left]-'0'];
				hasprint=true;
				if(left!=right) cout&lt;&lt;&quot; &quot;&lt;&lt;wei[right-left-1];
			}
			left++;
		}
		if(right!=len-1&amp;&amp;hasprint==true)	cout&lt;&lt;&quot; &quot;&lt;&lt;wei[(len-1-right)/4+2]; 
		right+=4; 
	}
	return 0;
} 
</code></pre>
<h3 id="a108325-排序">A1083(25 排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string name,id;
	int grade;
}stu[1000];
bool cmp(node a,node b){return a.grade&gt;b.grade;}
int main(){
	int n,score,g1,g2;
	string name,id;
	vector&lt;node&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;stu[i].name&gt;&gt;stu[i].id&gt;&gt;stu[i].grade;
	cin&gt;&gt;g1&gt;&gt;g2;
	for(int i=0;i&lt;n;i++) {
		if(stu[i].grade&gt;=g1&amp;&amp;stu[i].grade&lt;=g2){
			ans.push_back(stu[i]);
		}
	}
	if(ans.size()==0) cout&lt;&lt;&quot;NONE&quot;;
	else{
		sort(ans.begin(),ans.end(),cmp);
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%s %s\n&quot;,ans[i].name.c_str(),ans[i].id.c_str());
	} 
	return 0;
}
</code></pre>
<h3 id="a108420-字符串">A1084(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main(){
	string s1,s2,ans;
	cin&gt;&gt;s1&gt;&gt;s2;
	for(int i=0;i&lt;s1.length();i++){
		if(s2.find(s1[i])==string::npos&amp;&amp;ans.find(toupper(s1[i]))==string::npos)
		  ans+=toupper(s1[i]); 
	}
	cout&lt;&lt;ans;
	return 0; 
}
</code></pre>
<h3 id="a108525-二分-twopoints-多解法">A1085(25 二分 twopoints 多解法)</h3>
<pre><code>二分法
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,p,ans=0;
	cin&gt;&gt;n&gt;&gt;p;
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++)  cin&gt;&gt;v[i];
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n;i++){
		int j=upper_bound(v.begin()+i+1,v.begin()+n,(long long)p*v[i])-v.begin();
		ans=max(ans,j-i);
	}
	cout&lt;&lt;ans;
	return 0;
}


two points
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, p,num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num,num + n);
	int count=0,i=0,j=0;
    while(i&lt;n&amp;&amp;j&lt;n){
        while(j&lt;n&amp;&amp;num[j]&lt;=(long long)num[i]*p){
            count=max(count,j-i+1);
            j++;
        }
        i++;
    }
    printf(&quot;%d&quot;,count);
    return 0;
}
</code></pre>
<h3 id="a108625-栈模拟中序和先序建树输出后序">A1086(25 栈模拟中序和先序建树，输出后序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=31;
int n,pre[maxn],in[maxn],num=0;
struct node{
	int data;
	node*left,*right;
};
node*create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;data=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;data) k++;
	int leftnum=k-inl;
	root-&gt;left=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;right=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
void postorder(node*root){
	if(root==NULL) return;
	postorder(root-&gt;left);
	postorder(root-&gt;right);
	printf(&quot;%d&quot;,root-&gt;data);
	num++;
	if(num&lt;n) printf(&quot; &quot;);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char s[5];
	stack&lt;int&gt; st;
	int temp,preindex=0,inindex=0;
	for(int i=0;i&lt;2*n;i++){
		scanf(&quot;%s&quot;,s);
		if(strcmp(s,&quot;Push&quot;)==0){
			scanf(&quot;%d&quot;,&amp;temp);
			st.push(temp);
			pre[preindex++]=temp;
		}else{
			temp=st.top();
			st.pop();
			in[inindex++]=temp;
		}
	}
	node*root=create(0,n-1,0,n-1);
	postorder(root);
	return 0;
}
</code></pre>
<h3 id="a108730-dijkstdfs边权点权-总边权-平均点权">A1087(30 dijkst+dfs,边权点权、总边权、平均点权)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt; 
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=210;
const int INF=0x7fffffff;
int n,k,G[maxn][maxn],d[maxn],happ[maxn],maxhapp=0,num=0;
double maxavg=0;
vector&lt;int&gt; pre[maxn];
bool vis[maxn]={false};
map&lt;string,int&gt; cityint;
map&lt;int,string&gt; citystr;
vector&lt;int&gt; temppath,path;
void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					d[v]=G[u][v]+d[u];
					pre[v].clear();
					pre[v].push_back(u);
				}else if(d[u]+G[u][v]==d[v]) pre[v].push_back(u);
			}
		}
	}
}
void dfs(int s){
	if(s==0){
		num++;
		int temphapp=0;
		temppath.push_back(s);
		for(int i=temppath.size()-2;i&gt;=0;i--) temphapp+=happ[temppath[i]];
		double tempavg=temphapp*1.0/(temppath.size()-1);
		if(temphapp&gt;maxhapp){
			path=temppath;
			maxhapp=temphapp;
			maxavg=tempavg;
		}else if(temphapp==maxhapp&amp;&amp;tempavg&gt;maxavg){
			path=temppath;
			maxavg=tempavg;
		}
		temppath.pop_back();
		return;
	}
	temppath.push_back(s);
	for(int i=0;i&lt;pre[s].size();i++) dfs(pre[s][i]);
	temppath.pop_back();
}
int main(){
	string c1,c2;
	int a,index=0;
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;c1;
	cityint[c1]=index++;
	citystr[cityint[c1]]=c1;
	for(int i=0;i&lt;n-1;i++){
		cin&gt;&gt;c1&gt;&gt;a;
		cityint[c1]=index++;
	    citystr[cityint[c1]]=c1;
		happ[cityint[c1]]=a;
	}
	fill(G[0],G[0]+maxn*maxn,INF);
	while(k--){
		cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;a;
		G[cityint[c1]][cityint[c2]]=a;
		G[cityint[c2]][cityint[c1]]=a;
	}
	dijkst(0);
	dfs(cityint[&quot;ROM&quot;]);
	printf(&quot;%d %d %d %d\n&quot;,num,d[cityint[&quot;ROM&quot;]],maxhapp,(int)maxavg);
	for(int i=path.size()-1;i&gt;=0;i--){
		cout&lt;&lt;citystr[path[i]];
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	return 0;
} 
</code></pre>
<h3 id="a108820-分数的加减乘除">A1088(20  分数的加减乘除)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	long long up, down;
};
long long gcd(long long a,long long b){
	return b==0? abs(a) : gcd(b,a%b);
}
node reduction(node res){
	if(res.down&lt;0){
		res.up=-res.up;
		res.down=-res.down;
	}
	if(res.up==0) res.down=1;
	else{
		long long d=gcd(abs(res.up),abs(res.down));
		res.up/=d;
		res.down/=d;
	}
	return res;
}
node add(node f1,node f2){//分数相加
	node res;
	res.up=f1.down*f2.up+f1.up*f2.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node minu(node f1,node f2){//分数相减
	node res;
	res.up=f1.up*f2.down-f2.up*f1.down;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node multi(node f1,node f2){//分数相乘
	node res;
	res.up=f1.up*f2.up;
	res.down=f1.down*f2.down;
	return reduction(res);
}
node divide(node f1,node f2){//分数相除
	node res;
	res.up=f1.up*f2.down;
	res.down=f1.down*f2.up;
	return reduction(res);
}
void showres(node res){
	res=reduction(res);
	if(res.up&lt;0) printf(&quot;(&quot;);
	if(res.down==1) printf(&quot;%lld&quot;,res.up);
	else if(abs(res.up)&gt;abs(res.down)){
		printf(&quot;%lld %lld/%lld&quot;,res.up/res.down,abs(res.up%res.down),res.down);
	}else printf(&quot;%lld/%lld&quot;,res.up,res.down);
	if(res.up&lt;0) printf(&quot;)&quot;);
}
int main(){
	node a,b,ans;
	scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;a.up,&amp;a.down,&amp;b.up,&amp;b.down);
	showres(a);
	printf(&quot; + &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(add(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; - &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(minu(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; * &quot;);
	showres(b);
	printf(&quot; = &quot;);
	showres(multi(a,b));
	printf(&quot;\n&quot;);
	showres(a);
	printf(&quot; / &quot;);
	showres(b);
	printf(&quot; = &quot;);
	if(b.up==0) printf(&quot;Inf&quot;);
	else showres(divide(a,b));
	printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a1089-25-插入排序和归并排序">A1089  (25 插入排序和归并排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100],b[100],n,j,m;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i];
	for(j=0;j&lt;n-1&amp;&amp;b[j]&lt;=b[j+1];j++);
	for(m=j+1;m&lt;n&amp;&amp;a[m]==b[m];m++);
	if(m==n){
		cout&lt;&lt;&quot;Insertion Sort\n&quot;;
		sort(a,a+j+2);
	}else{
		cout&lt;&lt;&quot;Merge Sort\n&quot;;
		int flag=1,k=1;
		while(flag){
			flag=0;
			for(int i=0;i&lt;n;i++){
				if(a[i]!=b[i]) flag=1;
			}
			k=k*2;
			for(int i=0;i&lt;n/k;i++) sort(a+i*k,a+(i+1)*k);
			sort(a+(n/k)*k,a+n);
		}
	}
	for(int i=0;i&lt;n;i++){
		if(i!=0) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;a[i];
	}
	return 0;
}
</code></pre>
<h3 id="a109025-树的dfs求深度">A1090(25 树的dfs求深度)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int maxdepth=-1,num,n;
double p,r,ans=0;
vector&lt;int&gt; tree[100010];
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(depth&gt;maxdepth){
			maxdepth=depth;
			num=1;
		}
		else if(depth==maxdepth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int father,root;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;father);
		if(father==-1) root=i;
	    else tree[father].push_back(i);
	}
	dfs(root,0);
	ans=p*pow((1+r/100),maxdepth);
	printf(&quot;%.2f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a109130-经典bfs求矩阵中块的个数">A1091(30 经典BFS求矩阵中块的个数)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int x,y,z;
}Node;
int m,n,L,t,ans=0;
bool inq[70][1300][140]={false};
int pix[70][1300][140]={0};
int Z[6]={0,0,0,0,1,-1};
int X[6]={0,0,1,-1,0,0};
int Y[6]={1,-1,0,0,0,0};
bool judge(int z,int y,int x){
	if(x&gt;=n||x&lt;0||y&gt;=m||y&lt;0||z&lt;0||z&gt;=L) return false;
	if(pix[z][y][x]==0||inq[z][y][x]==true) return false;
	return true;
}
int bfs(int z,int y,int x){
	int total=0;
	queue&lt;node&gt; q;
	Node.x=x,Node.y=y,Node.z=z;
	q.push(Node);
	inq[z][y][x]=true;
	while(!q.empty()){
		node Top=q.front();
		q.pop();
		total++;//注意在出队的时候计数 
		for(int i=0;i&lt;6;i++){
			int newz=Top.z+Z[i];
			int newx=Top.x+X[i];
			int newy=Top.y+Y[i];
			if(judge(newz,newy,newx)){
				Node.x=newx,Node.y=newy,Node.z=newz;
				q.push(Node);
				inq[newz][newy][newx]=true;
			}
		}
	}
	if(total&gt;=t) return total;
	else return 0;
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;m,&amp;n,&amp;L,&amp;t);
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				scanf(&quot;%d&quot;,&amp;pix[i][j][k]);
			}
		}
	}
	for(int i=0;i&lt;L;i++){
		for(int j=0;j&lt;m;j++){
			for(int k=0;k&lt;n;k++){
				if(inq[i][j][k]==false&amp;&amp;pix[i][j][k]==1) ans+=bfs(i,j,k);
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1092字符串-hash">A1092(字符串 hash)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	string s1,s2;
	cin&gt;&gt;s1&gt;&gt;s2;
	vector&lt;int&gt; v(128,0);
	bool can=true;
	int miss=0;
	for(int i=0;i&lt;s1.length();i++)  v[s1[i]]++;
	for(int i=0;i&lt;s2.length();i++){
	    v[s2[i]]-=1;
	    if(v[s2[i]]&lt;0) {
	    	can=false;
	    	++miss;
		}
	}
	if(can==false) cout&lt;&lt;&quot;No &quot;&lt;&lt;miss;
	else cout&lt;&lt;&quot;Yes &quot;&lt;&lt;s1.length()-s2.length();
	return 0;
}
</code></pre>
<h3 id="a109325-逻辑题">A1093(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	cin&gt;&gt;s;
	long long ans=0;
	int num1[100010]={0},num2[100010]={0};
	for(int i=1;i&lt;s.length();i++){
		if(s[i-1]=='P') num1[i]=num1[i-1]+1;
		else num1[i]=num1[i-1];
	}
	for(int i=s.length()-2;i&gt;=0;i--){
		if(s[i+1]=='T') num2[i]=num2[i+1]+1;
		else num2[i]=num2[i+1];
	}
	for(int i=1;i&lt;s.length()-1;i++){
		if(s[i]=='A') ans+=num1[i]*num2[i];
	}
	cout&lt;&lt;ans%1000000007;
	return 0;
}
</code></pre>
<h3 id="a109425-树的dfs">A1094(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,level[100]={0},maxdepth=-1,ansnum=-1,anslevel;
vector&lt;int&gt; tree[100];
void dfs(int index,int depth){
	level[depth]++;
	if(tree[index].size()==0){
		if(maxdepth&lt;depth) maxdepth=depth;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	int id,k,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d&quot;,&amp;id,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[id].push_back(temp);
		}
	}
	dfs(1,1);
	for(int i=1;i&lt;=maxdepth;i++){
		if(level[i]&gt;ansnum){
			ansnum=level[i];
			anslevel=i;
		}
	}
	printf(&quot;%d %d&quot;,ansnum,anslevel);
	return 0;
}
</code></pre>
<h3 id="a109530-校园停车-排序-两辆配对-时间查询输出">A1095(30 校园停车 排序  两辆配对  时间查询输出)</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
struct node{
	string id;
	int time,flag=0;
};
bool cmp1(node &amp;a,node &amp;b){
	return a.id!=b.id? a.id&lt;b.id : a.time&lt;b.time;
}
bool cmp2(node &amp;a,node &amp;b){
	return a.time&lt;b.time;
}
int main(){
	int n,m,hh,mm,ss,maxparking=-1,tempindex=0;
	string status;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; record(n),car;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;record[i].id;
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		cin&gt;&gt;status;
		record[i].time=hh*3600+mm*60+ss;
		record[i].flag=(status==&quot;in&quot;)? 1 : -1;
	}
	sort(record.begin(),record.end(),cmp1);
	map&lt;string,int&gt; mp;
	for(int i=1;i&lt;n;i++){
		if(record[i-1].flag==1&amp;&amp;record[i].flag==-1&amp;&amp;record[i-1].id==record[i].id){
			car.push_back(record[i-1]);
			car.push_back(record[i]);
			mp[record[i].id]+=record[i].time-record[i-1].time;
		    if(maxparking&lt;mp[record[i].id]) maxparking=mp[record[i].id];
		}
	}
	sort(car.begin(),car.end(),cmp2);
	vector&lt;int&gt; cnt(n);
	for(int i=0;i&lt;car.size();i++){
		if(i==0) cnt[i]+=car[i].flag;
		else cnt[i]=cnt[i-1]+car[i].flag;
	}
	
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d:%d:%d&quot;,&amp;hh,&amp;mm,&amp;ss);
		int query=hh*3600+mm*60+ss;
		int j;
		for(j=tempindex;j&lt;car.size();j++){
			if(query&lt;car[j].time){
				printf(&quot;%d\n&quot;,cnt[j-1]);
				break;
			}else if(j==car.size()-1) printf(&quot;%d\n&quot;,cnt[j]);
		}
		tempindex=j;
	}
	for(auto it=mp.begin();it!=mp.end();it++){
		if(it-&gt;second==maxparking) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;;
	}
	printf(&quot;%02d:%02d:%02d&quot;,maxparking/3600,maxparking%3600/60,maxparking%60);
	return 0;
}
</code></pre>
<h3 id="a109620-找出连续的因数">A1096(20 找出连续的因数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
long long n,temp=1;
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	int st=0,len=0;
	for(int i=2;i&lt;=sqrt(n*1.0);i++){
		int j,temp=1;
		for(j=i;j&lt;=sqrt(n*1.0);j++){
			temp*=j;
			if(n%temp!=0) break;
		}
		if(j-i&gt;len){
			len=j-i;
			st=i;
		}
	}
	if(st==0) printf(&quot;1\n%d&quot;,n);
	else{
		printf(&quot;%d\n&quot;,len);
	    for(int i=0;i&lt;len;i++){
		   if(i!=0) printf(&quot;*&quot;);
		   printf(&quot;%d&quot;,st+i);
    	}
	}
	return 0;
}
</code></pre>
<h3 id="a109725-链表分离">A1097(25 链表分离)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int address,data,next;
}list[100010];
int main(){
	int begin,n,address;
	scanf(&quot;%d%d&quot;,&amp;begin,&amp;n);
	vector&lt;int&gt; flag(10010,0);
	vector&lt;node&gt; remain,remov;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;list[address].data,&amp;list[address].next);
		list[address].address=address;
	}
	while(begin!=-1){
		if(flag[abs(list[begin].data)]==0) {
			flag[abs(list[begin].data)]=1;
			remain.push_back(list[begin]);
		}else remov.push_back(list[begin]);
		begin=list[begin].next;
	}
	for(int i=0;i&lt;remain.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remain[i].address,remain[i].data,remain[i+1].address);		
	printf(&quot;%05d %d -1\n&quot;,remain[remain.size()-1].address,remain[remain.size()-1].data);
	if(remov.size()!=0){
		for(int i=0;i&lt;remov.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,remov[i].address,remov[i].data,remov[i+1].address);		
     	printf(&quot;%05d %d -1&quot;,remov[remov.size()-1].address,remov[remov.size()-1].data);
	}
	return 0;
}
</code></pre>
<h3 id="a109825-判断插入排序和堆排序">A1098(25 判断插入排序和堆排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
void downadjust(vector&lt;int&gt;&amp;b,int low,int high){
	int i=low,j=i*2;
	while(j&lt;=high){
		if(j+1&lt;=high&amp;&amp;b[j+1]&gt;b[j]) j=j+1;
		if(b[i]&gt;=b[j]) break;
		swap(b[i],b[j]);
		i=j;
		j=i*2;
	}
}
int main(){
	int n,p,q;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt;a(n+1),b(n+1);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for(p=2;b[p-1]&lt;=b[p]&amp;&amp;p&lt;=n;p++);
	int index=p;
	while(index&lt;=n&amp;&amp;a[index]==b[index]) index++;
	if(index==n+1){
		printf(&quot;Insertion Sort\n&quot;);
		sort(b.begin()+1,b.begin()+p+1);	
	}
	else{
		printf(&quot;Heap Sort\n&quot;);
		for(q=n;b[q]&gt;=b[1]&amp;&amp;q&gt;2;q--);
		swap(b[1],b[q]);
		downadjust(b,1,q-1);
	}
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,b[i]);
	}
	return 0;
} 
</code></pre>
<h3 id="a109930-中序遍历建立二叉搜索树">A1099(30 中序遍历建立二叉搜索树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=101;
struct node{
	int v;
	int left,right;
}Node[maxn];
int n,a[maxn],index=0,num=0;
void inorder(int root){
	if(root==-1) return;
	inorder(Node[root].left);
	Node[root].v=a[index++];
	inorder(Node[root].right);
} 
void bfs(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int temp=q.front();
		q.pop();
		if(num&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,Node[temp].v);
		num++;
		if(Node[temp].left!=-1) q.push(Node[temp].left);
		if(Node[temp].right!=-1) q.push(Node[temp].right);
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;Node[i].left,&amp;Node[i].right);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n);
	inorder(0);
	bfs(0);
	return 0;
} 
</code></pre>
<h3 id="a110020-字符串-string-map">A1100(20 字符串 string map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
string unitdigit[13]={&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,
&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string tendigit[13]= {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,
&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
string numtostr[169];
map&lt;string,int&gt; strtonum;
void init(){
	for(int i=0;i&lt;13;i++){
		numtostr[i]=unitdigit[i];
		strtonum[unitdigit[i]]=i;
		numtostr[i*13]=tendigit[i];
		strtonum[tendigit[i]]=i*13;
	}
	for(int i=1;i&lt;13;i++){
		for(int j=1;j&lt;13;j++){
			string str=tendigit[i]+&quot; &quot;+unitdigit[j];
			numtostr[i*13+j]=str;
			strtonum[str]=i*13+j;
		}
	}
}
int main(){
	init();
	int n,temp;
	scanf(&quot;%d\n&quot;,&amp;n);
	string s;
	while(n--){
		getline(cin,s);
		if(s[0]&gt;='0'&amp;&amp;s[0]&lt;='9'){
			temp=stoi(s);
			cout&lt;&lt;numtostr[temp]&lt;&lt;endl;
		}
		else cout&lt;&lt;strtonum[s]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<h3 id="a110125-逻辑题">A1101(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std; 
int main(){
	int n,a[100010],leftmax=-1,rightmin=0x7fffffff;
	int left[100010],right[100010];
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
	left[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i-1]&gt;leftmax) leftmax=a[i-1];
		left[i]=leftmax;
	}
	right[n-1]=a[n-1];
	for(int i=n-2;i&gt;=0;i--){
		if(a[i+1]&lt;rightmin) rightmin=a[i+1];
		right[i]=rightmin;
	}
	for(int i=0;i&lt;n;i++){
		if(a[i]&gt;=left[i]&amp;&amp;a[i]&lt;=right[i]) ans.insert(a[i]);
	}
	cout&lt;&lt;ans.size()&lt;&lt;endl;
	for(auto it=ans.begin();it!=ans.end();it++){
		if(it!=ans.begin()) cout&lt;&lt;&quot; &quot;;
		cout&lt;&lt;*it;
	}
	cout&lt;&lt;endl;
	 return 0;
}
</code></pre>
<h3 id="a110225-二叉树反转">A1102(25 二叉树反转)</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
struct node{
	int left,right;
}tree[11];
int n,ischild[11]={0},root,num1=0,num2=0;
void layerorder(int root){
	queue&lt;int&gt; q;
	q.push(root);
	while(!q.empty()){
		int Top=q.front();
		q.pop();
		printf(&quot;%d&quot;,Top);
		num1++;
		if(num1&lt;n) printf(&quot; &quot;);
		if(tree[Top].left!=-1) q.push(tree[Top].left);
		if(tree[Top].right!=-1) q.push(tree[Top].right); 
	}
}
void inorder(int root){
	if(root==-1) return;
	inorder(tree[root].left);
	printf(&quot;%d&quot;,root);
	num2++;
	if(num2&lt;n) printf(&quot; &quot;);
	inorder(tree[root].right);
}
void invert(int root){
	if(root==-1) return;
	invert(tree[root].left);
	invert(tree[root].right);
	swap(tree[root].left,tree[root].right);
} 
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	char c1,c2;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%*c%c %c&quot;,&amp;c1,&amp;c2);
		if(c1=='-') tree[i].left=-1;
		else {
			ischild[c1-'0']=1;
			tree[i].left=c1-'0';
		}
		if(c2=='-') tree[i].right=-1;
		else {
			ischild[c2-'0']=1;
			tree[i].right=c2-'0';
		}
	}
	for(int i=0;i&lt;n;i++){
		if(ischild[i]==0){
			root=i;
			break;
		} 
	}
	invert(root);
	layerorder(root);
	printf(&quot;\n&quot;);
	inorder(root);
	return 0;
}
</code></pre>
<h3 id="a110330-dfs-分解因式">A1103(30 DFS 分解因式)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
int n,k,p,maxfac=-1;
vector&lt;int&gt; fac,temp,ans; 
void init(){
	int i=0;
	while(pow(i,p)&lt;=n){
		fac.push_back(pow(i,p));
		i++;
	} 
}
void dfs(int index,int nowk,int sum,int facsum){
	if(nowk==k&amp;&amp;sum==n){
		if(facsum&gt;maxfac){
			maxfac=facsum;
			ans=temp;
		}
		return;
	}
	if(nowk&gt;k||sum&gt;n) return;
	if(index&gt;=1){
		temp.push_back(index);
		dfs(index,nowk+1,sum+fac[index],facsum+index);
		temp.pop_back();
		dfs(index-1,nowk,sum,facsum);
	}
}
int main(){
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;p);
	init();
	dfs(fac.size()-1,0,0,0);
	if(maxfac==-1) printf(&quot;Impossible&quot;);
	else{
		printf(&quot;%d = &quot;,n);
		for(int i=0;i&lt;ans.size();i++){
		   if(i&gt;0) printf(&quot; + &quot;);
		   printf(&quot;%d^%d&quot;,ans[i],p);
	   }
	}
	return 0;
}
</code></pre>
<h3 id="a110420-片段和-逻辑题">A1104(20 片段和 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int main(){
	int n;
	long double ans=0,temp;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;temp;
		ans+=temp*(n-i)*(i+1);
	}
	printf(&quot;%.2llf\n&quot;,ans);
	return 0; 
}
</code></pre>
<h3 id="a110525-顺时针螺旋二维数组注意判断下标越界">A1105(25 顺时针螺旋二维数组，注意判断下标越界)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b) {
	return a&gt;b;
}
int main() {
	int N, m,n;
	scanf(&quot;%d&quot;,&amp;N);
	vector&lt;int&gt;t(N);
	for(int i=0; i&lt;N; i++) scanf(&quot;%d&quot;,&amp;t[i]);
	sort(t.begin(),t.end(),cmp);
	m=(int)(ceil(sqrt(N*1.0)));
	while(N%m!=0) m++;
	n=N/m;
	vector&lt;vector&lt;int&gt; &gt;v(m,vector&lt;int&gt;(n));
	int level=m/2+m%2,index=0;
	for(int i=0; i&lt;level; i++) {
		for(int j=i; j&lt;n-i&amp;&amp;index&lt;N; j++)  v[i][j]=t[index++];
		for(int j=i+1; j&lt;m-i&amp;&amp;index&lt;N; j++) v[j][n-i-1]=t[index++];
		for(int j=n-i-2; j&gt;=i&amp;&amp;index&lt;N; j--) v[m-i-1][j]=t[index++];
		for(int j=m-i-2; j&gt;i&amp;&amp;index&lt;N; j--) v[j][i]=t[index++];
	}
	for(int i=0; i&lt;m; i++) {
		if(i!=0) printf(&quot;\n&quot;);
		for(int j=0; j&lt;n; j++) {
			if(j!=0) printf(&quot; &quot;);
			printf(&quot;%d&quot;,v[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a110625-树的dfs">A1106(25 树的dfs)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int n,num=0,mindepth=0x7fffffff;
double p,r,ans=0.0;
vector&lt;int&gt; tree[100010]; 
void dfs(int index,int depth){
	if(tree[index].size()==0){
		if(mindepth&gt;depth){
			mindepth=depth;
			num=1;
		}else if(mindepth==depth) num++;
		return;
	}
	for(int i=0;i&lt;tree[index].size();i++) dfs(tree[index][i],depth+1);
}
int main(){
	scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);
	int k,temp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			tree[i].push_back(temp);
		}
	}
	dfs(0,0);
	ans=p*pow((1+r/100),mindepth);
	printf(&quot;%.4f %d&quot;,ans,num);
	return 0;
}
</code></pre>
<h3 id="a110730-经典并查集">A1107(30 经典并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt; 
using namespace std;
vector&lt;int&gt;father,isroot;
bool cmp(int a,int b){return a&gt;b;}
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
}
void Union(int a,int b){
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA!=faB) father[faA]=faB;
}
int main(){
	int course[1001]={0},n,num,courseid,cnt=0;
	scanf(&quot;%d&quot;,&amp;n);
	father.resize(n+1);
	isroot.resize(n+1,0);
	for(int i=1;i&lt;=n;i++) father[i]=i;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d:&quot;,&amp;num);
		while(num--){
			scanf(&quot;%d&quot;,&amp;courseid);
			if(course[courseid]==0) course[courseid]=i;
			Union(i,findfather(course[courseid])); 
		}
	}
	for(int i=1;i&lt;=n;i++) isroot[findfather(i)]++;
	for(int i=1;i&lt;=n;i++){
		if(isroot[i]!=0) cnt++;
	}
	sort(isroot.begin(),isroot.end(),cmp);
	printf(&quot;%d\n&quot;,cnt);
	for(int i=0;i&lt;cnt;i++){
		if(i&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,isroot[i]);
	}
	return 0;
}
</code></pre>
<h3 id="a110820-字符串-sscanf-sprintf">A1108(20 字符串 sscanf、sprintf)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
int main(){
	int n,num=0;
	double sum=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		char s[50],b[50];
		double temp;
		int flag=0;
		scanf(&quot;%s&quot;,s);
		sscanf(s,&quot;%lf&quot;,&amp;temp);
		sprintf(b,&quot;%.2f&quot;,temp);
		for(int j=0;j&lt;strlen(s);j++){
			if(s[j]!=b[j]) flag=1;
		}
		if(flag||temp&lt;-1000||temp&gt;1000){
			printf(&quot;ERROR: %s is not a legal number\n&quot;,s);
			continue;
		}
		num++;
		sum+=temp;
	}
	if(num==0) printf(&quot;The average of 0 numbers is Undefined&quot;);
	else if(num==1) printf(&quot;The average of 1 number is %.2f&quot;,sum);
	else printf(&quot;The average of %d numbers is %.2f&quot;,num,sum/num);
	return 0;
}
</code></pre>
<h3 id="a110925-排序">A1109(25 排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int height;
	char name[10];
}v[10010];
bool cmp(node a,node b){
	return a.height!=b.height? a.height&gt;b.height : strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,k,index=0,num;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	int m=round(n*1.0/k);
	for(int i=0;i&lt;n;i++) scanf(&quot;%s%d&quot;,v[i].name,&amp;v[i].height);
	sort(v,v+n,cmp);
	for(int i=0;i&lt;k;i++){
		if(i==0) num=n-m*(k-1);
		else num=m;
		vector&lt;node&gt; temp(num);
		temp[num/2]=v[index++];
		for(int j=0;j&lt;num;j++){
			if(num/2-j-1&gt;=0) temp[num/2-j-1]=v[index++];
			if(num/2+j+1&lt;num) temp[num/2+j+1]=v[index++];
		}
		for(int j=0;j&lt;num;j++){
			if(j&gt;0) printf(&quot; &quot;);
			printf(&quot;%s&quot;,temp[j].name);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a111025-判断是否是完全二叉树-dfs">A1110(25 判断是否是完全二叉树 dfs)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node{
	int left,right;
}v[30];
int n,maxn=-1,ans;
void dfs(int root,int index){
	if(index&gt;maxn){
		maxn=index;
		ans=root;
	}
	if(v[root].left!=-1) dfs(v[root].left,index*2);
	if(v[root].right!=-1) dfs(v[root].right,index*2+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	string l,r;
	int ischild[30]={0},root=0;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;l&gt;&gt;r;
		if(l==&quot;-&quot;) v[i].left=-1;
		else {
			v[i].left=stoi(l);
			ischild[v[i].left]=1;
		}
		if(r==&quot;-&quot;) v[i].right=-1;
		else {
			v[i].right=stoi(r);
			ischild[v[i].right]=1;
		}
	}
	while(ischild[root]==1) root++;
	dfs(root,1);
	if(maxn==n) printf(&quot;YES %d&quot;,ans);
    else printf(&quot;NO %d&quot;,root);
	return 0;
} 
</code></pre>
<h3 id="a111130-两次dijkst加dfs最短-最快路径-结点最少路径">A1111(30 两次dijkst加dfs,最短、最快路径、结点最少路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt; 
using namespace std;
const int INF=0x7fffffff;
const int maxn=520;
int n,m,st,ed,e[maxn][maxn],t[maxn][maxn],d[maxn],time[maxn],dispre[maxn],timepre[maxn],fast[maxn],fewnum[maxn];
bool vis[maxn];
vector&lt;int&gt; dispath,timepath;
void dis_dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(fast,fast+maxn,INF);
	for(int i=0;i&lt;n;i++) dispre[i]=i;
	d[s]=0;
	fast[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
        for(int j=0;j&lt;n;j++){
        	if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
        		u=j;
        		MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;e[u][v]!=INF){
				if(d[u]+e[u][v]&lt;d[v]){
					d[v]=d[u]+e[u][v];
					fast[v]=fast[u]+t[u][v];
					dispre[v]=u;
				}else if(d[u]+e[u][v]==d[v]&amp;&amp;fast[v]&gt;fast[u]+t[u][v]){
					fast[v]=fast[u]+t[u][v];
					dispre[v]=u;
				}
			}
		} 
	}
}
void time_dijkst(int s){
	fill(time,time+maxn,INF);
	fill(vis,vis+maxn,false);
	time[s]=0;
	fewnum[s]=1;
	for(int i=0;i&lt;n;i++) timepre[i]=i;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
        for(int j=0;j&lt;n;j++){
        	if(vis[j]==false&amp;&amp;time[j]&lt;MIN){
        		u=j;
        		MIN=time[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;t[u][v]!=INF){
				if(time[v]&gt;time[u]+t[u][v]){
					time[v]=time[u]+t[u][v];
					timepre[v]=u;
					fewnum[v]=fewnum[u]+1;
				}else if(time[v]==time[u]+t[u][v]&amp;&amp;fewnum[v]&gt;fewnum[u]+1){
					timepre[v]=u;
					fewnum[v]=fewnum[u]+1;
				}
			}
		}
	}
}
void dis_dfs(int ed){
	dispath.push_back(ed);
	if(ed==st) return;
	dis_dfs(dispre[ed]);
}
void time_dfs(int ed){
	timepath.push_back(ed);
	if(ed==st) return;
	time_dfs(timepre[ed]);
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int v1,v2,flag,len,ti;
	fill(e[0],e[0]+maxn*maxn,INF);
	fill(t[0],t[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d%d%d%d&quot;,&amp;v1,&amp;v2,&amp;flag,&amp;len,&amp;ti);
		e[v1][v2]=len;
		t[v1][v2]=ti;
		if(flag!=1){
			e[v2][v1]=len;
			t[v2][v1]=ti;
		}
	}
	scanf(&quot;%d%d&quot;,&amp;st,&amp;ed);
	dis_dijkst(st);
	time_dijkst(st);
	dis_dfs(ed);
	time_dfs(ed);
	if(dispath==timepath){
		printf(&quot;Distance = %d; Time = %d: &quot;,d[ed],time[ed]);
		for(int i=dispath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,dispath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
	}else{
		printf(&quot;Distance = %d: &quot;,d[ed]);
		for(int i=dispath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,dispath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
		printf(&quot;\n&quot;);
		printf(&quot;Time = %d: &quot;,time[ed]);
		for(int i=timepath.size()-1;i&gt;=0;i--){
			printf(&quot;%d&quot;,timepath[i]);
			if(i&gt;0) printf(&quot; -&gt; &quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a111220-字符串-找出坏键">A1112(20 字符串、找出“坏键”)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	map&lt;char,bool&gt; mp,hasprint;
	string s,ans;
	int k,cnt=1;
	scanf(&quot;%d\n&quot;,&amp;k);
	cin&gt;&gt;s;
	s=&quot;*&quot;+s+&quot;*&quot;;
	for(int i=1;i&lt;s.length();i++){
		if(s[i]==s[i-1]) cnt++;
		else{
			if(cnt%k!=0) mp[s[i-1]]=true;
			cnt=1;
		}
	}
	for(int i=1;i&lt;s.length()-1;i++){
		ans+=s[i];
		if(mp[s[i]]!=true){
			if(hasprint.count(s[i])!=true){
				cout&lt;&lt;s[i];
		     	hasprint[s[i]]=true;
			}
			i+=k-1;
		}
	}
	cout&lt;&lt;endl&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a111325-水题">A1113(25 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,s=0,s1=0;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt;v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n;i++){
		if(i&lt;n/2) s1+=v[i];
		s+=v[i];
	}
	printf(&quot;%d %d&quot;,n%2==0? 0:1,s-s1*2);
	return 0;
}
</code></pre>
<h3 id="a1114-25-并查集">A1114 (25 并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt; 
using namespace std;
int n,father[10001],family[10001],exist[10001];
struct node{
	int sets,area;
}v[10001];
struct fam{
	int id,num=0;
	double avgset=0, avgarea=0;
}f[10001];
bool cmp(fam a,fam b){
	return a.avgarea!=b.avgarea ? a.avgarea&gt;b.avgarea : a.id&lt;b.id;
}
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
}
void Union(int a,int b){
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA&gt;faB) father[faA]=faB;
	else if(faA&lt;faB) father[faB]=faA;
}
int main(){
	set&lt;int&gt; ans;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;10001;i++) father[i]=i;
	for(int i=0;i&lt;n;i++){
		int id,fa,mo,k,childid;
		scanf(&quot;%d%d%d%d&quot;,&amp;id,&amp;fa,&amp;mo,&amp;k);
		exist[id]=1;
		if(fa!=-1){
			exist[fa]=1;
			Union(id,fa);
		} 
		if(mo!=-1) {
			Union(id,mo);;
			exist[mo]=1;
		}
		while(k--){
		 	scanf(&quot;%d&quot;,&amp;childid);
		 	exist[childid]=1;
		 	Union(id,childid);
		} 
		scanf(&quot;%d%d&quot;,&amp;v[id].sets,&amp;v[id].area);
	}
	for(int i=0;i&lt;10001;i++){
		if(exist[i]==1){
			ans.insert(findfather(i));
			f[findfather(i)].id=findfather(i);
			f[findfather(i)].num++;
			f[findfather(i)].avgset+=v[i].sets;
			f[findfather(i)].avgarea+=v[i].area;
		}
	}
	for(auto it=ans.begin();it!=ans.end();it++){
		f[*it].avgarea=f[*it].avgarea/f[*it].num;
		f[*it].avgset=f[*it].avgset/f[*it].num;
	} 
	sort(f,f+10001,cmp);
	printf(&quot;%d\n&quot;,ans.size());
	for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %d %.3f %.3f\n&quot;,f[i].id,f[i].num,f[i].avgset,f[i].avgarea);
	return 0;
}
</code></pre>
<h3 id="a111530-二叉搜索树建立与dfs">A1115(30 二叉搜索树建立与DFS)</h3>
<pre><code>#include&lt;cstdio&gt;
struct node{
	int v;
	node*left,*right;
};
int maxlevel=-1,level=0,n1=0,n2=0;
void insert(node *&amp;root,int v){
	level++;
	if(root==NULL){
		root=new node;
		root-&gt;v=v;
		root-&gt;left=root-&gt;right=NULL;
		if(maxlevel&lt;level) maxlevel=level;
		level=0;
		return;
	}
	if(v&lt;=root-&gt;v) insert(root-&gt;left,v);
	else insert(root-&gt;right,v);
}
void dfs(node*root,int level){
	if(root==NULL) return;
	if(level==maxlevel) n1++;
	else if(level==maxlevel-1) n2++;
	dfs(root-&gt;left,level+1);
	dfs(root-&gt;right,level+1);
}
int main(){
	int n,a;
	node*root=NULL;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		insert(root,a);
	}
	dfs(root,1);
	printf(&quot;%d + %d = %d&quot;,n1,n2,n1+n2);
	return 0;
}
</code></pre>
<h3 id="a111620-水题">A1116(20 水题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
using namespace std;
bool isprime(int x){
	if(x&lt;=1) return false;
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int n,temp,k;
	scanf(&quot;%d&quot;,&amp;n);
	map&lt;int,int&gt; mp,hascheck;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		mp[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;temp);
		if(mp.count(temp)==0) printf(&quot;%04d: Are you kidding?\n&quot;,temp);
		else{
			if(hascheck.count(temp)==0){
			hascheck[temp]=1;
			if(mp[temp]==1) printf(&quot;%04d: Mystery Award\n&quot;,temp);
	     	else if(isprime(mp[temp])) printf(&quot;%04d: Minion\n&quot;,temp);
	     	else printf(&quot;%04d: Chocolate\n&quot;,temp);
		 }
		else printf(&quot;%04d: Checked\n&quot;,temp);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a111725-逻辑题">A1117(25 逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100010]={0},n,j=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n,greater&lt;int&gt;());
    while(j&lt;n&amp;&amp;a[j]&gt;j+1) j++;
	printf(&quot;%d&quot;,j);
	return 0;
}
</code></pre>
<h3 id="a111825-并查集">A1118(25 并查集)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
int n,father[10006],tree[10006]={0};
int findfather(int x){
	int a=x;
	while(x!=father[x]) x=father[x];
	while(a!=father[a]){
		int z=a;
		a=father[a];
		father[z]=x;
	}
	return x;
} 
void Union(int a,int b){
	int fa=findfather(a);
	int fb=findfather(b);
	if(fa!=fb) father[fa]=fb;
}
int main(){
	int k,q,t,temp,num=0;
	scanf(&quot;%d&quot;,&amp;n);
	set&lt;int&gt; birds;
	for(int i=0;i&lt;10006;i++) father[i]=i;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;k,&amp;t);
		birds.insert(t);
		for(int j=0;j&lt;k-1;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			birds.insert(temp);
			Union(temp,t);
		}
	}
	for(auto it=birds.begin();it!=birds.end();it++)	tree[findfather(*it)]++;
	for(int i=0;i&lt;10006;i++){
		if(tree[i]!=0) num++;
	}
	printf(&quot;%d %d\n&quot;,num,birds.size());
	scanf(&quot;%d&quot;,&amp;q);
	while(q--){
		scanf(&quot;%d%d&quot;,&amp;t,&amp;temp);
		if(findfather(t)==findfather(temp)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
} 
</code></pre>
<h3 id="a1119-30-树的前序和后序-求中序">A1119 (30 树的前序和后序 求中序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,post[31],pre[30],num=0;
bool unique=true;
struct node{
	int v;
	node*left,*right;
};
node* create(int prel,int prer,int postl,int postr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;v=pre[prel];//每次取先序序列的第一个为根节点
	int k=prel+1;
	while(k&lt;=prer&amp;&amp;pre[k]!=post[postr-1]) k++;
	if(prel+1&lt;n&amp;&amp;postr-1&gt;=0&amp;&amp;pre[prel+1]==post[postr-1]) unique=false;
	//如果先序序列的第二个元素等于后序序列的倒数第二个元素，说明树的个数不唯一，因为无法确定该结点属于左子树还是右子树
	int numleft=k-prel-1;
	root-&gt;left=create(prel+1,k-1,postl,postl+numleft-1);
	root-&gt;right=create(k,prer,postl+numleft,postr-1);//如果树的个数不唯一，假设该不确定节点属于右子树
	return root;
}
void inorder(node*root){
	if(root==NULL) return;
	inorder(root-&gt;left);
    if(num&gt;0) printf(&quot; &quot;);
	printf(&quot;%d&quot;,root-&gt;v);
	num++;
	inorder(root-&gt;right);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=NULL;
	root=create(0,n-1,0,n-1);
	if(unique) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	inorder(root);
    printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a112020-水题">A1120(20 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=10010;
int main(){
	int n,sum[maxn]={0};
	string str;
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	bool flag[maxn]={false};
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;str;
		int len=str.size();
		for(int j=0;j&lt;len;j++){
			sum[i]+=(str[j]-'0');
		}
	}
	for(int i=0;i&lt;n;i++) ans.insert(sum[i]);
	printf(&quot;%d\n&quot;,ans.size());
	for(auto it=ans.begin();it!=ans.end();it++) {
		if(it!=ans.begin()) printf(&quot; %d&quot;,*it);
		else printf(&quot;%d&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1121-25-map-set应用">A1121 (25 map、set应用)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
bool flag[100000] = { false };
map&lt;int, int&gt;couple;
int main() {
	int n, m, p1, p2;
	set&lt;int&gt; ans;
	vector&lt;int&gt; guests;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%d%d&quot;, &amp;p1, &amp;p2);
		couple[p1] = p2;
		couple[p2] = p1;
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;p1);
		guests.push_back(p1);
		flag[p1] = true;
	}
	for (int i = 0; i &lt; guests.size(); i++) {
		if (couple.count(guests[i])==0||(flag[couple[guests[i]]]==false)&amp;&amp; couple.count(guests[i]) != 0) ans.insert(guests[i]);
	}
	printf(&quot;%d\n&quot;, ans.size());
	for (auto it = ans.begin(); it != ans.end(); it++) {
		if (it != ans.begin()) printf(&quot; &quot;);
		printf(&quot;%05d&quot;, *it);
	}
	return 0;
}
</code></pre>
<h3 id="a112225-哈密顿回路-set">A1122(25 哈密顿回路  set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,c1,c2,g[210][210];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		g[c1][c2]=1;
		g[c2][c1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int num,flag1=1,flag2=1;
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		set&lt;int&gt; s;
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);	
			s.insert(v[i]);
		}	
		if(num-1!=n||s.size()!=n||v[0]!=v[num-1]) flag1=0;
		for(int i=0;i&lt;num-1;i++){
			if(g[v[i]][v[i+1]]!=1) flag2=0;
		}
		if(flag1==1&amp;&amp;flag2==1) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a112330-avl-层序遍历-判断是否是完全二叉树">A1123(30 AVL 、层序遍历、判断是否是完全二叉树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v,height;
	node* left,*right;
};
node* newnode(int v){
	node* Node=new node;
	Node-&gt;v=v;
	Node-&gt;left=Node-&gt;right=NULL;
	Node-&gt;height=1;
	return Node;
}
int getheight(node *root){
	if(root==NULL) return 0;
	return root-&gt;height;
}
void updateheight(node *root){
	root-&gt;height=max(getheight(root-&gt;left),getheight(root-&gt;right))+1;
}
int getbalance(node *root){
	return getheight(root-&gt;left)-getheight(root-&gt;right);
}
void R(node*&amp;root){
	node*temp=root-&gt;left;
	root-&gt;left=temp-&gt;right;
	temp-&gt;right=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void L(node*&amp;root){
    node*temp=root-&gt;right;
	root-&gt;right=temp-&gt;left;
	temp-&gt;left=root;
	updateheight(root);
	updateheight(temp);
	root=temp;
}
void insert(node*&amp;root,int v){
	if(root==NULL){
		root=newnode(v);
		return;
	}
	if(root-&gt;v&gt;v){
		insert(root-&gt;left,v);
		updateheight(root);
		if(getbalance(root)==2){
			if(getbalance(root-&gt;left)==1){
				R(root);
			}else if(getbalance(root-&gt;left)==-1){
				L(root-&gt;left);
				R(root);
			}
		}
	}else{
		insert(root-&gt;right,v);
		updateheight(root);
		if(getbalance(root)==-2){
			if(getbalance(root-&gt;right)==-1){
				L(root);
			}else if(getbalance(root-&gt;right)==1){
				R(root-&gt;right);
				L(root);
			}
		}
	}
}
int iscomplete=1,after=0,n,num=0;
void layerorder(node*root){
	queue&lt;node*&gt;q;
	q.push(root);
	while(!q.empty()){
		node* t=q.front();
		q.pop();
		if(num&gt;0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,t-&gt;v);
		num++;
		if(t-&gt;left!=NULL){
			if(after) iscomplete=0;
			q.push(t-&gt;left);
		}else after=1;
		if(t-&gt;right!=NULL){
			if(after) iscomplete=0;
			q.push(t-&gt;right);
		}else after=1;
	}
}
int main(){
	int temp;
	scanf(&quot;%d&quot;,&amp;n);
	node*root=NULL;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		insert(root,temp);
	}
	layerorder(root);
	if(iscomplete) printf(&quot;\nYES&quot;);
	else printf(&quot;\nNO&quot;);
	return 0;
}
</code></pre>
<h3 id="a1124-20-逻辑题">A1124  20 逻辑题</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int m,n,s;
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
	vector&lt;string&gt; v(m+1);
	map&lt;string,bool&gt; win;
	for(int i=1;i&lt;=m;i++)	cin&gt;&gt;v[i];
	if(s&gt;m) cout&lt;&lt;&quot;Keep going...&quot;;
	else{
		for(int i=s;i&lt;=m;i++){
			if(win.count(v[i])==0){
				win[v[i]]=true;
				cout&lt;&lt;v[i]&lt;&lt;endl;
				i+=n-1;
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112525-贪心-排序">A1125(25 贪心 排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;v[i]);
	sort(v.begin(),v.end());
	double seg=v[0];
	for(int i=0;i&lt;n-1;i++) seg=(seg+v[i+1])/2;
	printf(&quot;%d&quot;,(int)seg);
	return 0;
}
</code></pre>
<h3 id="a112625-欧拉图-欧拉回路-欧拉路径">A1126(25 欧拉图 欧拉回路 欧拉路径)</h3>
<pre><code>#include&lt;cstdio&gt;
int g[510][510],degree[510]={0},n,m;
bool vis[510]={false};
void dfs(int u){
	vis[u]=true;
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false&amp;&amp;g[u][i]==1){
			dfs(i);
		}
	}
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int v1,v2,evennum=0,block=0;
	while(m--){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
		degree[v1]++;
		degree[v2]++;
	}
	for(int i=1;i&lt;=n;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,degree[i]);
		if(degree[i]%2==0) evennum++;
	}
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			dfs(i);
			block++;
		}	
	}
	if(block==1&amp;&amp;evennum==n) printf(&quot;\nEulerian&quot;);
	else if(block==1&amp;&amp;evennum==n-2) printf(&quot;\nSemi-Eulerian&quot;);
	else printf(&quot;\nNon-Eulerian&quot;);
	return 0;
}
</code></pre>
<h3 id="a112730-中序后序建树dfs输出z字形层序遍历">A1127(30 中序后序建树，dfs，输出z字形层序遍历)</h3>
<pre><code>方法一:层序遍历用结构体统计每层结点
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
int n,post[31],in[31];
vector&lt;int&gt; level[35];
struct node{
	int v,depth;
	node* left,*right;
};
node* create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;v=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root; 
}
void bfs(node*root){
	queue&lt;node&gt; q;
	q.push(node{root-&gt;v,1,root-&gt;left,root-&gt;right});
	while(!q.empty()){
		node t=q.front();
		q.pop();
		level[t.depth].push_back(t.v);
		if(t.left!=NULL) q.push(node{t.left-&gt;v,t.depth+1,t.left-&gt;left,t.left-&gt;right});
		if(t.right!=NULL) q.push(node{t.right-&gt;v,t.depth+1,t.right-&gt;left,t.right-&gt;right});
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=create(0,n-1,0,n-1);
	bfs(root);
	printf(&quot;%d&quot;,root-&gt;v);
	for(int i=2;i&lt;35;i++){
		if(i%2==0){
			for(int j=0;j&lt;level[i].size();j++) printf(&quot; %d&quot;,level[i][j]);
		}else{
			for(int j=level[i].size()-1;j&gt;=0;j--) printf(&quot; %d&quot;,level[i][j]);
		}
	}
	return 0;
}


方法二:层序遍历用当前队列的元素个数统计每层节点
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
int n,post[31],in[31],depth=1;
vector&lt;int&gt; level[31];
struct node{
	int v;
	node* left,*right;
};
node* create(int postl,int postr,int inl,int inr){
	if(postl&gt;postr) return NULL;
	node *root=new node;
	root-&gt;v=post[postr];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(postl,postl+leftnum-1,inl,k-1);
	root-&gt;right=create(postl+leftnum,postr-1,k+1,inr);
	return root; 
}
void bfs(node*root){
	queue&lt;node*&gt; q;
	q.push(root);
	while(!q.empty()){
		int count=q.size();
		while(count--){
			node* t=q.front();
			q.pop();
			level[depth].push_back(t-&gt;v);
			if(t-&gt;left!=NULL) q.push(t-&gt;left);
			if(t-&gt;right!=NULL) q.push(t-&gt;right);
		}
		depth++;
	}
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;post[i]);
	node*root=create(0,n-1,0,n-1);
	bfs(root);
	printf(&quot;%d&quot;,root-&gt;v);
	for(int i=2;i&lt;=depth;i++){
		if(i%2==0){
			for(int j=0;j&lt;level[i].size();j++) printf(&quot; %d&quot;,level[i][j]);
		}else{
			for(int j=level[i].size()-1;j&gt;=0;j--) printf(&quot; %d&quot;,level[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112820-n皇后问题">A1128(20  n皇后问题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int k,n,a[1005];
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int flag=1;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		for(int i=2;i&lt;=n;i++){
			for(int j=1;j&lt;i;j++){
				if(a[j]==a[i]||abs(i-j)==abs(a[j]-a[i])){
					flag=0;
					break;
				}
			}
			if(flag==0){
				printf(&quot;NO\n&quot;);
				break;
			}
		}
		if(flag) printf(&quot;YES\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1129-25-set的应用-结构体内运算符重载">A1129 (25 set的应用 结构体内运算符重载)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int id,fre;
};
bool operator &lt; (const node &amp;a,const node &amp;b){
	return a.fre!=b.fre? a.fre&gt;b.fre : a.id&lt;b.id;
}
int main(){
	int n,k,item,times[50005]={0};
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	set&lt;node&gt; s; 
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;item);
		if(i!=0){
			int j=0;
			printf(&quot;%d:&quot;,item);
			for(auto it=s.begin();j&lt;k&amp;&amp;it!=s.end();it++,j++) printf(&quot; %d&quot;,*it);
			printf(&quot;\n&quot;);
		}
		auto it=s.find(node{item,times[item]});
		times[item]++;
		if(it!=s.end()) s.erase(it);
		s.insert(node{item,times[item]});
	}
	return 0;
}
</code></pre>
<h3 id="a1130中序遍历二叉树-输出中缀表达式">A1130(中序遍历二叉树 输出中缀表达式)</h3>
<pre><code>//中序遍历可以得到中缀表达式
//如果不是叶节点且不是根节点就加括号
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node{
	string v;
	int left,right;
}tree[21];
string ans;
int n,l,r,notroot[21]={0},root=1;
void inorder(int index){
	bool flag=false;
	if((tree[index].left!=-1||tree[index].right!=-1)&amp;&amp;index!=root){
		flag=true;
		ans+=&quot;(&quot;;
	}
	if(tree[index].left!=-1) inorder(tree[index].left);
	ans+=tree[index].v;
	if(tree[index].right!=-1) inorder(tree[index].right);
	if(flag) ans+=&quot;)&quot;;
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;tree[i].v&gt;&gt;tree[i].left&gt;&gt;tree[i].right;
		if(tree[i].left!=-1) notroot[tree[i].left]=1;
		if(tree[i].right!=-1) notroot[tree[i].right]=1;
	}
	while(notroot[root]!=0) root++;
	inorder(root);
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="a113130-dfs-unordered_map邻接矩阵-难题">A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
vector&lt;vector&lt;int&gt; &gt; v(10000);
int visit[10000] = { 0 }, mincnt, mintransfer, st, ed;
unordered_map&lt;int, int&gt; line;
vector&lt;int&gt; path, temppath;
int transfercnt(vector&lt;int&gt; a) {
	int cnt = -1, preline = 0;
	for (int i = 1; i &lt; a.size(); i++) {
		if (line[a[i - 1] * 10000 + a[i]] != preline) cnt++;
		preline = line[a[i - 1] * 10000 + a[i]];
	}
	return cnt;
}
void dfs(int node, int cnt) {
	if (node == ed &amp;&amp; (cnt &lt; mincnt || (cnt == mincnt &amp;&amp; transfercnt(temppath) &lt; mintransfer))) {
		mincnt = cnt;
		mintransfer = transfercnt(temppath);
		path = temppath;
    return;
	}
	for (int i = 0; i &lt; v[node].size(); i++) {
		if (visit[v[node][i]] == 0) {
			visit[v[node][i]] = 1;
			temppath.push_back(v[node][i]);
			dfs(v[node][i], cnt + 1);
			visit[v[node][i]] = 0;
			temppath.pop_back();
		}
	}
}
int main() {
	int n, m, pre, temp, k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d&quot;, &amp;m, &amp;pre);
		for (int j = 1; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[pre].push_back(temp);
			v[temp].push_back(pre);
			line[pre * 10000 + temp]=line[temp*10000+pre] = i;
			pre = temp;
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	while (k--) {
		mintransfer = mincnt = 1000000000;
		scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);
		temppath.clear();
		temppath.push_back(st);
		visit[st] = 1;
		dfs(st, 0);
		visit[st] = 0;
		printf(&quot;%d\n&quot;, mincnt);
		int preline = 0, pretransfer = st;
		for (int i = 1; i &lt; path.size(); i++) {
			if (line[path[i - 1] * 10000 + path[i]] != preline) {
				if (preline != 0) printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, path[i - 1]);
				preline = line[path[i - 1] * 10000 + path[i]];
				pretransfer = path[i - 1];
			}
		}
		printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, ed);
	}
	return 0;
}
</code></pre>
<h3 id="a113220-字符串-水题">A1132(20 字符串 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	string s, s1, s2;
	int n, len;
	cin &gt;&gt; n;
	while (n--) {
		cin &gt;&gt; s;
		len = s.size();
		s1 = s.substr(0, len / 2);
		s2 = s.substr(len / 2, len / 2);
		if (stoi(s1) == 0 || stoi(s2) == 0) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else if (stoi(s) % (stoi(s1) * stoi(s2)) == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1133链表-重新排列">A1133(链表  重新排列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int id, data, next;
};
vector&lt;node&gt; v, ans;
int main() {
	node a[100010];
	int begin, n, k;
	int id, data, next;
	scanf(&quot;%d%d%d&quot;, &amp;begin, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;id, &amp;data, &amp;next);
		a[id] = { id,data,next };
	}
	for (; begin != -1; begin = a[begin].next) v.push_back(a[begin]);
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &lt; 0) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt;= 0 &amp;&amp; v[i].data &lt;= k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt; k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; ans.size() - 1; i++) {
		printf(&quot;%05d %d %05d\n&quot;, ans[i].id, ans[i].data, ans[i + 1].id);
	}
	printf(&quot;%05d %d -1&quot;, ans[ans.size() - 1].id, ans[ans.size() - 1].data);
	return 0;
}
</code></pre>
<h3 id="a113425-hash散列">A1134(25 hash散列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,exist[10001];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v[10001];
	for(int i=0;i&lt;m;i++){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[i].push_back(v1);
		v[i].push_back(v2);
	} 
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int num,hashtable[10001]={0},temp,flag=1;
		scanf(&quot;%d&quot;,&amp;num);
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;temp);
			hashtable[temp]=1;
		}
		for(int i=0;i&lt;m;i++){
			if(hashtable[v[i][0]]!=1&amp;&amp;hashtable[v[i][1]]!=1){
				flag=0;
				break;
			}
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a113530-判断红黑树-递归判断">A1135(30 判断红黑树 递归判断)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v;
	node*left,*right;
};
void create(node*&amp;root,int v){
	if(root==NULL){
		root=new node;
		root-&gt;v=v;
		root-&gt;left=root-&gt;right=NULL;
		return;
	}
	if(abs(v)&lt;=abs(root-&gt;v)) create(root-&gt;left,v);
	else create(root-&gt;right,v);
}
bool judge1(node*root){
	if(root==NULL) return true;
	if(root-&gt;v&lt;0){
		if(root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;v&lt;0) return false;
		if(root-&gt;right!=NULL&amp;&amp;root-&gt;right-&gt;v&lt;0) return false;
	}
	return judge1(root-&gt;left)&amp;&amp;judge1(root-&gt;right);
}
int getnum(node*root){
	if(root==NULL) return 0;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	return root-&gt;v&gt;0? max(l,r)+1 :max(l,r);
}
bool judge2(node*root){
	if(root==NULL) return true;
	int l=getnum(root-&gt;left);
	int r=getnum(root-&gt;right);
	if(l!=r) return false;
	return judge2(root-&gt;left)&amp;&amp;judge2(root-&gt;right);
}
int main(){
	int k,n,temp;
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		node*root=NULL;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;temp);
			create(root,temp);
		}
		if(root-&gt;v&gt;0&amp;&amp;judge1(root)&amp;&amp;judge2(root)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1136-20-回文串-字符串">A1136 (20 回文串 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
string revs(string s){
	reverse(s.begin(),s.end());
	return s;
}
string add(string s1,string s2){
	string s=s1;
	int carry=0;
	for(int i=s1.size()-1;i&gt;=0;i--){
		s[i]=((s1[i]-'0')+(s2[i]-'0')+carry)%10+'0';
		carry=((s1[i]-'0')+(s2[i]-'0')+carry)/10;
	}
	if(carry&gt;0) s='1'+s;
	return s;
}
int main(){
	string s,rev;
	cin&gt;&gt;s;
	if(s==revs(s)) {
		cout&lt;&lt;s&lt;&lt;&quot; is a palindromic number.&quot;;
		return 0;
	}
	for(int i=1;i&lt;=10;i++){
		string sum=add(s,revs(s));
		cout&lt;&lt;s&lt;&lt;&quot; + &quot;&lt;&lt;revs(s)&lt;&lt;&quot; = &quot;&lt;&lt;sum&lt;&lt;endl;
		s=sum;
		if(s==revs(s)){
			cout&lt;&lt;s&lt;&lt;&quot; is a palindromic number.&quot;;
			break;
		}else{
			if(i==10) cout&lt;&lt;&quot;Not found in 10 iterations.&quot;;
		}
	}
	return 0;
}
</code></pre>
<h3 id="a113725-map-排序">A1137(25 map 排序)</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node {
	string name;
	int gp,gm,gf,g;
};
int p,m,n,index1=1;
map&lt;string,int&gt; mp;
vector&lt;node&gt; v,ans;
bool cmp(node a,node b){
	return a.g!=b.g? a.g&gt;b.g : a.name&lt;b.name;
}
int main() {
	scanf(&quot;%d%d%d&quot;,&amp;p,&amp;m,&amp;n);
	string name;
	int sc;
	for(int i=0; i&lt;p; i++) {
		cin&gt;&gt;name&gt;&gt;sc;
		if(sc&gt;=200){
			v.push_back(node {name,sc,-1,-1,0});
			mp[name]=index1++;
		}
	}
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;name&gt;&gt;sc;
		if(mp[name]!=0) v[mp[name]-1].gm=sc;
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;name&gt;&gt;sc;
		if(mp[name]!=0){
			int id=mp[name]-1;
			v[id].gf=sc;
			if(v[id].gf&gt;=v[id].gm) v[id].g=v[id].gf;
			if(v[id].gf&lt;v[id].gm)	v[id].g=round(0.4*v[id].gm+0.6*v[id].gf);
		}
	}
	for(int i=0;i&lt;v.size();i++){
		if(v[i].g&gt;=60) ans.push_back(v[i]);
	}
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i&lt;ans.size();i++){
		printf(&quot;%s %d %d %d %d\n&quot;,ans[i].name.c_str(),ans[i].gp,ans[i].gm,ans[i].gf,ans[i].g);
	}
	return 0;
}
</code></pre>
<h3 id="a113825-树-前序加中序输出后序">A1138(25 树 前序加中序输出后序)</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
vector&lt;int&gt; pre, in;
bool flag = false;
void postOrder(int prel, int inl, int inr) {
	if (inl &gt; inr || flag == true) return;
	int i = inl;
	while (in[i] != pre[prel]) i++;
	postOrder(prel+1, inl, i-1);
	postOrder(prel+i-inl+1, i+1, inr);
	if (flag == false) {
		printf(&quot;%d&quot;, in[i]);
		flag = true;
	}
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	in.resize(n);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;in[i]);
	postOrder(0, 0, n-1);
	return 0;
}
</code></pre>
<h3 id="a113930-逻辑题-unordered_map">A1139(30 逻辑题 unordered_map)</h3>
<pre><code>#include&lt;unordered_map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int a,b;
};
bool cmp(const node &amp;i,const node &amp;j){
	return i.a!=j.a? i.a&lt;j.a : i.b&lt;j.b;
}
unordered_map&lt;int ,bool&gt; isfri;
int main(){
	int n,m,k,c,d;
	cin&gt;&gt;n&gt;&gt;m;
	string a,b;
	vector&lt;int&gt; v[10000];
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;a&gt;&gt;b;
		if(a.length()==b.length()) {
			v[abs(stoi(a))].push_back(abs(stoi(b)));
			v[abs(stoi(b))].push_back(abs(stoi(a)));
		}
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
	}
	cin&gt;&gt;k;
	while(k--){
		vector&lt;node&gt; ans;
		cin&gt;&gt;c&gt;&gt;d;
		for(int i=0;i&lt;v[abs(c)].size();i++){
			for(int j=0;j&lt;v[abs(d)].size();j++){
				if(v[abs(c)][i]==abs(d)||v[abs(d)][j]==abs(c)) continue;
				if(isfri[v[abs(c)][i]*10000+v[abs(d)][j]]==true) ans.push_back(node{v[abs(c)][i],v[abs(d)][j]});
			}
		}
		sort(ans.begin(),ans.end(),cmp);
		cout&lt;&lt;ans.size()&lt;&lt;endl;
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %04d\n&quot;,ans[i].a,ans[i].b);
	}
	return 0;
}
</code></pre>
<h3 id="a114020-字符串">A1140(20 字符串)</h3>
<pre><code>#include&lt;iostream&gt; 
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	int n,j;
	cin&gt;&gt;s&gt;&gt;n;
	for(int x=1;x&lt;n;x++){
       string ans;
       for(int i=0;i&lt;s.length();i=j){
       	for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
       	ans+=s[i]+to_string(j-i);
	   }
	   s=ans;
	}
	cout&lt;&lt;s;
	return 0;
} 
</code></pre>
<h3 id="a114125-stl-排序">A1141(25 stl、排序)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node{
	string name;
	double score=0;
	int num=0,fscore=0,rank;
}t[100010];
int index=0;
unordered_map&lt;string,int&gt; mp;
int change(string &amp;s){
	for(int i=0;i&lt;s.size();i++){
		if(isupper(s[i])) s[i]=tolower(s[i]);
	}
	if(mp.count(s)==0) mp[s]=index++;
	return mp[s]; 
}
bool cmp(node a,node b){
	if(a.fscore!=b.fscore) return a.fscore&gt;b.fscore;
	else if(a.num!=b.num) return a.num&lt;b.num;
	else return a.name&lt;b.name;
}
int main(){
	int n;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		string id,code;
		int score,tid;
		cin&gt;&gt;id&gt;&gt;score&gt;&gt;code;
		tid=change(code);
		t[tid].name=code;
		t[tid].num++;
		if(id[0]=='B') t[tid].score+=score/1.5;
		if(id[0]=='A') t[tid].score+=score*1.0;
		if(id[0]=='T') t[tid].score+=score*1.5;
	}
	for(int i=0;i&lt;index;i++) t[i].fscore=(int)(t[i].score);
	sort(t,t+index,cmp);
	cout&lt;&lt;index&lt;&lt;endl;
	t[0].rank=1;
	printf(&quot;%d %s %d %d\n&quot;,t[0].rank,t[0].name.c_str(),t[0].fscore,t[0].num);
	for(int i=1;i&lt;index;i++){
		if(t[i].fscore==t[i-1].fscore) t[i].rank=t[i-1].rank;
		else t[i].rank=i+1;
		printf(&quot;%d %s %d %d\n&quot;,t[i].rank,t[i].name.c_str(),t[i].fscore,t[i].num);
	}
	return 0;
}
</code></pre>
<h3 id="a114225-无向完全图-最大子图-两点相连">A1142(25 无向完全图 最大子图  两点相连)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int nv,ne,m,k,g[210][210],v1,v2;
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	for(int i=0;i&lt;ne;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;m);
	while(m--){
		int isclique=1,ismax=1,hash[210]={0};
		scanf(&quot;%d&quot;,&amp;k);
		vector&lt;int&gt; v(k);
		for(int i=0;i&lt;k;i++) {
			scanf(&quot;%d&quot;,&amp;v[i]);
			hash[v[i]]=1;
		}
		for(int i=0;i&lt;k-1;i++){
			if(isclique==0) break;
			for(int j=i+1;j&lt;k;j++){
				if(g[v[i]][v[j]]!=1){
					isclique=0;
					printf(&quot;Not a Clique\n&quot;);
				    break;
				}
			}
		}
		if(isclique==0) continue;
		for(int i=1;i&lt;=nv;i++){
			if(ismax==0) break;
			if(hash[i]!=1){
				for(int j=0;j&lt;k;j++){
					if(g[i][v[j]]==1){
						if(j==k-1) ismax=0;
					}else break;
				}
			}
		}
		if(ismax==1) printf(&quot;Yes\n&quot;);
		else printf(&quot;Not Maximal\n&quot;);
	} 
	return 0;
}
</code></pre>
<h3 id="a114330-树-lca-最低公共祖先">A1143(30 树 LCA 最低公共祖先)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;unordered_map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int m,n,u,v,ans;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	unordered_map&lt;int,bool&gt;mp;
	vector&lt;int&gt; pre(n);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;pre[i]);
		mp[pre[i]]=true;
	}
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		for(int j=0;j&lt;n;j++){
			if((pre[j]&gt;=u&amp;&amp;pre[j]&lt;=v)||(pre[j]&lt;=u&amp;&amp;pre[j]&gt;=v)){
				ans=pre[j];
				break;
			}
		}
		if(mp.count(u)==0&amp;&amp;mp.count(v)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,u,v);
		else if(mp.count(u)==0&amp;&amp;mp.count(v)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,u);
		else if(mp.count(v)==0&amp;&amp;mp.count(u)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,v);
		else if(ans==u||ans==v) printf(&quot;%d is an ancestor of %d.\n&quot;,ans,ans==u?v:u);
		else printf(&quot;LCA of %d and %d is %d.\n&quot;,u,v,ans);
	}
	return 0;
}
</code></pre>
<h3 id="a114525-hash-平方探查">A1145(25 hash 平方探查)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x){
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,a;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		int flag=0;
		for(int j=0;j&lt;msize;j++){
			int pos=(a+j*j)%msize;
			if(v[pos]==0){
				flag=1;
				v[pos]=a;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,a);
	}
	int cnt=0,temp;
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//注意这里的&lt;=，因为要回到初始的位置才知道是否能插入
			cnt++;
			if(v[(temp+j*j)%msize]==temp||v[(temp+j*j)%msize]==0) break;
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
    return 0;
}
</code></pre>
<h3 id="a114420-找丢失的最小正数">A1144(20 找丢失的最小正数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	int n,ans=1,temp;
    map&lt;int,int&gt; mp;
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;temp;
		if(temp&gt;0) mp[temp]++;
	}
	while(mp[ans]!=0) ans++;
	cout&lt;&lt;ans;
	return 0;
} 
</code></pre>
<h3 id="a114525-hash-平方探查法插入与查找">A1145(25 hash 平方探查法插入与查找)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,temp,cnt=0;;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize,0);//注意初始化数组元素
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		int flag=0;
		for(int j=0;j&lt;msize;j++){//注意是小于号 
			int pos=(temp+j*j)%msize;
			if(v[pos]==0){
				v[pos]=temp;
				flag=1;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,temp);
	}
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//注意这里是等号,与插入时不同，要回到初始位置才知道查找失败 
			int pos=(temp+j*j)%msize;
			cnt++;
			if(v[pos]==temp||v[pos]==0) break;//找到或没找到
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
}
</code></pre>
<h3 id="a114625-判断是否为拓扑排序序列">A1146(25 判断是否为拓扑排序序列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,in[1001]={0},flag=0,temp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v[1001];
	for(int i=0;i&lt;m;i++){
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[v1].push_back(v2);
		in[v2]++;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int i=0;i&lt;k;i++){
		vector&lt;int&gt; tin(in,in+n+1);
		int judge=1;
		for(int j=0;j&lt;n;j++){
			scanf(&quot;%d&quot;,&amp;temp);
			if(tin[temp]!=0) judge=0;
			for(int x=0;x&lt;v[temp].size();x++) tin[v[temp][x]]--;
		}
		if(judge==1) continue;
		if(flag==1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,i);
		flag=1;	
	}
	return 0;
} 
</code></pre>
<h3 id="a114730-判断大顶堆小顶堆-后序遍历">A1147(30  判断大顶堆小顶堆 后序遍历)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int m, n, num = 0;
vector&lt;int&gt;v;
void dfs(int index) {//后序遍历
	if (index &gt; n) return;
	dfs(index * 2);
	dfs(index * 2 + 1);
	printf(&quot;%d&quot;, v[index]);
	if (num &lt; n - 1)printf(&quot; &quot;);
	num++;
}
int main() {
	scanf_s(&quot;%d%d&quot;, &amp;m, &amp;n);
	while (m--) {
		v.resize(n+1);
		bool flagmin = true, flagmax = true;
		for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
		for (int i = 2; i &lt;= n; i++) {
			if (v[i] &gt;= v[i / 2]) flagmax = false;
			if (v[i] &lt;= v[i / 2]) flagmin = false;
		}
		if (flagmin) printf(&quot;Min Heap\n&quot;);
		else if (flagmax) printf(&quot;Max Heap\n&quot;);
		else if (flagmax == false &amp;&amp; flagmin == false) printf(&quot;Not Heap\n&quot;);
		dfs(1);
		num = 0;
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1148狼人杀-找到两个狼人">A1148(狼人杀 找到两个狼人)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];
	for(int i=1;i&lt;=n;i++){
		for(int j=i+1;j&lt;=n;j++){
			vector&lt;int&gt; lie,a(n+1,1);
			a[i]=a[j]=-1;
			for(int k=1;k&lt;=n;k++){
				if(v[k]*a[abs(v[k])]&lt;0) lie.push_back(k);
			}
			if(lie.size()==2&amp;&amp;a[lie[0]]+a[lie[1]]==0){
				cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;No Solution&quot;;
	return 0;
} 
</code></pre>
<h3 id="a114925-map">A1149(25 map)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,g1,g2,num;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	map&lt;int,vector&lt;int&gt; &gt; mp;
	while(n--){
		scanf(&quot;%d%d&quot;,&amp;g1,&amp;g2);
		mp[g1].push_back(g2);
		mp[g2].push_back(g1);
	}
	while(m--){
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		int exist[100005]={0},flag=1;
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			exist[v[i]]=1;
		}
		for(int i=0;i&lt;num;i++){
			for(int j=0;j&lt;mp[v[i]].size();j++){
				 if(exist[mp[v[i]][j]]==1){
				    printf(&quot;No\n&quot;);
				    flag=0;
				    break;
			    }
			}
			if(flag==0) break;
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115025-判断循环图-输出最小路径">A1150(25 判断循环图 输出最小路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,m,k,dis[210][210]={0},mindis=0x7fffffff,ansid;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	while(m--){
		int c1,c2,d;
		scanf(&quot;%d%d%d&quot;,&amp;c1,&amp;c2,&amp;d);
		dis[c1][c2]=dis[c2][c1]=d;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int x=1;x&lt;=k;x++){
		int num,total=0,flag=1;
		scanf(&quot;%d&quot;,&amp;num);
		set&lt;int&gt; s;
		vector&lt;int&gt; v(num);
		for(int i=0;i&lt;num;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			s.insert(v[i]);
		}
		for(int i=0;i&lt;num-1;i++){
			if(dis[v[i]][v[i+1]]==0){
				flag=0;
				break;
			}
			total+=dis[v[i]][v[i+1]];
		} 
		printf(&quot;Path %d:&quot;,x);
		if(flag==0) printf(&quot; NA &quot;);
		else printf(&quot; %d &quot;,total);
		if(v[0]!=v[num-1]||s.size()!=n||flag==0) printf(&quot;(Not a TS cycle)\n&quot;);
		else if(num-1==n&amp;&amp;s.size()==n&amp;&amp;v[0]==v[num-1]){
			if(total&lt;mindis) {
			    mindis=total;
		     	ansid=x;
		    }
			printf(&quot;(TS simple cycle)\n&quot;);
		} 
		else if(num-1!=n&amp;&amp;s.size()==n&amp;&amp;v[0]==v[num-1]){
			if(total&lt;mindis) {
			    mindis=total;
		     	ansid=x;
		    }
		    printf(&quot;(TS cycle)\n&quot;);
		} 
	}
	printf(&quot;Shortest Dist(%d) = %d&quot;,ansid,mindis);
	return 0;
}
</code></pre>
<h3 id="a115130-树-中序加先序求lca">A1151(30  树 中序加先序求LCA)</h3>
<pre><code>方法一:
#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10010;
map&lt;int,int&gt; pos;
vector&lt;int&gt; ins,pre;
void lca(int inl,int inr,int preroot,int a,int b){
	if(inl&gt;inr) return;
	int inroot=pos[pre[preroot]],ain=pos[a],bin=pos[b];
	if(ain&lt;inroot&amp;&amp;bin&lt;inroot) lca(inl,inroot-1,preroot+1,a,b);
	else if((ain&lt;inroot&amp;&amp;bin&gt;inroot)||(ain&gt;inroot&amp;&amp;bin&lt;inroot)){
		printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,ins[inroot]);
	}
	else if(ain&gt;inroot&amp;&amp;bin&gt;inroot) lca(inroot+1,inr,preroot+1+(inroot-inl),a,b);
	else if(ain==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);
	else if(bin==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);
}
int main(){
	int m,n,a,b;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	ins.resize(n + 1), pre.resize(n + 1);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;ins[i]);
		pos[ins[i]]=i;
	}
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,a);
		if(pos.count(b)==0&amp;&amp;pos.count(a)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);
		if(pos.count(a)!=0&amp;&amp;pos.count(b)!=0) lca(1,n,1,a,b);
	}
	return 0;
}

方法二:建树加dfs
#include&lt;cstdio&gt;
#include&lt;unordered_map&gt;
using namespace std;
const int maxn=10010;
int in[maxn],pre[maxn];
struct node{
	int v;
	node*left,*right;
};
node* create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node*root=new node;
	root-&gt;v=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;left=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;right=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
node* lca(node*root,int a,int b){
	if(root==NULL||root-&gt;v==a||root-&gt;v==b) return root;
	node*l=lca(root-&gt;left,a,b);
	node*r=lca(root-&gt;right,a,b);
	if(l==NULL) return r;
	if(r==NULL) return l;
	return root;
}
int main(){
	int m,n,u,v,res;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	unordered_map&lt;int,bool&gt;mp;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;in[i]);
		mp[in[i]]=true;
	}
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	node*root=create(0,n-1,0,n-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		if(mp.count(u)==0&amp;&amp;mp.count(v)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,u,v);
		else if(mp.count(u)==0&amp;&amp;mp.count(v)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,u);
		else if(mp.count(v)==0&amp;&amp;mp.count(u)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,v);
		else{
			node*ans=lca(root,u,v);
			res=ans-&gt;v;
			if(res==u||res==v) printf(&quot;%d is an ancestor of %d.\n&quot;,res,res==u?v:u);
		    else printf(&quot;LCA of %d and %d is %d.\n&quot;,u,v,res);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a115220-字符串中找第一个k位素数">A1152(20 字符串中找第一个k位素数)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(string s){
	if(stoi(s)&lt;=1) return false;
	int sqr=sqrt(stoi(s));
	for(int i=2;i&lt;=sqr;i++){
		if(stoi(s)%i==0) return false;
	}
	return true;
}
int main(){
	int l,k;
    string s;
	cin&gt;&gt;l&gt;&gt;k&gt;&gt;s;
	for(int i=0;i&lt;s.size();i++){
		if(i+k&lt;=s.size()){
			string t=s.substr(i,k);
			if(isprime(t)){
				cout&lt;&lt;t;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;404&quot;;
	return 0;
}
</code></pre>
<h3 id="a115325-模拟-排序引用传参-unordered_map">A1153(25 模拟 排序引用传参  unordered_map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	string info;
	int score;
};
bool cmp(const node&amp; a, const node&amp; b) {
	return a.score != b.score ? a.score &gt; b.score : a.info &lt; b.info;
}
int main() {
	int n, m, type;
	string t;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; v(n);
	for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].info &gt;&gt; v[i].score;
	for (int i = 1; i &lt;= m; i++) {
		vector&lt;node&gt; ans;
		cin &gt;&gt; type &gt;&gt; t;
		printf(&quot;Case %d: %d %s\n&quot;, i, type, t.c_str());
		int sum = 0, cnt = 0;
		if (type == 1) {
			for (int j = 0; j &lt; n; j++) {
				if (t[0] == v[j].info[0]) ans.push_back(v[j]);
			}
		}
		else if (type == 2) {
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(1, 3) == t) {
					cnt++;
					sum += v[j].score;
				}
			}
			if (cnt != 0) printf(&quot;%d %d\n&quot;, cnt, sum);
		}
		else {
			unordered_map&lt;string, int&gt; m;
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(4, 6) == t) m[v[j].info.substr(1, 3)]++;
			}
			for (auto it : m) ans.push_back({ it.first,it.second });
		}
		sort(ans.begin(), ans.end(), cmp);
		for (int j = 0; j &lt; ans.size(); j++) printf(&quot;%s %d\n&quot;, ans[j].info.c_str(), ans[j].score);
		if (((type == 1 || type == 3) &amp;&amp; ans.size() == 0) || (type == 2 &amp;&amp; cnt == 0)) printf(&quot;NA\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115425-图-边的两端点的判断">A1154(25 图  边的两端点的判断  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
struct node{
	int v1,v2;
};
int main(){
	int n,m,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; v(m);
	vector&lt;int&gt; colo(n);
	for(int i=0;i&lt;m;i++) scanf(&quot;%d%d&quot;,&amp;v[i].v1,&amp;v[i].v2);
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int flag=1;
		set&lt;int&gt; s;
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;colo[i]);
			s.insert(colo[i]);
		}
		for(int i=0;i&lt;m;i++){
			if(colo[v[i].v1]==colo[v[i].v2]){
				flag=0;
				break;
			}
		}
		if(flag==0) printf(&quot;No\n&quot;);
		else printf(&quot;%d-coloring\n&quot;,s.size());
	}
	return 0;
}
</code></pre>
<h3 id="a115530-完全二叉树-判断大顶堆小顶堆-dfs-打印路径">A1155(30 完全二叉树  判断大顶堆小顶堆 dfs  打印路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,t[1005],index;
vector&lt;int&gt; v;
void dfs(int i){
	if(i*2+1&gt;n&amp;&amp;i*2&gt;n){
		if(i&lt;=n){
			for(int i=0;i&lt;v.size();i++){
				if(i&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,v[i]);
			}
			printf(&quot;\n&quot;);
		}
		return;
	}
	v.push_back(t[i*2+1]);
	dfs(i*2+1);
	v.pop_back();
	v.push_back(t[i*2]);
	dfs(i*2);
	v.pop_back();
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	int flagmax=1,flagmin=1;
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]);
	v.push_back(t[1]);
	for(int i=2;i&lt;=n;i++){
		if(t[i]&lt;t[i/2]) flagmin=0;
		if(t[i]&gt;t[i/2]) flagmax=0;
	}
	dfs(1);
	if(flagmin==1) printf(&quot;Min Heap&quot;);
	else if(flagmax==1) printf(&quot;Max Heap&quot;);
	else if(flagmin==0&amp;&amp;flagmax==0) printf(&quot;Not Heap&quot;);
	return 0;
} 
</code></pre>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      lxb&#39;blog
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://liuxbo.github.io/post/pat-ti-jie/" title="PAT题解">PAT题解</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://liuxbo.github.io/tag/a8Kpb5X9y/"># PAT</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="IDEA的使用" href="https://liuxbo.github.io/post/idea-de-shi-yong/">IDEA的使用</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="IDEA的使用" href="https://liuxbo.github.io/post/idea-de-shi-yong/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="c++(PAT)刷题笔记汇总" href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">c++(PAT)刷题笔记汇总</a>
        <a class="nav-mobile-next" title="c++(PAT)刷题笔记汇总" href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="\media\images\custom-bgImg.png" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>