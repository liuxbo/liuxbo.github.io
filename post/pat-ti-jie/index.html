<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="菜鸡成长之路">
<meta name="theme-color" content="#000">
<title>PAT题解 | lxb&#39;blog</title>
<link rel="shortcut icon" href="https://liuxbo.github.io/favicon.ico?v=1588819430243">
<link rel="stylesheet" href="https://liuxbo.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="PAT题解" />
    <meta name="keywords" content="PAT" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>lxb&#39;blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">左手蓝银右手锤</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://liuxbo.github.io/images/avatar.png"/>
    <p class="site-author-name">lxb&#39;blog</p>
    <p class="site-description right-motion">铅华洗尽</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://liuxbo.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#a-1001">A 1001</a></li>
<li><a href="#a1002%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C">A1002(多项式求和)</a></li>
<li><a href="#a1003">A1003</a></li>
<li><a href="#a1004">A1004</a></li>
<li><a href="#a1005">A1005</a></li>
<li><a href="#a1006">A1006</a></li>
<li><a href="#a1007">A1007</a></li>
<li><a href="#a1008">A1008</a></li>
<li><a href="#a1009-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E4%B9%98">A1009 多项式相乘</a></li>
<li><a href="#a1010-%E4%BA%8C%E5%88%86">A1010 二分</a></li>
<li><a href="#a1011">A1011</a></li>
<li><a href="#a1012">A1012</a></li>
<li><a href="#a1013">A1013</a></li>
<li><a href="#a101430-%E6%A8%A1%E6%8B%9F-%E9%9A%BE%E9%A2%98">A1014(30 模拟  难题)</a></li>
<li><a href="#a1015">A1015</a></li>
<li><a href="#a1016">A1016</a></li>
<li><a href="#a1017-25-%E6%A8%A1%E6%8B%9F-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86-%E6%8E%92%E5%BA%8F">A1017 （25 模拟 ，时间处理、排序、）</a></li>
<li><a href="#a1018">A1018</a></li>
<li><a href="#a1019">A1019</a></li>
<li><a href="#a1020">A1020</a></li>
<li><a href="#a1021">A1021</a></li>
<li><a href="#a1022">A1022</a></li>
<li><a href="#a1023">A1023</a></li>
<li><a href="#a1024">A1024</a></li>
<li><a href="#a1025">A1025</a></li>
<li><a href="#a1027">A1027</a></li>
<li><a href="#a1028">A1028</a></li>
<li><a href="#a1029">A1029</a></li>
<li><a href="#a1030">A1030</a></li>
<li><a href="#a1031">A1031</a></li>
<li><a href="#a1032%E9%93%BE%E8%A1%A8">A1032(链表)</a></li>
<li><a href="#a1033">A1033</a></li>
<li><a href="#a1034">A1034</a></li>
<li><a href="#a1035">A1035</a></li>
<li><a href="#a1036">A1036</a></li>
<li><a href="#a1037">A1037</a></li>
<li><a href="#a1038">A1038</a></li>
<li><a href="#a1039">A1039</a></li>
<li><a href="#a1040">A1040</a></li>
<li><a href="#a1041">A1041</a></li>
<li><a href="#a1042">A1042</a></li>
<li><a href="#a1043">A1043</a></li>
<li><a href="#a1044">A1044</a></li>
<li><a href="#a1045">A1045</a></li>
<li><a href="#a1046">A1046</a></li>
<li><a href="#a1047">A1047</a></li>
<li><a href="#a1048">A1048</a></li>
<li><a href="#a1049">A1049</a></li>
<li><a href="#a1050">A1050</a></li>
<li><a href="#a1051-%E6%A0%88">A1051 栈</a></li>
<li><a href="#a1052%E9%93%BE%E8%A1%A8">A1052(链表)</a></li>
<li><a href="#a1053">A1053</a></li>
<li><a href="#a1054">A1054</a></li>
<li><a href="#a1055">A1055</a></li>
<li><a href="#a1056%E9%98%9F%E5%88%97">A1056(队列)</a></li>
<li><a href="#a105730-%E5%88%86%E5%9D%97-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">A1057(30 分块、树状数组)</a></li>
<li><a href="#a1058">A1058</a></li>
<li><a href="#a1059">A1059</a></li>
<li><a href="#a1060">A1060</a></li>
<li><a href="#a1061">A1061</a></li>
<li><a href="#a1062">A1062</a></li>
<li><a href="#a1063">A1063</a></li>
<li><a href="#a1064">A1064</a></li>
<li><a href="#a1065">A1065</a></li>
<li><a href="#a1066">A1066</a></li>
<li><a href="#a1067">A1067</a></li>
<li><a href="#a1068">A1068</a></li>
<li><a href="#a1069">A1069</a></li>
<li><a href="#a1070">A1070</a></li>
<li><a href="#a1071">A1071</a></li>
<li><a href="#a1072">A1072</a></li>
<li><a href="#a1073-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">A1073 科学计数法</a></li>
<li><a href="#a1074%E9%93%BE%E8%A1%A8">A1074(链表)</a></li>
<li><a href="#a1075">A1075</a></li>
<li><a href="#a1076">A1076</a></li>
<li><a href="#a1078">A1078</a></li>
<li><a href="#a1079">A1079</a></li>
<li><a href="#a1080">A1080</a></li>
<li><a href="#a1081">A1081</a></li>
<li><a href="#a1082">A1082</a></li>
<li><a href="#a1083">A1083</a></li>
<li><a href="#a1084">A1084</a></li>
<li><a href="#a1085">A1085</a></li>
<li><a href="#a1086">A1086</a></li>
<li><a href="#a1087">A1087</a></li>
<li><a href="#a1088">A1088</a></li>
<li><a href="#a1089-two-points">A1089  TWO POINTS</a></li>
<li><a href="#a1090">A1090</a></li>
<li><a href="#a1091">A1091</a></li>
<li><a href="#a1092">A1092</a></li>
<li><a href="#a1093">A1093</a></li>
<li><a href="#a1094">A1094</a></li>
<li><a href="#a1096">A1096</a></li>
<li><a href="#a1097">A1097</a></li>
<li><a href="#a1098">A1098</a></li>
<li><a href="#a1099">A1099</a></li>
<li><a href="#a1100">A1100</a></li>
<li><a href="#a1101">A1101</a></li>
<li><a href="#a1102">A1102</a></li>
<li><a href="#a1103">A1103</a></li>
<li><a href="#a1104">A1104</a></li>
<li><a href="#a1105">A1105</a></li>
<li><a href="#a1106">A1106</a></li>
<li><a href="#a1107">A1107</a></li>
<li><a href="#a1108">A1108</a></li>
<li><a href="#a1109">A1109</a></li>
<li><a href="#a1110">A1110</a></li>
<li><a href="#a1112">A1112</a></li>
<li><a href="#a1113%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B0%B4%E9%A2%98">A1113(小技巧，水题)</a></li>
<li><a href="#a1114-%E5%B9%B6%E6%9F%A5%E9%9B%86">A1114 并查集</a></li>
<li><a href="#a1115%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8Edfs">A1115(二叉搜索树建立与DFS)</a></li>
<li><a href="#a1116">A1116</a></li>
<li><a href="#a1117%E9%80%BB%E8%BE%91%E9%A2%98">A1117(逻辑题)</a></li>
<li><a href="#a1118-%E5%B9%B6%E6%9F%A5%E9%9B%86">A1118  并查集</a></li>
<li><a href="#a1119-30-%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F-%E6%B1%82%E4%B8%AD%E5%BA%8F">A1119 (30 树的前序和后序 求中序)</a></li>
<li><a href="#a1120">A1120</a></li>
<li><a href="#a1121-25-map-set%E5%BA%94%E7%94%A8">A1121 (25 map、set应用)</a></li>
<li><a href="#a112225-%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF-set">A1122(25 哈密顿回路  set)</a></li>
<li><a href="#a112330-avl-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">A1123(30 AVL 、层序遍历、判断是否是完全二叉树)</a></li>
<li><a href="#a1124-20-%E9%80%BB%E8%BE%91%E9%A2%98">A1124  20 逻辑题</a></li>
<li><a href="#a112525-%E8%B4%AA%E5%BF%83-%E6%8E%92%E5%BA%8F">A1125(25 贪心 排序)</a></li>
<li><a href="#a1126">A1126</a></li>
<li><a href="#a112730-%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E5%BB%BA%E6%A0%91dfs%E8%BE%93%E5%87%BAz%E5%AD%97%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">A1127(30 中序后序建树，dfs，输出z字形层序遍历)</a></li>
<li><a href="#a112820-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">A1128(20  n皇后问题)</a></li>
<li><a href="#a1129-25-set%E7%9A%84%E5%BA%94%E7%94%A8-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">A1129 (25 set的应用 结构体内运算符重载)</a></li>
<li><a href="#a1130dfs%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BE%93%E5%87%BA%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">A1130(dfs二叉树 输出中缀表达式)</a></li>
<li><a href="#a113130-dfs-unordered_map%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E9%9A%BE%E9%A2%98">A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</a></li>
<li><a href="#a113220-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%B0%B4%E9%A2%98">A1132(20 字符串 水题)</a></li>
<li><a href="#a1133%E9%93%BE%E8%A1%A8-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97">A1133(链表  重新排列)</a></li>
<li><a href="#a1134%E5%9B%BE-%E7%BB%93%E7%82%B9%E4%B8%8E%E8%BE%B9%E7%9A%84%E9%97%AE%E9%A2%98">A1134(图  结点与边的问题)</a></li>
<li><a href="#a113530-%E5%88%A4%E6%96%AD%E7%BA%A2%E9%BB%91%E6%A0%91-%E9%80%92%E5%BD%92%E5%88%A4%E6%96%AD">A1135(30 判断红黑树 递归判断)</a></li>
<li><a href="#a1136-20-%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2">A1136 (20 回文串 字符串)</a></li>
<li><a href="#a113725-map-%E6%8E%92%E5%BA%8F">A1137(25 map 排序)</a></li>
<li><a href="#a113930-%E9%80%BB%E8%BE%91%E9%A2%98-unordered_map">A1139(30 逻辑题 unordered_map)</a></li>
<li><a href="#a1140">A1140</a></li>
<li><a href="#a1141">A1141</a></li>
<li><a href="#a114225-%E6%97%A0%E5%90%91%E5%AE%8C%E5%85%A8%E5%9B%BE-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%9B%BE-%E4%B8%A4%E7%82%B9%E7%9B%B8%E8%BF%9E">A1142(25 无向完全图 最大子图  两点相连)</a></li>
<li><a href="#a1143">A1143</a></li>
<li><a href="#a114525-hash-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5">A1145(25 hash 平方探查)</a></li>
<li><a href="#a1144">A1144</a></li>
<li><a href="#a1146%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%BA%8F%E5%88%97">A1146(判断是否为拓扑排序序列 )</a></li>
<li><a href="#a114730-%E5%88%A4%E6%96%AD%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%B0%8F%E9%A1%B6%E5%A0%86-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">A1147(30  判断大顶堆小顶堆 后序遍历)</a></li>
<li><a href="#a1148%E7%8B%BC%E4%BA%BA%E6%9D%80-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E7%8B%BC%E4%BA%BA">A1148(狼人杀 找到两个狼人)</a></li>
<li><a href="#a1149">A1149</a></li>
<li><a href="#a115025-%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E5%9B%BE-%E8%BE%93%E5%87%BA%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84">A1150(25 判断循环图 输出最小路径)</a></li>
<li><a href="#a1151">A1151</a></li>
<li><a href="#a115325-%E6%A8%A1%E6%8B%9F-%E6%8E%92%E5%BA%8F%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82-vector-unordered_map">A1153(25 模拟 排序引用传参 vector unordered_map)</a></li>
<li><a href="#a115425-%E5%9B%BE-%E8%BE%B9%E7%9A%84%E4%B8%A4%E7%AB%AF%E7%82%B9%E7%9A%84%E5%88%A4%E6%96%AD">A1154(25 图  边的两端点的判断  )</a></li>
<li><a href="#a115530-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%A4%E6%96%AD%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%B0%8F%E9%A1%B6%E5%A0%86-dfs-%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84">A1155(30 完全二叉树  判断大顶堆小顶堆 dfs  打印路径)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://liuxbo.github.io/post/pat-ti-jie/">
      PAT题解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-05-06</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
      <span class="meta-item">
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://liuxbo.github.io/tag/a8Kpb5X9y/">
              <span>PAT</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>179分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>28765<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <h3 id="a-1001">A 1001</h3>
<pre><code>#include&lt;cstdio&gt;
int main(){
	int a,b,res[10];
	long long sum;
	scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	sum=a+b;
	if(sum&lt;0){
		sum=-sum;
		printf(&quot;-&quot;);
	}
	int i=0;
	if(sum==0) printf(&quot;0&quot;);
	while(sum&gt;0){
		res[i++]=sum%10;
		sum=sum/10;
	}
	for(int j=i-1;j&gt;=0;j--){
		printf(&quot;%d&quot;,res[j]);
		if(j%3==0&amp;&amp;j!=0) printf(&quot;,&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1002多项式求和">A1002(多项式求和)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=1001;
int count1,count2;
double coe[maxn]={},a;
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
	while(count1--){
		int i;
	    scanf(&quot;%d%lf&quot;,&amp;i,&amp;a);
		coe[i]=coe[i]+a;
	}
	scanf(&quot;%d&quot;,&amp;count2);
	while(count2--){
        int k;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		coe[k]=coe[k]+a;
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(coe[k]!=0) printf(&quot; %d %.1f&quot;,k,coe[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a1003">A1003</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=510;
const int INF=1000000000;
int weight[maxn],d[maxn],w[maxn],num[maxn],G[maxn][maxn];
int n;
bool vis[maxn]={false};
void dijks(int s){
	fill(d,d+maxn,INF);
	fill(num,num+maxn,0);
	fill(w,w+maxn,0);
	w[s]=weight[s];
	d[s]=0;
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[j];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[u]+G[u][v]&lt;d[v]){
					num[v]=num[u];
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];
				}else if(d[u]+G[u][v]==d[v]){
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
					}
					num[v]+=num[u];
				}
			}
		}
	}
}
int main(){
	int m,st,end;
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;end);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;weight[i]);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;m;i++){
		int c1,c2;
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		scanf(&quot;%d&quot;,&amp;G[c1][c2]);
		G[c2][c1]=G[c1][c2]; 
	}
	dijks(st);
	printf(&quot;%d %d&quot;,num[end],w[end]);
	return 0;
}
</code></pre>
<h3 id="a1004">A1004</h3>
<pre><code>1.DFS法
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn = 110;
int hashtable[maxn] = { 0 };
vector&lt;int&gt; child[maxn];
int n,m,totallevel=0;
void DFS(int index, int level) {
	if (child[index].size() == 0) {
		hashtable[level]++;
		if (level &gt; totallevel) totallevel=level;
		return;
	}
	for (int i = 0; i &lt; child[index].size(); i++) {
		DFS(child[index][i], level + 1);
	}
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int father,num,temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father, &amp;num);
		while (num--) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[father].push_back(temp);
		}
	}
	DFS(1, 0);
	for (int i = 0; i &lt;= totallevel; i++) {
		printf(&quot;%d&quot;, hashtable[i]);
		if (i &lt; totallevel) printf(&quot; &quot;);
	}
	return 0;
}

2.BFS法
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int hashtable[maxn] = { 0 };
vector&lt;int&gt; child[maxn];
int n, m, level[maxn] = { 0 },maxlevel=0;
void BFS() {
	level[1] = 1;
	queue&lt;int&gt; q;
	q.push(1);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		if (child[now].size() == 0) {
			hashtable[level[now]]++;
			maxlevel = max(maxlevel, level[now]);
		}
		for (int i = 0; i &lt; child[now].size(); i++) {
			level[child[now][i]] = level[now] + 1;
			q.push(child[now][i]);
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int father,num,temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father, &amp;num);
		while (num--) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[father].push_back(temp);
		}
	}
	BFS();
	for (int i = 1; i &lt;= maxlevel; i++) {
		printf(&quot;%d&quot;, hashtable[i]);
		if (i &lt; maxlevel) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1005">A1005</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
int main(){
	int res[3],sum[110],i,result=0;
	char number[110];
	string english[10]={&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;};
	scanf(&quot;%s&quot;,number);
	int len=strlen(number);
	for(i=0;i&lt;len;i++){
		sum[i]=number[i]-'0';
		result+=sum[i];
	}
	int j=0;
	if(result==0) printf(&quot;zero&quot;);
	while(result){
		res[j++]=result%10;
		result/=10;
	}
	for(int x=j-1;x&gt;=0;x--){
		printf(&quot;%s&quot;,english[res[x]].c_str());
		if(x!=0) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1006">A1006</h3>
<pre><code>#include&lt;cstdio&gt; 

struct person {
	char id[16];
	int hh, mm, ss;
}temp,first,last;
bool great(person node1, person node2) {
	if (node1.hh != node2.hh) return node1.hh &gt; node2.hh;
	if (node2.mm != node2.mm) return node1.mm &gt; node2.mm;
	return node1.ss &gt; node2.ss;
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	first.hh = 24, first.mm = 60, first.ss = 60;
	last.hh = 0, last.mm = 0, last.ss = 0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %d:%d:%d&quot;, temp.id, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, first) == false)  first = temp;
		scanf(&quot;%d:%d:%d&quot;, &amp;temp.hh, &amp;temp.mm, &amp;temp.ss);
		if (great(temp, last))   last = temp;
	}
	printf(&quot;%s %s&quot;, first.id, last.id);
	return 0;
}
</code></pre>
<h3 id="a1007">A1007</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
	dp[0]=a[0];
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
<h3 id="a1008">A1008</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
	int n,a[100000],totaltime=0;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
		if (i == 0) totaltime = a[i] * 6 + 5;
		else {
			if (a[i] &gt; a[i - 1]) totaltime +=(a[i] - a[i - 1]) * 6 + 5;
			else totaltime += ((a[i-1] - a[i]) * 4 + 5);
		}
	}
	cout &lt;&lt; totaltime;
	return 0;
}
</code></pre>
<h3 id="a1009-多项式相乘">A1009 多项式相乘</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string.h&gt;
const int maxn=2001;
int count1,count2;
struct poly{
	int exp;
	double coef;
}coe[1001];
double result[maxn];
int number=0;
int main(){
	scanf(&quot;%d&quot;,&amp;count1);
for(int i =0;i&lt;count1;i++){
	scanf(&quot;%d%lf&quot;,&amp;coe[i].exp,&amp;coe[i].coef);
    }
	scanf(&quot;%d&quot;,&amp;count2);
for(int i=0;i&lt;count2;i++){
	int k;
	double a;
		scanf(&quot;%d%lf&quot;,&amp;k,&amp;a);
		for(int i=0;i&lt;count1;i++){
			result[k+coe[i].exp]+=(a*coe[i].coef);
		}
	}
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0){
			number++;
		}
	}
    printf(&quot;%d&quot;,number);
	for(int k=maxn-1;k&gt;=0;k--){
		if(result[k]!=0) printf(&quot; %d %.1f&quot;,k,result[k]);
	}
	return 0;
} 
</code></pre>
<h3 id="a1010-二分">A1010 二分</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
using namespace std;
long long convert_to10(string n, long long radix) {
	int temp=0, index = 0;
	long long sum = 0;
	for (auto it = n.rbegin(); it != n.rend(); it++) {
		temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
		sum += temp * pow(radix, index++);
	}
	return sum;
}
long long find_radix(string n, long long num) {
	char it = *max_element(n.begin(), n.end());
	long long low = (isdigit(it) ? it - '0' : it - 'a' + 10) + 1;
	long long high = max(low, num);
	while (low &lt;= high) {
		long long mid = (low + high) / 2;
		long long t = convert_to10(n, mid);
		if (t &gt; num || t &lt; 0) high = mid - 1;
		else if (t == num) return mid;
		else if (t &lt; num)  low = mid + 1;
	}
	return -1;
}
int main() {
	string n1, n2;
	int tag;
	long long radix;
	cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix;
	long long ans = tag == 1 ? find_radix(n2, convert_to10(n1, radix)) : find_radix(n1, convert_to10(n2, radix));
	if (ans == -1) printf(&quot;Impossible&quot;);
	else printf(&quot;%lld&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1011">A1011</h3>
<pre><code>#include&lt;cstdio&gt; 
char s[4] = &quot;WTL&quot;;
double a,res=1;
int main() {
	for (int i = 0; i &lt; 3; i++) {
		int imax;
		double temp = 0;
		for (int i = 0; i &lt; 3; i++) {
			scanf_s(&quot;%lf&quot;, &amp;a);
			if (a &gt; temp) {
				temp = a;
				imax = i;
			}
		}
		res *= temp;
		printf(&quot;%c &quot;, s[imax]);
	}
	printf(&quot;%.2f&quot;, (res * 0.65 - 1) * 2);
	return 0;
}
</code></pre>
<h3 id="a1012">A1012</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int id;
	int grade[4];
}stu[2100];
int now;
bool cmp(node a, node b) {return a.grade[now] &gt; b.grade[now];}
int rank_stu[1000000][4] = { 0 };
char course[4] = { 'A','C','M','E' };
int main() {
	int n, m;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;stu[i].id, &amp;stu[i].grade[1], &amp;stu[i].grade[2], &amp;stu[i].grade[3]);
		stu[i].grade[0] = stu[i].grade[1] + stu[i].grade[2] + stu[i].grade[3];
	}
	for (now = 0; now &lt; 4; now++) {
		sort(stu, stu + n, cmp);
		rank_stu[stu[0].id][now] = 1;
		for (int i = 1; i &lt; n; i++) {
			if (stu[i].grade[now] == stu[i - 1].grade[now]) rank_stu[stu[i].id][now] = rank_stu[stu[i - 1].id][now];
			else rank_stu[stu[i].id][now] = i+1;
		}
	}
	int query;
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;query);
		if (rank_stu[query][0] == 0) printf(&quot;N/A\n&quot;);
		else {
			int best=0;
			for (int j = 0; j &lt; 4; j++) {
				if (rank_stu[query][j] &lt; rank_stu[query][best])
					best = j;
			}
			printf(&quot;%d %c\n&quot;, rank_stu[query][best], course[best]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1013">A1013</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1010;
vector&lt;int&gt; G[maxn];
bool vis[maxn]={false};
int deletepoint;
void DFS(int v){
	if(v==deletepoint) return;
	vis[v]=true;
	for(int i=0;i&lt;G[v].size();i++){
		if(vis[G[v][i]]==false){
			DFS(G[v][i]);
		}
	}
}
int main(){
	int n,m,k;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	while(m--){
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		G[a].push_back(b);
		G[b].push_back(a);
	}
	for(int i=0;i&lt;k;i++){
		int block=0;
		scanf(&quot;%d&quot;,&amp;deletepoint);
		fill(vis,vis+maxn,false);
		for(int j=1;j&lt;=n;j++){
			if(j!=deletepoint&amp;&amp;vis[j]==false){
				DFS(j);
				block++;
			}
		}
		printf(&quot;%d\n&quot;,block-1);
	}
	return 0;
}
</code></pre>
<h3 id="a101430-模拟-难题">A1014(30 模拟  难题)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct node {
	int poptime, endtime;
	queue&lt;int&gt; q;
};
int main() {
	int n, m, k, Q, index = 1, query;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;Q);
	vector&lt;int&gt; time(k + 1), ans(k + 1);
	for (int i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;time[i]);
	vector&lt;node&gt;window(n + 1);
	vector&lt;bool&gt;sorry(k + 1, false);
	for (int i = 1; i &lt;= m; i++) {
		for (int j = 1; j &lt;= n; j++) {
			if (index &lt;= k) {
				window[j].q.push(time[index]);
				if (window[j].endtime &gt;= 540) sorry[index] = true;
				window[j].endtime += time[index];
				if (i == 1) window[j].poptime = window[j].endtime;
				ans[index] = window[j].endtime;
				index++;
			}
		}
	}
	while (index &lt;= k) {
		int minpoptime = window[1].poptime, tempwindow = 1;
		for (int i = 2; i &lt;= n; i++) {
			if (window[i].poptime &lt; minpoptime) {
				minpoptime = window[i].poptime;
				tempwindow = i;
			}
		}
		window[tempwindow].q.pop();
		window[tempwindow].poptime += window[tempwindow].q.front();
		window[tempwindow].q.push(time[index]);
		if (window[tempwindow].endtime &gt;= 540) sorry[index] = true;
		window[tempwindow].endtime += time[index];
		ans[index] = window[tempwindow].endtime;
		index++;
	}
	while (Q--) {
		scanf(&quot;%d&quot;, &amp;query);
		if (sorry[query] == true) printf(&quot;Sorry\n&quot;);
		else printf(&quot;%02d:%02d\n&quot;, (ans[query] + 480) / 60, (ans[query] + 480) % 60);
	}
	return 0;
}
</code></pre>
<h3 id="a1015">A1015</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = (int)sqrt(n * 1.0);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
int change(int n,int b) {
	int res[20],ans=0;
	int j = 0;
	do {
		res[j++] = n % b;
		n = n / b;
	} while (n != 0);
	reverse(res, res+ j);
	for (int i = 0; i &lt; j; i++) {
		ans += res[i] * pow(b*(1.0), i*(1.0));
	}
	return ans;
}
int main() {
	while (1) {
		int num, radix;
		scanf_s(&quot;%d&quot;, &amp;num);
		if (num &lt; 0) break;
		else {
			scanf_s(&quot;%d&quot;, &amp;radix);
			int ans = change(num, radix);
			if (isprime(num) &amp;&amp; isprime(ans)) printf(&quot;Yes\n&quot;);
			else printf(&quot;No\n&quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1016">A1016</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 1010;
int toll[24];
struct Record {
	char name[21];
	int mon, dd, hh, mm;
	bool status;
}rec[maxn],temp;
bool cmp(Record a, Record b) {
	if (strcmp(a.name, b.name) != 0) return strcmp(a.name, b.name) &lt; 0;
	else if (a.mon != b.mon) return a.mon &lt; b.mon;
	else if (a.dd != b.dd) return a.dd &lt; b.dd;
	else if (a.hh != b.hh) return a.hh &lt; b.hh;
	else return a.mm &lt; b.mm;
}
void get_ans(int on, int off, int&amp; time, int&amp; money) {
	temp = rec[on];
	while (temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) {
		time++;
		money += toll[temp.hh];
		temp.mm++;
		if (temp.mm &gt;= 60) {
			temp.mm = 0;
			temp.hh++;
		}
		if (temp.hh &gt;= 24) {
			temp.hh = 0;
			temp.dd++;
		}
	}
}
int main() {
	char line_status[10];
	int n;
	for (int i = 0; i &lt; 24; i++) scanf(&quot;%d&quot;, &amp;toll[i]);
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %d:%d:%d:%d %s&quot;, rec[i].name, &amp;rec[i].mon, &amp;rec[i].dd, &amp;rec[i].hh, &amp;rec[i].mm,line_status);
		if (strcmp(line_status, &quot;on-line&quot;) == 0) rec[i].status = true;
		if (strcmp(line_status, &quot;off-line&quot;) == 0) rec[i].status = false;
	}
	sort(rec, rec + n, cmp);
	int on = 0, off, next;
	while (on &lt; n) {//每次处理一个用户的所有记录
		int needprint = 0;
		next = on;
		while (next &lt; n &amp;&amp; strcmp(rec[next].name, rec[on].name) == 0) {//判断是否有配对项
			if (rec[next].status == true &amp;&amp; needprint == 0) needprint = 1;
			else if (rec[next].status == false &amp;&amp; needprint == 1) needprint = 2;
			next++;
		}
		if (needprint &lt; 2) {
			on = next;
			continue;
		}
		int allmoney = 0;
		printf(&quot;%s %02d\n&quot;, rec[on].name, rec[on].mon);
		while (on &lt; next) {
			while (on &lt; next - 1 &amp;&amp; !(rec[on].status == true &amp;&amp; rec[on + 1].status == false)) on++;
			off = on + 1;
			if (off == next) {
				on = next;
				break;
			}
			int time = 0;
			int  money = 0;
			get_ans(on, off, time, money);
			allmoney += money;
			printf(&quot;%02d:%02d:%02d &quot;, rec[on].dd, rec[on].hh, rec[on].mm);
			printf(&quot;%02d:%02d:%02d &quot;, rec[off].dd, rec[off].hh, rec[off].mm);
			printf(&quot;%d $%.2f\n&quot;, time, money / 100.0);
			on=off+1;
		}
		printf(&quot;Total amount:$%.2f\n&quot;, double(allmoney) / 100);
	}
	return 0;
}
</code></pre>
<h3 id="a1017-25-模拟-时间处理-排序">A1017 （25 模拟 ，时间处理、排序、）</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int cometime;
	int servetime;
}newcustomer; 
int Endtime[101];
vector&lt;node&gt; customer;
int convert(int h,int m,int s){
	return h*3600+m*60+s;
}
bool cmp(node a,node b){
	return a.cometime&lt;b.cometime;
}
int main(){
	int n,w,totwait=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;w);
	int starttime=convert(8,0,0);
	int endtime=convert(17,0,0);
	for(int i=0;i&lt;n;i++){
		int hh,mm,ss,serve;
		scanf(&quot;%d:%d:%d %d&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;serve);
		newcustomer.cometime=convert(hh,mm,ss);
		if(newcustomer.cometime&gt;endtime) continue;
		newcustomer.servetime=(serve&lt;=60?serve*60:3600);
		customer.push_back(newcustomer);
	}
	sort(customer.begin(),customer.end(),cmp);
	for(int i=0;i&lt;=101;i++) Endtime[i]=starttime;
	for(int i=0;i&lt;customer.size();i++){
		int minendtime=1000000000,id=-1;
		for(int j=0;j&lt;w;j++){
			if(Endtime[j]&lt;minendtime){
				minendtime=Endtime[j];
				id=j;
			}
		}
		if(Endtime[id]&lt;=customer[i].cometime){
			Endtime[id]=customer[i].cometime+customer[i].servetime;
		}else{
			totwait+=Endtime[id]-customer[i].cometime; 
			Endtime[id]+=customer[i].servetime; 
		}
	}
	if(customer.size()==0) printf(&quot;0.0&quot;);
	else printf(&quot;%.1f&quot;,(double)((totwait*1.0/60.0)/customer.size()));
	return 0;
}
</code></pre>
<h3 id="a1018">A1018</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int  maxn=510;
const int INF=1000000000;
int minneed=INF,minremain=INF,cmax,n,sp,m;
int G[maxn][maxn],d[maxn],weight[maxn];
vector&lt;int&gt; path,temppath;
vector&lt;int&gt;pre[maxn];
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=0;i&lt;=n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;=n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;=n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					pre[v].clear();
					pre[v].push_back(u);
				}else if(d[v]==G[u][v]+d[u]){
					pre[v].push_back(u);
				}
			}
		}
	}
}
void DFS(int v){
	if(v==0){
		temppath.push_back(v);
		int need=0,remain=0;
		for(int i=temppath.size()-1;i&gt;=0;i--){
			int id=temppath[i];
			if(weight[id]&gt;0){
				remain+=weight[id];
			}else{
				if(abs(weight[id])&lt;remain){
					remain-=abs(weight[id]);
				}else {
					need+=abs(weight[id])-remain;
					remain=0;
				}
			}
		} 
		if(need&lt;minneed){
			minneed=need;
			minremain=remain;
			path=temppath;
		}else if(need==minneed&amp;&amp;remain&lt;minremain){
			minremain=remain;
			path=temppath;
		}
		temppath.pop_back();
		return;
	}
	temppath.push_back(v);
	for(int i=0;i&lt;pre[v].size();i++){
		DFS(pre[v][i]);
	}
	temppath.pop_back();
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;cmax,&amp;n,&amp;sp,&amp;m);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;weight[i]);
		weight[i]-=cmax/2;
	}
	for(int i=1;i&lt;=m;i++){
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		scanf(&quot;%d&quot;,&amp;G[a][b]);
		G[b][a]=G[a][b];
	}
	dijkst(0);
	DFS(sp);
	printf(&quot;%d &quot;,minneed);
	for(int i=path.size()-1;i&gt;=0;i--){
		printf(&quot;%d&quot;,path[i]);
		if(i&gt;0) printf(&quot;-&gt;&quot;);
	}
	printf(&quot; %d&quot;,minremain);
	return 0;
}
</code></pre>
<h3 id="a1019">A1019</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; a,c;
void change(int n,int b){
	if(n&gt;0){
		int i=0;
		change(n/b,b);
		a.push_back(n%b);
	}
	else return;
}
bool judge(vector&lt;int&gt; a,vector&lt;int&gt; b){
	for(int i=0;i&lt;a.size();i++){
		if (a[i]==b[i]) continue;
		else return false;
	}
	return true;
}
int main(){
	int n,b;
	scanf(&quot;%d %d&quot;,&amp;n,&amp;b);
	change(n,b);
	for(int i=0;i&lt;a.size();i++){
		c.push_back(a[i]);
	}
	for (int min = 0, max = a.size()-1; min &lt;= max; min++, max--) {
		int temp = a[min];
		a[min] = a[max];
		a[max] = temp;
	}
	if(judge(a,c)==true){
		printf(&quot;Yes\n&quot;);
		for(int i=0;i&lt;c.size();i++){
			printf(&quot;%d&quot;,c[i]);
			if(i!=c.size()-1) printf(&quot; &quot;);
		}
	}
	if(judge(a,c)==false) {
		printf(&quot;No\n&quot;);
		for(int i=0;i&lt;c.size();i++){
			printf(&quot;%d&quot;,c[i]);
			if(i!=c.size()-1) printf(&quot; &quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1020">A1020</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
int postorder[31], inorder[31], n;
struct node {
	int data;
	node* lchild;
	node* rchild;
};
node* create(int postL, int postR, int inL, int inR) {
	if (postL &gt; postR) return NULL;
	node* root = new node;
	root-&gt;data = postorder[postR];
	int k;
	for (int i = inL; i &lt;= inR; i++) {
		if (inorder[i] == root-&gt;data) {
			k = i;
			break;
		}
	}
	int leafnum = k - inL;
	root-&gt;lchild = create(postL, postL + leafnum - 1, inL, k - 1);
	root-&gt;rchild = create(postL + leafnum, postR - 1, k + 1, inR);
	return root;
}
int num = 0;
void layerorder(node* root) {
	queue&lt;node*&gt; q;
	q.push(root);
	while (!q.empty()) {
		node* now = q.front();
		q.pop();
		printf(&quot;%d&quot;, now-&gt;data);
        num++;
		if (num &lt; n) printf(&quot; &quot;);
		if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);
		if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);
	}
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;postorder[i]);
	}
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;inorder[i]);
	}
	node* root = create(0, n - 1, 0, n - 1);
	layerorder(root);
	return 0;
}
</code></pre>
<h3 id="a1021">A1021</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
vector&lt;vector&lt;int&gt; &gt; G;
set&lt;int&gt; ans;
vector&lt;int&gt; temp;
bool vis[maxn]={false};
int maxheight=0;
void DFS(int node,int height){
	if(height&gt;maxheight){
		maxheight=height;
		temp.clear();
		temp.push_back(node);
	}else if(height==maxheight){
		temp.push_back(node);
	}
	vis[node]=true;
	for(int i=0;i&lt;G[node].size();i++){
		if(vis[G[node][i]]==false){
			DFS(G[node][i],height+1);
		}
	}
}
int main(){
	int n,count=0,select1;
	scanf(&quot;%d&quot;,&amp;n);
	G.resize(n+1);
	for(int i=0;i&lt;n-1;i++){
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		G[a].push_back(b);
		G[b].push_back(a);
	}
	for(int i=1;i&lt;=n;i++){
		if(vis[i]==false){
			DFS(i,1);
		    if(i==1){
			   if(temp.size()!=0) select1=temp[0];
			   for(int j=0;j&lt;temp.size();j++)	ans.insert(temp[j]);
	    	}
	    	count++;
		} 	
	}
	if(count&gt;=2) printf(&quot;Error: %d components&quot;,count);
	else{
		temp.clear();
		maxheight=0;
		fill(vis,vis+maxn,false);
		DFS(select1,1);
		for(int i=0;i&lt;temp.size();i++) ans.insert(temp[i]);
		for(auto it=ans.begin();it!=ans.end();it++) printf(&quot;%d\n&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1022">A1022</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string, set&lt;int&gt; &gt; mptitle, mpautor, mpkey, mppublish, mpyear;
void query(map&lt;string, set&lt;int&gt; &gt;&amp; mp, string&amp; str) {
	if (mp.count(str) == 0) cout &lt;&lt; &quot;Not Found\n&quot;;
	else {
		for (auto it = mp[str].begin(); it != mp[str].end(); it++) {
			printf(&quot;%07d\n&quot;, *it);
		}
	}
}
int main() {
	int n,m,id;
	cin &gt;&gt; n;
	string title, autor, keyword, publish, year;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		char c = getchar();
		getline(cin, title);
		mptitle[title].insert(id);
		getline(cin, autor);
		mpautor[autor].insert(id);
		while (cin &gt;&gt; keyword) {
			mpkey[keyword].insert(id);
			 c = getchar();
			if (c == '\n') break;
		}
		getline(cin, publish);
		mppublish[publish].insert(id);
		getline(cin, year);
		mpyear[year].insert(id);
	}
	cin &gt;&gt; m;
	while(m--){
		int type;
		string temp;
		scanf(&quot;%d: &quot;, &amp;type);
		getline(cin, temp);
		cout &lt;&lt; type &lt;&lt; &quot;:&quot; &lt;&lt; &quot; &quot; &lt;&lt; temp&lt;&lt;endl;
		if (type == 1) query(mptitle, temp);
		if (type == 2) query(mpautor, temp);
		if (type == 3) query(mpkey, temp);
		if (type == 4) query(mppublish, temp);
		if (type == 5) query(mpyear, temp);
	}
	return 0;
}
</code></pre>
<h3 id="a1023">A1023</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
bool judge(bign a, bign b) {
	if (a.len != b.len) return false;
	else {
		int count[10] = { 0 };
		for (int i = 0; i &lt; a.len; i++) {
			count[a.d[i]]++;
			count[b.d[i]]--;
		}
		for (int i = 0; i &lt; 10; i++) {
			if (count[i] != 0) {
				return false;
			}
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
}
int main() {
	string str;
	cin &gt;&gt; str;
	bign a, ans;
	a=change(str);
	ans = multi(a, 2);
	if (judge(a, ans)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	print(ans);
	return 0;
}
</code></pre>
<h3 id="a1024">A1024</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
struct bign {
	int d[100];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign res;
	res.len = str.size();
	for (int i = 0; i &lt; res.len; i++) {
		res.d[i] = str[res.len - 1 - i]-'0';
	}
	return res;
}
bign add(bign a, bign b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len || i &lt; b.len; i++) {
		int temp = a.d[i] + b.d[i] + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	if (carry != 0) {
		c.d[c.len++] = carry % 10;
	}
	return c;
}
bool judge(bign a) {
	for (int i = 0; i &lt;= a.len / 2; i++) {
		if (a.d[i] != a.d[a.len - 1 - i]) {
			return false;
		}
	}
	return true;
}
void print(bign a) {
	for (int i = a.len - 1; i &gt;= 0; i--) {
		printf(&quot;%d&quot;, a.d[i]);
	}
	cout &lt;&lt; endl;
}
int main() {
	string str;
	int k;
	cin &gt;&gt; str;
	cin &gt;&gt; k;
	bign ans=change(str);
	int i;
	for ( i = 0; i &lt; k; i++) {
		if (judge(ans)) break;
		bign temp = ans;
		reverse(temp.d, temp.d + temp.len);
		ans = add(temp, ans);
	}
	print(ans);
	if (i &lt;= k) cout &lt;&lt; i;
	else cout &lt;&lt; k;
	return 0;
}
</code></pre>
<h3 id="a1025">A1025</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
struct student{
	char id[15];
	int grade;
	int lrank,frank;
	int local_num;
}testee[30010];
bool cmp1(student a,student b){ 
     return a.grade&gt;b.grade;
}
bool cmp2(student a,student b){
	if(a.frank!=b.frank) return a.frank&lt;b.frank;
	else if(strcmp(a.id,b.id)!=0) return strcmp(a.id,b.id)&lt;0;
}
int main(){
	int n;
	int total=0;
	int localnum=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++){
		int temp;
		localnum++;
		int on,off;
		on=total;
		off=on;
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;temp;j++){
			scanf(&quot;%s%d&quot;,testee[total].id,&amp;testee[total].grade);
			testee[total].local_num=localnum;
			total++;
			off++;
		}
		sort(testee+on,testee+off,cmp1);
		testee[on].lrank=1;
		for(int k=on+1;k&lt;off;k++){
			if(testee[k].grade==testee[k-1].grade) testee[k].lrank=testee[k-1].lrank;
			else testee[k].lrank=k-on+1;
		}
	}
	sort(testee,testee+total,cmp1);
	testee[0].frank=1;
	for(int k=1;k&lt;total;k++){
		if(testee[k].grade==testee[k-1].grade) testee[k].frank=testee[k-1].frank;
		else testee[k].frank=k+1;
	}
	sort(testee,testee+total,cmp2);
	printf(&quot;%d\n&quot;,total);
	for(int i=0;i&lt;total;i++){
		printf(&quot;%s %d %d %d\n&quot;,testee[i].id,testee[i].frank,testee[i].local_num,testee[i].lrank);
	}
	return 0;
}
</code></pre>
<h3 id="a1027">A1027</h3>
<pre><code>#include&lt;cstdio&gt;
int a[2],b[2],c[2];
	void change(int x,int a[]){
		if(x==0) {
			a[0]=0;
			a[1]=0;
		}
		else{
			a[0]=x%13;
			if((x/13)==0) a[1]=0;
			else a[1]=(x/13)%13;
		}
	}
int main(){
	int red,green,blue;
	scanf(&quot;%d %d %d&quot;,&amp;red,&amp;green,&amp;blue);
	char str[15]={'0','1','2','3','4','5','6','7','8','9','A','B','C'};
    change(red,a);
	printf(&quot;#%c%c&quot;,str[a[1]],str[a[0]]);
	change(green,b);
	printf(&quot;%c%c&quot;,str[b[1]],str[b[0]]);
	change(blue,c);
	printf(&quot;%c%c&quot;,str[c[1]],str[c[0]]);
	return 0;
} 
</code></pre>
<h3 id="a1028">A1028</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
struct node {
	char id[10];
	char name[10];
	int grade;
}student[100010];
int c;
bool cmp(node a, node b) {
	if (c == 1) return strcmp(a.id, b.id) &lt; 0;
	if (c == 2) {
		if (strcmp(a.name, b.name) != 0) return strcmp(a.name, b.name) &lt; 0;
		else return strcmp(a.id, b.id) &lt; 0;
	}
	if (c == 3) {
		if (a.grade != b.grade) return a.grade &lt; b.grade;
		else return strcmp(a.id, b.id) &lt; 0;
	}
}
int main() {
		int n;
		scanf(&quot;%d&quot;, &amp;n);
		scanf(&quot;%d&quot;, &amp;c);
		for (int i = 0; i &lt; n; i++) scanf(&quot;%s%s%d&quot;, student[i].id, student[i].name, &amp;student[i].grade);
		sort(student, student + n, cmp);
		for (int i = 0; i &lt; n; i++) printf(&quot;%s%s%d\n&quot;, student[i].id, student[i].name, student[i].grade);
		return 0;
}
</code></pre>
<h3 id="a1029">A1029</h3>
<pre><code>1.直接暴力
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
int main(){
    int n1,n2;
    long long a[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    int i;
    for( i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for( i=n1;i&lt;n2+n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
    sort(a,a+n1+n2);
    printf(&quot;%d&quot;,a[(n1+n2-1)/2]);
    return 0;
}

2.two points

#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=400010;
const int INF=(1&lt;&lt;31)-1;
int main(){
    int n1,n2;
    long long a[maxn],b[maxn];
    scanf(&quot;%d&quot;,&amp;n1);
    for(int i=0;i&lt;n1;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
    }
      scanf(&quot;%d&quot;,&amp;n2);
    for(int i=0;i&lt;n2;i++){
        scanf(&quot;%lld&quot;,&amp;b[i]);
    }
    a[n1]=INF;
    b[n2]=INF;
    int midpos=(n1+n2-1)/2;
    int count=0,j=0,i=0;
    while(count&lt;midpos){
        if(a[i]&lt;b[j]) i++;
        else j++;
        count++;
    }
    if(a[i]&lt;b[j]) printf(&quot;%lld&quot;,a[i]);
    else printf(&quot;%lld&quot;,b[j]);
    return 0;
}
</code></pre>
<h3 id="a1030">A1030</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int  maxn=510;
const int INF=1000000000;
int n,m,st,destination;
int G[maxn][maxn],d[maxn],cost[maxn][maxn],pre[maxn],costtotal[maxn];
bool vis[maxn]={false};
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(costtotal,costtotal+maxn,INF);
	d[s]=0;
	costtotal[s]=0;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					costtotal[v]=cost[u][v]+costtotal[u];
					pre[v]=u;
				}else if(d[v]==G[u][v]+d[u]&amp;&amp;costtotal[v]&gt;costtotal[u]+cost[u][v]){
					costtotal[v]=cost[u][v]+costtotal[u];
					pre[v]=u;
				}
			}
		}
	}
}
void DFS(int v){
	if(v==st){
		printf(&quot;%d &quot;,v);
		return;
	}
    DFS(pre[v]);
    printf(&quot;%d &quot;,v);
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;destination);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=m;i++){
		int c1,c2,dis,cos;
		scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2);
		scanf(&quot;%d&quot;,&amp;G[c1][c2]);
		G[c2][c1]=G[c1][c2];
		scanf(&quot;%d&quot;,&amp;cost[c1][c2]);
		cost[c2][c1]=cost[c1][c2];
	}
	dijkst(st);
	DFS(destination);
	printf(&quot;%d %d&quot;,d[destination],costtotal[destination]);
	return 0;
}
</code></pre>
<h3 id="a1031">A1031</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
int main() {
	char str[100], uu[40][40];
    scanf(&quot;%s&quot;,str); 
	int N = strlen(str);
	int n1=(N+2)/3;
	int n3=(N+2)/3;
	int n2=N-n1-n3+2;
	int pos=0;
    memset(uu,' ',sizeof(uu));
	for(int i=0;i&lt;n1-1;i++){
		uu[i][0]=str[pos++];
	} 
	for(int j=0;j&lt;n2;j++){
		uu[n1-1][j]=str[pos++];
	}
	for(int k=n3-2;k&gt;=0;k--){
		uu[k][n2-1]=str[pos++];
	}
	for(int i=0;i&lt;n1;i++){
		for(int j=0;j&lt;n2;j++){
			printf(&quot;%c&quot;,uu[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1032链表">A1032(链表)</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn = 100010;
struct Node {
	int data;
	int next;
	bool flag;
}node[maxn];
int main() {
	int begin1, begin2, n;
	scanf(&quot;%d%d%d&quot;, &amp;begin1, &amp;begin2, &amp;n);
	for (int i = 0; i &lt; maxn; i++) {
		node[i].flag = false;
	}
	int address, data, next;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d %c %d&quot;, &amp;address, &amp;data, &amp;next);
		node[address].data = data;
		node[address].next = next;
	}
	int p;
	for (p = begin1; p != -1; p = node[p].next) {
		node[p].flag = true;
	}
	for (p = begin2; p != -1; p = node[p].next) {
		if (node[p].flag == true) {
			printf(&quot;%05d&quot;, p);
			break;
		}
	}
	if (p == -1) {
		printf(&quot;-1&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1033">A1033</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 510;
const int INF = 1000000000;
struct node{
	double price;
	double distance;
}station[maxn];
bool cmp(node a, node b) {
	return a.distance &lt; b.distance;
}
int main() {
	double cmax, d, davg;
	int n;
	scanf(&quot;%lf%lf%lf%d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%lf%lf&quot;, &amp;station[i].price, &amp;station[i].distance);
	}
	station[n].distance = d;
	station[n].price = 0;
	sort(station, station + n + 1, cmp);
	if (station[0].distance != 0) {
		printf(&quot;The maximum travel distance = 0.00&quot;);
		return 0;
	}
	int now = 0;
	double nowtank = 0, expend = 0,  canrun = cmax * davg;
	while (now &lt; n) {
        int k=-1;
        double minprice=INF;
		for (int i = now + 1; (station[i].distance - station[now].distance) &lt;= canrun &amp;&amp; i &lt;= n; i++) {
			if (station[i].price &lt; minprice) {
				minprice = station[i].price;
				k = i;
				if (minprice &lt; station[now].price) {
					break;
				}
			}
		}
		if (k == -1) break;
		double need = (station[k].distance - station[now].distance) / davg;
		if (station[k].price &lt; station[now].price) {
			if (nowtank &lt; need) {
				expend += (need - nowtank) * station[now].price;
				nowtank = 0;
			}
			else {
				nowtank -= need;
			}
		}
		else {
			expend += (cmax - nowtank) * station[now].price;
			nowtank = cmax - need;
		}
		now = k;
	}
	if (now == n) printf(&quot;%.2f&quot;, expend);
	else printf(&quot;The maximum travel distance = %.2f&quot;, station[now].distance + canrun);
	return 0;
}
</code></pre>
<h3 id="a1034">A1034</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
const int maxn = 2100;
map&lt;string, int&gt; stringtoint;
map&lt;int, string&gt; inttostring;
map&lt;string, int&gt; gang;
int G[maxn][maxn] = { 0 }, numperson = 0, weight[maxn] = { 0 }, k;
bool vis[maxn] = { false };
void DFS(int visnow, int&amp; head, int&amp; nummember, int&amp; totalvalue) {
	nummember++;
	vis[visnow] = true;
	if (weight[visnow] &gt; weight[head]) head = visnow;
	for (int i = 0; i &lt; numperson; i++) {
		if (G[visnow][i] &gt; 0) {
			totalvalue += G[visnow][i];
			G[visnow][i] = 0;
			G[i][visnow] = 0;
            if (vis[i] == false) {
			DFS(i, head, nummember, totalvalue);
	 	  }
		}	
	}
}
void DFStrave() {
	for (int i = 0; i &lt; numperson; i++) {
		if (vis[i] == false) {
			int head = i, nummember = 0, totalvalue = 0;
			DFS(i, head, nummember, totalvalue);
			if (totalvalue &gt; k &amp;&amp; nummember &gt; 2) {
				gang[inttostring[head]] = nummember;
			}
		}
	}
}
int change(string str) {
	if (stringtoint.count(str) == 0) {
		stringtoint[str] = numperson;
		inttostring[numperson] = str;
		return numperson++;
	}
	else {
		return stringtoint[str];
	}
}
int main() {
	int n, phonetime;
	string str1, str2;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; phonetime;
		int id1 = change(str1);
		int id2 = change(str2);
		weight[id1] += phonetime;
		weight[id2] += phonetime;
		G[id1][id2] += phonetime;
		G[id2][id1] += phonetime;
	}
	DFStrave();
	cout &lt;&lt; gang.size() &lt;&lt; endl;
	for (auto it = gang.begin();it!=gang.end();it++) {
		cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1035">A1035</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
struct node {
	char name[11];
	char password[11];
	bool flag;
}user[1010];
int main() {
	int n, change = 0;;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s%s&quot;, user[i].name, user[i].password);
		user[i].flag = false;
		int len1 = strlen(user[i].password);
		for (int j = 0; j &lt; len1; j++) {
			if (user[i].password[j] == '1') {
				user[i].password[j] = '@';
				user[i].flag = true;
			}
			else if (user[i].password[j] == '0') {
				user[i].password[j] = '%';
				user[i].flag = true;
			}
			else if (user[i].password[j] == 'l') {
				user[i].password[j] = 'L';
				user[i].flag = true;
			}
			else if (user[i].password[j] == 'O') {
				user[i].password[j] = 'o';
				user[i].flag = true;
			}
		}
		if (user[i].flag == true) change++;
	}
	if (n == 1) printf(&quot;There is 1 account and no account is modified&quot;);
	else if (n &gt; 1 &amp;&amp; change == 0) printf(&quot;There are %d accounts and no account is modified&quot;, n);
	else if (n &gt; 1 &amp;&amp; change &gt; 0) {
		printf(&quot;%d\n&quot;, change);
		for (int i = 0; i &lt; n; i++) {
			if (user[i].flag == true) {
				printf(&quot;%s %s\n&quot;, user[i].name, user[i].password);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1036">A1036</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
struct student {
	char name[11];
	char gender;
	char id[11];
	int score;
}male,female,temp;
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	female.score = -1;
	male.score = 101;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s %c %s %d&quot;, temp.name, &amp;temp.gender, temp.id, &amp;temp.score);
		if (temp.gender == 'F') {
			if (temp.score &gt; female.score) {
				female = temp;
			}
		}
		if (temp.gender == 'M') {
			if (temp.score &lt; male.score) {
				male = temp;
			}
		}
	}
	if (female.score == -1) printf(&quot;Absent\n&quot;);
	if (female.score &gt; -1) printf(&quot;%s %s\n&quot;, female.name, female.id);
	if (male.score == 101) printf(&quot;Absent\n&quot;);
	if (male.score &lt;101) printf(&quot;%s %s\n&quot;, male.name, male.id);
	if (female.score == -1 || male.score == 101) printf(&quot;NA&quot;);
	if (female.score &gt; -1 &amp;&amp; male.score &lt; 101) printf(&quot;%d&quot;, female.score - male.score);
	return 0;
}
</code></pre>
<h3 id="a1037">A1037</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int coupon[maxn];
	int product[maxn];
	int n, m;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;coupon[i]);
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;product[i]);
	}
	sort(coupon, coupon + n);
	sort(product, product + m);
	int j = 0, ans = 0;
	while (j &lt; n &amp;&amp; coupon[j] &lt; 0 &amp;&amp; product[j] &lt; 0 &amp;&amp; j &lt; m) {
		ans += coupon[j] * product[j];
		j++;
	}
	int k = n - 1, i = m - 1;
	while (k &gt;= 0 &amp;&amp; i &gt;= 0 &amp;&amp; coupon[k] &gt; 0 &amp;&amp; product[i] &gt; 0) {
		ans += coupon[k] * product[i];
		k--;
		i--;
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1038">A1038</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 10010;
bool cmp(string a, string b) {
	return a + b &lt; b + a;
}
int main() {
	int n;
	string str[maxn];
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; str[i];
	}
	sort(str, str + n, cmp);
	string ans;
	for (int i = 0; i &lt; n; i++) {
		ans += str[i];
	}
	while (ans[0] == '0' &amp;&amp; ans.size() != 0) {
		ans.erase(ans.begin());
	}
	if (ans.length() != 0) cout &lt;&lt; ans;
	else cout &lt;&lt; &quot;0&quot;;
	return 0;
}
</code></pre>
<h3 id="a1039">A1039</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 26 * 26 * 26 * 10 + 10;
vector&lt;int&gt; stu[maxn];
int getid(char name[]) {
	int id=0;
	for (int i = 0; i &lt; 3; i++) 
		id = id * 26 + (name[i] - 'A');
	id = id * 10 + (name[3] - '0');
	return id;
}
int main() {
	int n, k, no, num;
	char name[5];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d%d&quot;, &amp;no, &amp;num);
		for (int j = 0; j &lt; num; j++) {
			scanf(&quot;%s&quot;, name);
			stu[getid(name)].push_back(no);
		}
	}
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, name);
		printf(&quot;%s &quot;, name);
		printf(&quot;%d&quot;, stu[getid(name)].size());
		sort(stu[getid(name)].begin(), stu[getid(name)].end());
		for (int j = 0; j &lt; stu[getid(name)].size(); j++) {
			printf(&quot; %d&quot;, stu[getid(name)][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1040">A1040</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1041">A1041</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 10010;
struct node {
	int choice;
	int num;
	int rank;
}bets[maxn];
bool cmp(node a, node b) {
	if (a.num != b.num) return a.num &lt; b.num;
	else return a.rank &lt; b.rank;
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; maxn; i++) {
		bets[i].num = maxn;
		bets[i].rank = maxn;
	}
	for (int i = 0; i &lt; n; i++) {
		int choice;
		scanf(&quot;%d&quot;, &amp;choice);
		bets[choice].choice = choice;
		if (bets[choice].num == maxn) {
			bets[choice].num = 1;
		}
		else {
			bets[choice].num++;
		}
		if (bets[choice].rank == maxn) bets[choice].rank = i;
	}
	sort(bets, bets + maxn, cmp);
	if (bets[0].num == 1) printf(&quot;%d&quot;, bets[0].choice);
	else printf(&quot;None&quot;);
	return 0;
}
</code></pre>
<h3 id="a1042">A1042</h3>
<pre><code>#include&lt;cstdio&gt;
const int N = 55;
int main()
{
	char mp[5] = { 'S','H','C','D','J' };
	int start[N], next[N], end[N];
	int times;
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 1; i &lt;= 54; i++) {
		scanf(&quot;%d&quot;, &amp;next[i]);
	}
	for (int i = 1; i &lt;= 54; i++) {
		start[i] = i;
	}
	for (int step = 0; step &lt; times; step++) {
		for (int i = 1; i &lt;= 54; i++) {
			end[next[i]] = start[i];
		}
		for (int i = 1; i &lt;= 54; i++) {
			start[i] = end[i];
		}
	}
	for (int i = 1; i &lt;= 54; i++) {
		if (i != 1) printf(&quot; &quot;);
		start[i]--;
		printf(&quot;%c%d&quot;, mp[start[i] / 13], start[i] % 13+1);
	}
	return 0;
}
</code></pre>
<h3 id="a1043">A1043</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node* lchild;
	node* rchild;
};
void insert(node*&amp; root, int x) {
	if (root == NULL) {
		root = new node;
		root-&gt;data = x;
		root-&gt;lchild = NULL;
		root-&gt;rchild = NULL;
		return;
	}
	if (x &lt; root-&gt;data) insert(root-&gt;lchild, x);
	else insert(root-&gt;rchild, x);
}
void preorder(node* root, vector&lt;int&gt;&amp; vi) {
	if (root == NULL) return;
	vi.push_back(root-&gt;data);
	preorder(root-&gt;lchild,vi);
	preorder(root-&gt;rchild, vi);
}
void preMorder(node* root, vector&lt;int&gt;&amp; vi) {
	if (root == NULL) return;
	vi.push_back(root-&gt;data);
	preMorder(root-&gt;rchild, vi);
	preMorder(root-&gt;lchild, vi);
}
void postorder(node*root,vector&lt;int&gt;&amp; vi) {
	if (root == NULL) return;
	postorder(root-&gt;lchild,vi);
	postorder(root-&gt;rchild,vi);
	vi.push_back(root-&gt;data);
}
void postMorder(node* root, vector&lt;int&gt;&amp; vi) {
	if (root == NULL) return;
	postMorder(root-&gt;rchild,vi);
	postMorder(root-&gt;lchild,vi);
	vi.push_back(root-&gt;data);
}
int main() {
	vector&lt;int&gt;origin, pre, preM, post, postM;
	int n,temp;
	scanf(&quot;%d&quot;, &amp;n);
	node* root = NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;, &amp;temp);
		origin.push_back(temp);
		insert(root, temp);
	}
	preorder(root, pre);
	preMorder(root, preM);
	postorder(root, post);
	postMorder(root, postM);
	if (origin == pre) {
		printf(&quot;YES\n&quot;);
		for (int i = 0; i &lt; post.size(); i++) {
			printf(&quot;%d&quot;, post[i]);
			if (i &lt; post.size() - 1) printf(&quot; &quot;);
		}
	}
	else if (origin == preM) {
		printf(&quot;YES\n&quot;);
		for (int i = 0; i &lt; postM.size(); i++) {
			printf(&quot;%d&quot;, postM[i]);
			if (i &lt; postM.size()-1) printf(&quot; &quot;);
		}
	}
	else  printf(&quot;NO\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a1044">A1044</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int near_m = 100000010;
int diamond[maxn];
int sum[maxn];
int main() {
	int n, m;
	sum[0] = 0;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;diamond[i]);
		sum[i] = sum[i-1]+diamond[i];
	}
	for (int i = 1; i &lt;= n; i++) {
		int j = upper_bound(sum+i, sum+n + 1, sum[i - 1] + m)-sum;
		if (sum[j - 1] - sum[i - 1] == m) {
			near_m = m;
			break; 
		}
		else if (sum[j] - sum[i - 1] &lt; near_m) {
			near_m = sum[j] - sum[i - 1];
		}
	}
	for (int i = 1; i &lt;= n; i++) {
		int j= upper_bound(sum+i, sum+n + 1, sum[i-1]+near_m)-sum;
		if ( sum[j - 1] - sum[i - 1]==near_m) {
			printf(&quot;%d-%d\n&quot;, i, j - 1);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1045">A1045</h3>
<pre><code>方法一:最长不下降子序列LIS
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
		ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
方法二:最长公共子序列
#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;
    for(int i=0;i&lt;L;i++) dp[0][i]=0;
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
<h3 id="a1046">A1046</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int dis[maxn], A[maxn];
int main() {
	int n,times,left,right,sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		sum += A[i];
        dis[i] = sum;
	}
	scanf(&quot;%d&quot;, &amp;times);
	for (int i = 0; i &lt; times; i++) {
		scanf(&quot;%d%d&quot;, &amp;left, &amp;right);
		if (left &gt; right)  swap(left, right);
		int distance = dis[right - 1] - dis[left - 1];
			printf(&quot;%d\n&quot;, min(distance,sum-distance));
	}
	return 0;
}
</code></pre>
<h3 id="a1047">A1047</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
vector&lt;int&gt; course[2510];
char stu[40010][5];
bool cmp(int a, int  b) {  return strcmp(stu[a], stu[b]) &lt; 0; }
int main() {
	int n,k,m;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, stu[i]);
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++) {
			int id;
			scanf(&quot;%d&quot;,&amp;id);
			course[id].push_back(i);
		}	
	}
	for (int i = 1; i &lt;= k; i++) {
		printf(&quot;%d %d\n&quot;, i, course[i].size());
		sort(course[i].begin(), course[i].end(), cmp);
		for (int j = 0; j &lt; course[i].size(); j++) {
			printf(&quot;%s\n&quot;, stu[course[i][j]]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1048">A1048</h3>
<pre><code>1.哈希散列解法
#include&lt;cstdio&gt;
const int maxn = 1010;
int hashtable[maxn] = { 0 };
int main() {
	int n, m;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		int num;
		scanf(&quot;%d&quot;, &amp;num);
		hashtable[num]++;
	}
	for (int i = 1; i &lt; m; i++) {
		if (hashtable[i] &gt; 0 &amp;&amp; hashtable[m - i] &gt; 0) {
			if ((i == m - i &amp;&amp; hashtable[i] &gt; 1) || i != m - i) {
				printf(&quot;%d %d&quot;, i, m - i);
				return 0;
			}
		}
	}
	printf(&quot;No Solution&quot;);
	return 0;
}


2.二分法解法
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num, num + n);
	int j,i;
	for ( i = 0; i &lt; n; i++) {
		 j = lower_bound(num + i, num +n, m - num[i]) - num;
		if ( (num[j] + num[i] == m&amp;&amp;j!=i)||(num[i]==num[i+1]&amp;&amp;num[i]*2==m)) {
			printf(&quot;%d %d&quot;, num[i], num[j]);
			break;
		}
	}
	if (i &gt;= n) printf(&quot;No Solution&quot;);
	return 0;
}

3.two points
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, m;
	int a[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	sort(a, a + n);
	int j=n-1,i=0;
    while(i&lt;j){
        if(a[i]+a[j]==m){
            printf(&quot;%d %d&quot;,a[i],a[j]);
            return 0;
        }
        else if(a[i]+a[j]&gt;m) j--;
        else i++;
    }
	printf(&quot;No Solution&quot;);
	return 0;
}
</code></pre>
<h3 id="a1049">A1049</h3>
<pre><code>#include &lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
int main() {
	int n,ans=0,a=1,index=0;
	cin &gt;&gt; n;
	int left, now, right;
	while (n / a != 0) {
		left = n / (a * 10);
		right = n % a;
		now = n/a%10;
		if (now == 0) ans += left * pow(10, index++);
		else if(now == 1) ans += left * pow(10, index++) + 1+right;
		else ans += (left + 1) * pow(10, index++);
		a *= 10;
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h3 id="a1050">A1050</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	bool hashtable[128] = { false };
	string s1, s2;
	getline(cin, s1);
	getline(cin, s2);
	int len1 = s1.length();
	int len2 = s2.length();
	for (int i = 0; i &lt; len2; i++) {
		hashtable[s2[i]] = true;
	}
	string ans;
	for (int i = 0; i &lt; len1; i++) {
		if (hashtable[s1[i]] == false) {
			ans += s1[i];
		}
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h3 id="a1051-栈">A1051 栈</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn = 1010;
int out[maxn];
stack&lt;int&gt; st;
int main() {
	int m, n, k;
	scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;k);
	while (k--) {
		while (!st.empty()) {
			st.pop();
		}
		bool flag=true;
		for (int i = 1; i &lt;= n; i++) {
			scanf(&quot;%d&quot;, &amp;out[i]);
		}
		int current = 1;
		for (int i = 1; i &lt;= n; i++) {
			st.push(i);
			if (st.size() &gt; m) {
				flag = false;
				break;
			}
			while(!st.empty()&amp;&amp;st.top() == out[current]) {
					st.pop();
					current++;
			}
		}
		if (st.empty()&amp;&amp; flag == true) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1052链表">A1052(链表)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct Node{
	int address,data,next;
	bool flag;
}node[maxn];
bool cmp(Node a,Node b){
	if(a.flag==false||b.flag==false) return a.flag&gt;b.flag;
	else return a.data&lt;b.data;
}
int main(){
	int n,begin;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;begin);
	for(int i=0;i&lt;maxn;i++){
		node[i].flag=false;
	}
	int address1,data1,next1;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d%d%d&quot;,&amp;address1,&amp;data1,&amp;next1);
		node[address1].address=address1;
		node[address1].data=data1;
		node[address1].next=next1;
	}
	int p=begin,count=0;
	while(p!=-1){
		node[p].flag=true;
		count++;
		p=node[p].next;
	}
	sort(node,node+maxn,cmp);
	if(count==0) printf(&quot;0 -1&quot;);
	else{
		printf(&quot;%d %05d\n&quot;,count,node[0].address);
		for(int i=0;i&lt;count-1;i++){
			printf(&quot;%05d %d %05d\n&quot;,node[i].address,node[i].data,node[i+1].address);
		}
		printf(&quot;%05d %d -1&quot;,node[count-1].address,node[count-1].data);
	}
	return 0;	
}
</code></pre>
<h3 id="a1053">A1053</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int n, m, s;
int path[maxn];
struct node {
	int weight;
	vector&lt;int&gt; child;
}Node[maxn];
bool cmp(int a, int b) {
	return Node[a].weight &gt; Node[b].weight;
}
void DFS(int index, int nodenum, int sum) {
	if (sum &gt; s) return;
	if (sum == s) {
		if (Node[index].child.size() != 0) return;
        for (int i = 0; i &lt; nodenum; i++) {
		     printf(&quot;%d&quot;,Node[path[i]].weight);
			 if (i &lt; nodenum - 1) printf(&quot; &quot;);
			 else printf(&quot;\n&quot;);
		}
	}
	for (int i = 0; i &lt; Node[index].child.size(); i++) {
		path[nodenum] = Node[index].child[i];
		DFS(Node[index].child[i], nodenum + 1, sum + Node[Node[index].child[i]].weight);
	}
}
int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;Node[i].weight);
	}
	int father,k, temp;
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;father,&amp;k);
		while (k--) {
			scanf(&quot;%d&quot;, &amp;temp);
			Node[father].child.push_back(temp);
		}
		sort(Node[father].child.begin(), Node[father].child.end(), cmp);
	}
	path[0] = 0;
	DFS(0, 1, Node[0].weight);
	return 0;
}
</code></pre>
<h3 id="a1054">A1054</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
map&lt;int, int&gt; colors;
int main() {
	int m, n,temp;
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; m; j++) {
            int temp;
            scanf(&quot;%d&quot;,&amp;temp);
			if (colors.count(temp) == 0) colors[temp] = 1;
			else colors[temp]++;
		}
	}
	int ans, maxn=0;
	for (auto it = colors.begin(); it != colors.end(); it++) {
		if (it-&gt;second &gt; maxn) {
			ans = it -&gt;first;
			maxn = it-&gt; second;
		}
	}
    printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1055">A1055</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	char name[10];
	int age,money;
}; 
bool cmp(node a,node b){
	if(a.money!=b.money) return a.money&gt;b.money;
	else if(a.age!=b.age) return a.age&lt;b.age;
	else return strcmp(a.name,b.name)&lt;0;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;node&gt; total(n),elect;
	vector&lt;int&gt; mark(210,0);
	for(int i=0;i&lt;n;i++) scanf(&quot;%s%d%d&quot;,total[i].name,&amp;total[i].age,&amp;total[i].money);
	sort(total.begin(),total.end(),cmp);
	for(int i=0;i&lt;n;i++){
		if(mark[total[i].age]&lt;=100){
			mark[total[i].age]++;
			elect.push_back(total[i]);
		}
	}
	int query,minage,maxage;
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;query,&amp;minage,&amp;maxage);
		vector&lt;node&gt; t;
		for(int j=0;j&lt;elect.size();j++){
			if(elect[j].age&lt;=maxage&amp;&amp;elect[j].age&gt;=minage)
				t.push_back(elect[j]);
		}
		printf(&quot;Case #%d:\n&quot;,i+1);
		int needprintf=0;
		for(int k=0;k&lt;query&amp;&amp;k&lt;t.size();k++){
			needprintf++;
		    printf(&quot;%s %d %d\n&quot;,t[k].name,t[k].age,t[k].money);
		}
		if(needprintf==0) printf(&quot;None\n&quot;);
	} 
	return 0;
}
</code></pre>
<h3 id="a1056队列">A1056(队列)</h3>
<pre><code>#include&lt;queue&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 1010;
struct node{
	int rank;
	int weight;
}mouse[maxn];
int main() {
    queue&lt;int&gt; q;
	int np, ng, order;
	scanf(&quot;%d%d&quot;, &amp;np, &amp;ng);
	for (int i = 0; i &lt; np; i++) {
		scanf(&quot;%d&quot;, &amp;mouse[i].weight);
	}
    int t=np;
	while(t--){
		scanf(&quot;%d&quot;, &amp;order);
		q.push(order);
	}
	int temp = np, group;
	while (q.size() != 1) {
		if (temp % ng == 0) group = temp / ng;
		else group = temp / ng + 1;
		for (int i = 0; i &lt; group; i++) {
			int k = q.front();
			for (int j = 0; j &lt; ng; j++) {
				if (i * ng + j &gt;= temp) break;
				int front = q.front();
				if (mouse[front].weight &gt; mouse[k].weight) {
					k = front;
				}
				mouse[front].rank = group + 1;
				q.pop();
			}
			q.push(k);
		}
		temp = group;
	}
	mouse[q.front()].rank = 1;
	for (int i = 0; i &lt; np; i++) {
		printf(&quot;%d&quot;, mouse[i].rank);
		if (i &lt; np - 1) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a105730-分块-树状数组">A1057(30 分块、树状数组)</h3>
<pre><code>1.分块
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int table[100010],block[317];
stack&lt;int&gt; st;
void Peekmedian(int x) {
	int sum = 0, block_id = 0;
	while (sum + block[block_id] &lt; x) {
		sum += block[block_id++];
	}
	int num = block_id * 316;
	while (sum + table[num] &lt; x) sum+=table[num++];
	printf(&quot;%d\n&quot;, num);
}
void Push(int x) {
	st.push(x);
	table[x]++;
	block[x / 316]++;
}
void Pop() {
	int top = st.top();
	st.pop();
	table[top]--;
	block[top / 316]--;
	printf(&quot;%d\n&quot;, top);
}
int main() {
	int n, temp;
	char cmd[15];
	scanf(&quot;%d&quot;, &amp;n);
	memset(table, 0, sizeof(table));
	memset(block, 0, sizeof(block));
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, cmd);
		if (strcmp(cmd, &quot;Pop&quot;)==0) {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else Pop();
		}
		else if (strcmp(cmd, &quot;Push&quot;)==0) {
			scanf(&quot;%d&quot;, &amp;temp);
			Push(temp);
		}
		else {
			if (st.empty()) printf(&quot;Invalid\n&quot;);
			else {
				int k = st.size();
				if (k % 2 == 0) k = k / 2;
				else k = k / 2 + 1;
				Peekmedian(k);
			}
		}
	}
	return 0;
}
2.树状数组

</code></pre>
<h3 id="a1058">A1058</h3>
<pre><code>#include&lt;cstdio&gt;
int main() {
	int sum[3], m1[3], m2[3];
	int  temp_sick, temp_knut;
	scanf(&quot;%d.%d.%d&quot;, &amp;m1[0], &amp;m1[1], &amp;m1[2]);
	scanf(&quot;%d.%d.%d&quot;, &amp;m2[0], &amp;m2[1], &amp;m2[2]);
	sum[2] = (m1[2] + m2[2]) % 29;
	temp_knut = (m1[2] + m2[2])/ 29;
	sum[1] = (m1[1] + m2[1] + temp_knut)%17;
	temp_sick = (m1[1] + m2[1] + temp_knut) / 17;
	sum[0] = m1[0] + m2[0] + temp_sick;
	printf(&quot;%d.%d.%d&quot;, sum[0], sum[1], sum[2]);
	return 0;
}
</code></pre>
<h3 id="a1059">A1059</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
const int maxn = 100010;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
struct factor {
	int x, exp;
}fac[10];
int main() {
	find_prime();
	int n,num=0;
	scanf(&quot;%d&quot;, &amp;n);
	int sqr = (int)sqrt(1.0 * n);
	if (n == 1) printf(&quot;1=1&quot;);
	else {
		printf(&quot;%d=&quot;, n);
		for (int i = 0; i &lt; pnum &amp;&amp; prime[i] &lt;= sqr; i++) {
			if (n % prime[i] == 0) {
				fac[num].x = prime[i];
				fac[num].exp = 0;
				while (n % prime[i] == 0) {
					fac[num].exp++;
					n /= prime[i];
				}
				num++;
			}
			if (n == 1) break;
		}
		if (n != 1) {
			fac[num].x = n;
			fac[num++].exp = 1;
		}
		for (int i = 0; i &lt; num; i++) {
			if (i &gt; 0) printf(&quot;*&quot;);
			printf(&quot;%d&quot;, fac[i].x);
			if (fac[i].exp &gt; 1) printf(&quot;^%d&quot;, fac[i].exp);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1060">A1060</h3>
<pre><code>#include&lt;iostream&gt; 
#include&lt;string&gt;
using namespace std;
int n;
string deal(string s, int&amp; e) {
	int k = 0;
	
	while (s.length() &gt; 0 &amp;&amp; s[0] == '0') {
		s.erase(s.begin());
	}
	if (s[0] == '.') {
		s.erase(s.begin());
		while (s.length() &gt; 0 &amp;&amp; s[0] == '0') {
			s.erase(s.begin());
			e--;
		}
	}
	else {
		while (s.length() &gt; k &amp;&amp; s[k] != '.') {
			e++;
			k++;
		}
		if(k&lt;s.length()) s.erase(s.begin() + k);
	}
	if (s.length() == 0) e = 0;
    string ans;
    k=0;
    int num=0;
    while(num&lt;n){
        if(k&lt;s.length()) ans+=s[k++];
        else ans+='0';
        num++;
    }
	return ans;
}
int main() {
	string s1, s2, ans1, ans2;
	int e1=0, e2=0;
	cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;
	ans1 = deal(s1, e1);
	ans2 = deal(s2, e2);
	if (ans1 == ans2 &amp;&amp; e1 == e2)
		cout &lt;&lt; &quot;YES &quot; &lt;&lt; &quot;0.&quot; &lt;&lt; ans1 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1;
	else
		cout &lt;&lt; &quot;NO &quot; &lt;&lt; &quot;0.&quot; &lt;&lt; ans1 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; &quot; &lt;&lt; &quot;0.&quot; &lt;&lt; ans2 &lt;&lt; &quot;*10^&quot; &lt;&lt; e2;
	return 0;
}
</code></pre>
<h3 id="a1061">A1061</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
int main() {
	char s1[70], s2[70], s3[70], s4[70];
	string days[7] = { &quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot; };
	scanf(&quot;%s%s%s%s&quot;, s1, s2, s3, s4);
	int len1 = strlen(s1);
	int len2 = strlen(s2);
	int len3 = strlen(s3);
	int len4 = strlen(s4);
	int i;
	for (i = 0; i &lt; len1 &amp;&amp; i &lt; len2; i++) {
		if (s1[i] == s2[i] &amp;&amp; s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G') {
			printf(&quot;%s &quot;, days[s1[i] - 'A'].c_str());
			break;
		}
	}
	for (i++; i &lt; len2 &amp;&amp; i &lt; len1; i++) {
		if (s1[i] == s2[i]) {
			if (s1[i] &gt;= '0' &amp;&amp; s1[i] &lt;= '9') {
				printf(&quot;%02d:&quot;, s1[i] - '0');
				break;
			}
			else if (s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') {
				printf(&quot;%02d:&quot;, s1[i] - 'A' + 10);
				break;
			}
		}
	}
	for (int j = 0; j &lt; len3 &amp;&amp; j &lt; len4; j++) {
		if (s3[j] == s4[j]) {
			if ((s3[j] &gt;= 'a' &amp;&amp; s3[j] &lt;= 'z') || (s3[j] &gt;= 'A' &amp;&amp; s3[j] &lt;= 'Z')) {
				printf(&quot;%02d&quot;, j);
				break;
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1062">A1062</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
struct test {
	char id[20];
	int de, cai, sum;
	int flag;
}student[100010];
bool cmp(test a, test b) {
	if (a.flag != b.flag) return a.flag &lt; b.flag;
	else if (a.sum != b.sum) return a.sum &gt; b.sum;
	else if (a.de != b.de) return a.de &gt; b.de;
	else return strcmp(a.id, b.id) &lt; 0;
}
int main() {
	int total, low, high;
	scanf(&quot;%d%d%d&quot;, &amp;total, &amp;low, &amp;high);
	int pass = total;
	for (int i = 0; i &lt; total; i++) {
		scanf(&quot;%s%d%d&quot;, student[i].id, &amp;student[i].de, &amp;student[i].cai);
		student[i].sum = student[i].de + student[i].cai;
		if (student[i].de &lt; low || student[i].cai &lt; low) {
			student[i].flag = 5;
			pass--;
		}
		else if (student[i].cai &gt;= high &amp;&amp; student[i].de &gt;= high) student[i].flag = 1;
		else if (student[i].cai &gt;= low &amp;&amp; student[i].cai &lt; high &amp;&amp; student[i].de &gt;= high) student[i].flag = 2;
		else if (student[i].cai &gt;= low &amp;&amp; student[i].cai &lt;= student[i].de &amp;&amp; student[i].de&lt;high) student[i].flag = 3;
		else  student[i].flag = 4;
	}
	sort(student, student + total, cmp);
	printf(&quot;%d\n&quot;, pass);
	for (int i = 0; i &lt; pass; i++) {
		printf(&quot;%s %d %d\n&quot;, student[i].id, student[i].de, student[i].cai);
	}
	return 0;
}
</code></pre>
<h3 id="a1063">A1063</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int maxn = 51;
set&lt;int&gt; v[maxn];
int main() {
	int n,m,temp,k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;m);
		for (int j = 0; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[i].insert(temp);
		}
	}
	int a, b;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		int nc=0, nt=v[b-1].size();
		for (auto it = v[a - 1].begin(); it != v[a - 1].end(); it++) {
			if (v[b - 1].find(*it) != v[b - 1].end())  nc++;
			else nt++;
		}
		printf(&quot;%.1f%%\n&quot;, (nc * 100.0) / nt);
	}
}
</code></pre>
<h3 id="a1064">A1064</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 1010;
int CBT[maxn],index=0,number[maxn],n;
void inorder(int root) {
	if (root &gt; n) return;
	inorder(root * 2);
	CBT[root] = number[index++];
	inorder(root * 2 + 1);
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;number[i]);
	}
	sort(number, number + n);
	inorder(1);
	for (int i = 1; i &lt;= n; i++) {
		printf(&quot;%d&quot;, CBT[i]);
		if (i &lt; n) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1065">A1065</h3>
<pre><code>#include&lt;cstdio&gt;
int main() {
	long long a, b, c;
	int n,times=1;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
		bool flag;
		long long sum = a + b;
		if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0)
			flag = true;
		else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0)
			flag = false;
		else if (sum &gt; c)
			flag = true;
		else flag = false;
		if (flag == true)
			printf(&quot;Case #%d:true&quot;, times++);
		if (flag == false)
			printf(&quot;Case #%d:false&quot;, times++);
	}
	return 0;
}
</code></pre>
<h3 id="a1066">A1066</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int v, height;
	node* lchild, *rchild;
};
node* newNode(int v) {
	node* Node = new node;
	Node-&gt;v = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
int getheight(node* root) {
	if (root == NULL) return 0;
	return root-&gt;height;
}
void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
int getbalancefactor(node* root) {
	return getheight(root-&gt;lchild) - getheight(root-&gt;rchild);
}
void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newNode(v);
		return ;
	}
	if (v &lt; root-&gt;v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalancefactor(root) == 2) {
			if (getbalancefactor(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalancefactor(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild,v);
		updateheight(root);
		if (getbalancefactor(root) == -2) {
			if (getbalancefactor(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalancefactor(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
int main() {
	int n, v;
	scanf(&quot;%d&quot;, &amp;n);
	node* root =NULL;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;v);
		insert(root, v);
	}
	printf(&quot;%d&quot;, root-&gt;v);
	return 0;
}
</code></pre>
<h3 id="a1067">A1067</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n,p[maxn],ans=0;
	scanf(&quot;%d&quot;, &amp;n);
	int left = n - 1;
	for (int i = 0; i &lt; n; i++) {
		int num;
		scanf(&quot;%d&quot;, &amp;num);
		p[num] = i;
		if(num != 0 &amp;&amp; p[num] == num) {
			left--;
		}
	}
	int k = 1;
	while (left &gt; 0) {
		if (p[0] == 0) {
			while (k&lt;n) {
				if (p[k] != k) {
					swap(p[0], p[k]);
					ans++;
					break;
				}
				k++;
			}
		}
		while(p[0]!=0) {
			swap(p[p[0]], p[0]);
			ans++;
			left--;
		}
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1068">A1068</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1069">A1069</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
bool cmp(int a, int b) {
	return a &gt; b;
}
int a[4];
int to_number(int a[]) {
	int res = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3] * 1;
	return res;
}
void to_arry(int num) {
	for (int j = 0; j &lt; 4; j++) {
		a[j] = num % 10;
		num = num / 10;
	}
}
int main() {
	int big, small, ans;
	scanf(&quot;%d&quot;, &amp;ans);
	do {
		to_arry(ans);
		sort(a, a + 4);
		small = to_number(a);
		sort(a, a + 4, cmp);
		big = to_number(a);
		ans = big - small;
		printf(&quot;%04d - %04d = %04d\n&quot;, big, small, ans);
		
	} while (ans &gt; 0 &amp;&amp; ans != 6174);
	return 0;
}
</code></pre>
<h3 id="a1070">A1070</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	double price;
	double stock;
}mooncake[1001];
bool cmp(node a, node b) {
	return a.price/a.stock &gt; b.price/b.stock;
}
int main() {
	int n, d;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;d);
	for (int i = 0; i &lt; n; i++) {
		double stock;
		scanf(&quot;%lf&quot;, &amp;stock);
		mooncake[i].stock = stock;
	}
	for (int i = 0; i &lt; n; i++) {
		double price;
		scanf(&quot;%lf&quot;, &amp;price);
		mooncake[i].price = price;
	}
	sort(mooncake, mooncake + n, cmp);
	double nowneed = (double)d;
	double income = 0.0;
	for (int i = 0; i &lt; n; i++) {
		if (mooncake[i].stock &gt;= nowneed) {
			income =income+(mooncake[i].price/mooncake[i].stock)*nowneed;
			nowneed = 0;
			break;
		}
		else {
			nowneed -= mooncake[i].stock;
			income += mooncake[i].price;
		}
	}
	printf(&quot;%.2f&quot;, income);
	return 0;
}
</code></pre>
<h3 id="a1071">A1071</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
bool check(char a) {
	if (a &gt;= '0' &amp;&amp; a &lt;= '9') return true;
	if (a &gt;= 'a' &amp;&amp; a &lt;= 'z') return true;
	if (a &gt;= 'A' &amp;&amp; a &lt;= 'Z') return true;
	return false;
}
map&lt;string, int&gt; text;
int main() {
	string str;
	getline(cin, str);
	int len = str.size();
	int i = 0;
	string ans,result;
	while (i &lt; len) {
		if (check(str[i])) {
			if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') {
				str[i] += 32;
			}
			ans += str[i];
			if (check(str[i + 1]) == false || i + 1 == len) {
				if (text.count(ans) == 0) text[ans] = 1;
				else text[ans]++;
				ans.clear();
			}
		}
		i++;
	}
	int maxtimes = 0;
	for (auto it = text.begin(); it != text.end(); it++) {
		if (it-&gt;second &gt; maxtimes) {
			result = it-&gt;first;
			maxtimes = it-&gt;second;
		}
	}
	cout &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; maxtimes;
	return 0;
}
</code></pre>
<h3 id="a1072">A1072</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1016;
const int INF=1000000000;
bool vis[maxn]={false};
int n,m,k,ds,G[maxn][maxn],d[maxn];
void dijkst(int s){
	fill(d,d+maxn,INF);
	fill(vis,vis+maxn,false);
	d[s]=0;
    for(int i=1;i&lt;=n+m;i++){
    	int u=-1,MIN=INF;
    	for(int j=1;j&lt;=n+m;j++){
    		if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
    			u=j;
			    MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=1;v&lt;=n+m;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
				}
			}
		}
	}	
}
int getid(char str[]){
	int i=0,len=strlen(str),id=0;
	while(i&lt;len){
		if(str[i]!='G'){
			id=id*10+(str[i]-'0');
		}
		i++;
	}
	if(str[0]=='G') return id+n;
	else return id;
}
int main(){
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;ds);
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=0;i&lt;k;i++){
		char str1[6],str2[6];
		int distance,id1,id2;;
		scanf(&quot;%s %s %d&quot;,str1,str2,&amp;distance);
		id1=getid(str1);
		id2=getid(str2);
		G[id1][id2]=distance;
		G[id2][id1]=G[id1][id2];
	}
	double ansavg=INF,ansdis=-1;
	vector&lt;int&gt; ansid;
	for(int i=n+1;i&lt;=n+m;i++){
		dijkst(i);
		double mindis=INF,avgdis=0.0;
		int j;
		for(j=1;j&lt;=n;j++){
			if(d[j]&gt;ds) break;
			if(d[j]&lt;mindis){
				mindis=d[j];
			}
			avgdis+=d[j]*1.0/n;
		}
		if(j&lt;n+1) continue;
		if(mindis&gt;ansdis){
			ansdis=mindis;
			ansavg=avgdis;
			ansid.clear();
			ansid.push_back(i);
		}else if(mindis==ansdis){
			if(ansavg&gt;avgdis){
				ansavg=avgdis;
				ansid.clear();
			    ansid.push_back(i);
			} 
			else if(ansavg==avgdis) ansid.push_back(i);
		}
	}
	if(ansid.size()==0) printf(&quot;No Solution&quot;);
	else{
		printf(&quot;G%d\n&quot;,ansid[0]-n);
		printf(&quot;%.1f %.1f&quot;,ansdis,ansavg);
	}
	return 0;
}
</code></pre>
<h3 id="a1073-科学计数法">A1073 科学计数法</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;cstring&gt;
int main(){
	char str[10010];
	scanf(&quot;%s&quot;,str);
	int len=strlen(str);
	int pos=0;
	while(str[pos]!='E') pos++;
	if(str[0]=='-') printf(&quot;-&quot;);
	int exp=0;
	for(int i=pos+2;i&lt;len;i++){
		exp=exp*10+str[i]-'0';
	}
	if(exp==0){
		for(int i=1;i&lt;pos;i++){
			printf(&quot;%c&quot;,str[i]);
		}
	}
	if(str[pos+1]=='-'){
		printf(&quot;0.&quot;);
		for(int t=0;t&lt;exp-1;t++) printf(&quot;0&quot;);
		for(int j=1;j&lt;pos;j++){
			if(str[j]=='.') continue;
			printf(&quot;%c&quot;,str[j]);
		}
	}
	else{
		for(int i=1;i&lt;pos;i++){
			if(str[i]=='.') continue;
			printf(&quot;%c&quot;,str[i]);
			if(i==exp+2&amp;&amp;(pos-3)!=exp){
				printf(&quot;.&quot;);
			}
		}
		for(int k=0;k&lt;exp-(pos-3);k++) printf(&quot;0&quot;);
	} 
	return 0;
}
</code></pre>
<h3 id="a1074链表">A1074(链表)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
struct Node {
	int address, data, next;
	int order;
}node[maxn];
bool cmp(Node a, Node b) {
	return a.order &lt; b.order;
}
int main() {
	for (int i = 0; i &lt; maxn; i++) {
		node[i].order = maxn;
	}
	int begin, n, k,count=0;
	scanf(&quot;%d%d%d&quot;, &amp;begin, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		int address;
		scanf(&quot;%d&quot;, &amp;address);
		scanf(&quot;%d%d&quot;, &amp;node[address].data, &amp;node[address].next);
		node[address].address = address;
	}
	int p = begin;
	while (p != -1) {
		node[p].order = count++;
		p = node[p].next;
	}
	sort(node, node + maxn, cmp);
	for (int i = 0; i &lt; count / k; i++) {
		for (int j = (i + 1) * k - 1; j &gt; i * k; j--) {
			printf(&quot;%05d %d %05d\n&quot;, node[j].address, node[j].data, node[j - 1].address);
		}
		printf(&quot;%05d %d &quot;, node[i * k].address, node[i * k].data);
		if (i &lt; count / k - 1) {
			node[i * k].next = node[(i + 2) * k - 1].address;
			printf(&quot;%05d\n&quot;, node[i * k].next);
		}
		else {
			if (count % k == 0) {
				printf(&quot;-1\n&quot;);
			}
			else {
				node[i * k].next = node[(i + 1) * k ].address;
				printf(&quot;%05d\n&quot;, node[i * k].next);
				if(count==(i+1)*k+1) printf(&quot;%05d %d -1\n&quot;, node[count - 1].address, node[count - 1].data);
				else {
					for (int x = (i + 1) * k; x &lt; count-1; x++) {
						printf(&quot;%05d %d %05d\n&quot;, node[x].address, node[x].data, node[x + 1].address);
					}
					printf(&quot;%05d %d -1\n&quot;, node[count - 1].address, node[count - 1].data);
				}
				
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1075">A1075</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 10010;
struct node {
	int rank;
	int id;
	int score[6];
	int total;
	int perfect;
	bool canprint;
}user[maxn];
bool cmp(node a, node b) {
	if (a.canprint == false || b.canprint == false) return a.canprint &gt; b.canprint;
	else if (a.total != b.total) return a.total &gt; b.total;
	else if (a.perfect != b.perfect) return a.perfect &gt; b.perfect;
	else return a.id &lt; b.id;
}
int main() {
	int n, k, m, question[6] = { 0 };
	scanf_s(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);
	for (int i = 1; i &lt;= k; i++) scanf_s(&quot;%d&quot;, &amp;question[i]);
	for (int i = 0; i &lt; maxn; i++) {
		memset(user[i].score, -1, sizeof(user[i].score));
		user[i].total = 0;
		user[i].perfect = 0;
		user[i].canprint = false;
	}
	for (int i = 0; i &lt; m; i++) {
		int id,problem_id,score;
		scanf_s(&quot;%d %d %d&quot;, &amp;id,&amp;problem_id,&amp;score);
		user[id].id = id;
		if (score == -1&amp;&amp;user[id].score[problem_id]==-1) user[id].score[problem_id] = 0;//第一次未能编译通过
		if (score != -1) {
			user[id].canprint = true;
			if (score == question[problem_id]&amp;&amp;user[id].score[problem_id]&lt;question[problem_id]) user[id].perfect++;
		}
		if (score &gt;= user[id].score[problem_id]) user[id].score[problem_id] = score;//第一次满分
	}
	for (int i = 0; i &lt; maxn; i++) {
		for (int j = 1; j &lt;= k; j++) {
			if (user[i].score[j] != -1) {
				user[i].total += user[i].score[j];
			}
		}
	}
	sort(user, user + maxn, cmp);
	user[0].rank = 1;
	for (int j = 1; j &lt; n; j++) {
		if (user[j].total == user[j - 1].total) {
			user[j].rank = user[j - 1].rank;
		}
		else user[j].rank = j + 1;
	}
	for (int i = 0; i &lt; n; i++) {
		if (user[i].canprint == true) {
			printf(&quot;%d %05d %d&quot;, user[i].rank, user[i].id, user[i].total);
			for (int j = 1; j &lt;= k; j++) {
				if (user[i].score[j] == -1) printf(&quot; -&quot;);
				else {
					printf(&quot; %d&quot;, user[i].score[j]);
				}
			}
			printf(&quot;\n&quot;);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1076">A1076</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1010;
bool inq[maxn]={false};
struct node{
	int id;
	int layer;
};
vector&lt;node&gt; adj[maxn];
int BFS(int s,int L){
	int numforward=0;
	queue&lt;node&gt; q;
	node start;
	start.id=s;
	start.layer=0;
	q.push(start);
	inq[start.id]=true;
	while(!q.empty()){
		node now;
		now.id=q.front().id;
		now.layer=q.front().layer;
		q.pop();
		for(int i=0;i&lt;adj[now.id].size();i++){
			node next=adj[now.id][i];
			next.layer=now.layer+1;
			if(inq[next.id]==false&amp;&amp;next.layer&lt;=L){
				q.push(next);
				inq[next.id]=true;
				numforward++;
			}
		}
	}
	return numforward;
}
int main(){
	int n,L,followid,m,k,userid,numforward=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;L);
	for(int i=1;i&lt;=n;i++){
		node user;
		user.id=i;
		scanf(&quot;%d&quot;,&amp;m);
		while(m--){
			scanf(&quot;%d&quot;,&amp;followid);
			adj[followid].push_back(user);
		}
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;userid);
		fill(inq,inq+maxn,false);
		numforward=BFS(userid,L);
		printf(&quot;%d\n&quot;,numforward);
	}
	return 0;
}
</code></pre>
<h3 id="a1078">A1078</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
bool isprime(int n) {
	if (n &lt;= 1) return false;
	int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}
bool hashtable[100010] = { 0 };
int main() {
	int tsize, n, a;
	scanf(&quot;%d%d&quot;, &amp;tsize, &amp;n);
    while(!isprime(tsize)){
        tsize++;
    }
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;a);
		int m = a % tsize;
		if (hashtable[m] == false) {
			hashtable[m] = true;
			if (i == 0) printf(&quot;%d&quot;, m);
			else printf(&quot; %d&quot;, m);
		}
		else {
            int step;
			for (step = 1; step &lt; tsize; step++) {
                m=(a+step*step)%tsize;
				if (hashtable[m] == false) {
					hashtable[m] =true;
					printf(&quot; %d&quot;,m);
					break;
				}
			}
			if (step == tsize) {
				printf(&quot; -&quot;);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1079">A1079</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=100010;
struct node{
	int data;
	vector&lt;int&gt;child;
}Node[maxn];
double p,r,ans=0;
int n;
void DFS(int index,int depth){
	if(Node[index].child.size()==0){
		ans+=Node[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;Node[index].child.size();i++){
		DFS(Node[index].child[i],depth+1);
	}
}
int main(){
	int num;
	scanf(&quot;%d%lf%lf&quot;,&amp;n,&amp;p,&amp;r);
	for(int i=0;i&lt;n;i++){
		int temp;
		scanf(&quot;%d&quot;,&amp;num);
		if(num==0){
			scanf(&quot;%d&quot;,&amp;temp);
			Node[i].data=temp;
		}else{
			for(int j=0;j&lt;num;j++){
				scanf(&quot;%d&quot;,&amp;temp);
				Node[i].child.push_back(temp);
			}
		}	
	}
	DFS(0,0);
	printf(&quot;%.1f&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="a1080">A1080</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn = 40010;
struct node {
	int rank;
	int GE, GI,fgrade;
	int id;
	int choice[6];
}app[maxn];
struct node1 {
	int num;
	int quota;
	int id[maxn];
	int lastadmit;
}sch[110];
bool cmpapp(node a, node b) {
	if (a.fgrade != b.fgrade) return a.fgrade &gt; b.fgrade;
	else return a.GE &gt; b.GE;
}
bool cmpstu(int a,int b) {
	return app[a].id &lt; app[b].id;
}
int main() {
	int n, m, k;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;sch[i].quota);
		sch[i].num = 0;
		sch[i].lastadmit = -1;
	}
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;app[i].GE, &amp;app[i].GI);
		app[i].id = i;
		for (int j = 0; j &lt; k; j++) {
			scanf(&quot;%d&quot;, &amp;app[i].choice[j]);
		}
		app[i].fgrade = app[i].GE + app[i].GI;
	}
	sort(app, app + n, cmpapp);
	for (int i = 0; i &lt; n; i++) {
		if (i &gt; 0 &amp;&amp; (app[i].fgrade == app[i - 1].fgrade) &amp;&amp; (app[i].GE == app[i - 1].GE)) {
			app[i].rank = app[i - 1].rank;
		}
		else {
			app[i].rank = i;
		}
	}
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; k; j++) {
			int choice = app[i].choice[j];
			int num = sch[choice].num;
			int last = sch[choice].lastadmit;
			if (sch[choice].quota &gt; num || (last != -1 &amp;&amp; app[i].rank == app[last].rank)) {
				sch[choice].id[num] = i;
				sch[choice].num++;
				sch[choice].lastadmit = i;
				break;
			}
		}
	}
	for (int i = 0; i &lt; m; i++) {
		if (sch[i].num &gt; 0) {
			sort(sch[i].id, sch[i].id + sch[i].num, cmpstu);
			for (int j = 0; j &lt; sch[i].num; j++) {
				printf(&quot;%d&quot;, app[sch[i].id[j]].id);
				if (j &lt; sch[i].num - 1) {
					printf(&quot; &quot;);
				}
			}
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1081">A1081</h3>
<pre><code>#include&lt;cstdio&gt;
long long gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	long long a2 = 0, b2 = 1,gcdvalue;
	for (int i = 0; i &lt; n; i++) {
		long long a, b;
		scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);
		gcdvalue = gcd(a, b);
		a /= gcdvalue;
		b /= gcdvalue;
		a2 = a * b2 + b * a2;
		b2 = b * b2;
		gcdvalue = gcd(a2, b2);
		a2 /= gcdvalue;
		b2 /= gcdvalue;
	}
	long long integer = a2 / b2;
	a2 = a2 - integer * b2;
	if (integer != 0) {
		printf(&quot;%lld&quot;, integer);
		if (a2 &gt; 0) printf(&quot; %lld/%lld&quot;,a2,b2);
		else if (a2 &lt; 0) printf(&quot; %lld/%lld&quot;, -a2, b2);
	}
	if (integer == 0 &amp;&amp; a2 != 0) printf(&quot;%lld/%lld&quot;, a2, b2);
	if (integer == 0 &amp;&amp; a2 == 0) printf(&quot;0&quot;);
	return 0;
}
</code></pre>
<h3 id="a1082">A1082</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
string num[10] = { &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; };
string wei[5] = { &quot;Shi&quot;,&quot;Bai&quot;,&quot;Qian&quot;,&quot;Wan&quot;,&quot;Yi&quot; };
int main() {
	string str;
	getline(cin, str);
	int len = str.length();
	int left = 0, right = len - 1;
	if (str[0] == '-') {
		cout &lt;&lt; &quot;Fu&quot;;
		left++;
	}
	while (left + 4 &lt;= right) {
		right -= 4;
	}
	while (left &lt; len) {
		bool flag = false;
		bool hasprint = false;
		while (left &lt;= right) {
			if (str[left] == '0' &amp;&amp; left &gt; 0) {
				flag = true;
			}
			else {
				if (flag == true) {
					cout &lt;&lt; &quot; ling&quot;;
					flag = false;
				}
				if (left&gt;=1) cout &lt;&lt; &quot; &quot;;
				cout &lt;&lt; num[str[left] - '0'];
				hasprint = true;
				if(left!=right) cout&lt;&lt;&quot; &quot;&lt;&lt; wei[right - left - 1];
			}
			left++;
		}
		if (hasprint == true &amp;&amp; left &lt;len ) {
			cout &lt;&lt; &quot; &quot; &lt;&lt; wei[(len - left) / 4 + 2];
		}
		right += 4;
	}
	return 0;
}
</code></pre>
<h3 id="a1083">A1083</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 100010;
struct node {
	char name[12];
	char id[12];
	int score;
}stu[maxn];
bool cmp(node a, node b) {
	return a.score &gt; b.score;
}
int main() {
	int n,grade1,grade2;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s%s%d&quot;, stu[i].name, stu[i].id, &amp;stu[i].score);
	}
	scanf(&quot;%d%d&quot;, &amp;grade1, &amp;grade2);
	sort(stu, stu + n, cmp);
	bool canprint = false;
	for (int i = 0; i &lt; n; i++) {
		if (stu[i].score &gt;= grade1 &amp;&amp; stu[i].score &lt;= grade2) {
			canprint = true;
			printf(&quot;%s %s\n&quot;, stu[i].name, stu[i].id);
		}
	}
	if (canprint == false) printf(&quot;NONE&quot;);
	return 0;
}
</code></pre>
<h3 id="a1084">A1084</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
bool hashtable[128] = { false };
int main() {
	string str1,str2;
	getline(cin, str1);
	getline(cin, str2);
	int len1 = str1.length();
	int len2 = str2.length();
	for (int i = 0; i &lt; len1; i++) {
		int j;
		if (str1[i] &gt;= 'a' &amp;&amp; str1[i] &lt;= 'z') str1[i] -= 32;
		for (j = 0; j &lt; len2; j++) {
			if ((str1[i] &gt;= '0' &amp;&amp; str1[i] &lt;= '9') || str1[i] == '_') {
				if (str2[j] == str1[i]){
					break;
				}
			}
			else {
				if (str2[j] &gt;= 'a' &amp;&amp; str2[j] &lt;= 'z') str2[j] -= 32;
				if (str1[i] == str2[j]) break;
			}
		}
		if (j == len2 &amp;&amp; hashtable[str1[i]] == false) {
			hashtable[str1[i]] = true;
			printf(&quot;%c&quot;, str1[i]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1085">A1085</h3>
<pre><code>二分法
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, p,num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num,num + n);
	int ans = 0;
	for (int i = 0; i &lt; n; i++) {
        long long k=(long long)p*num[i];
		int* right=upper_bound(num+i+1, num+n, k);
        int j=right-num;
		ans = max(ans, j-i);
	}
	printf(&quot;%d&quot;, ans);
	return 0; 
}

two points
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 100010;
int main() {
	int n, p,num[maxn];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;p);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;num[i]);
	}
	sort(num,num + n);
	int count=0,i=0,j=0;
    while(i&lt;n&amp;&amp;j&lt;n){
        while(j&lt;n&amp;&amp;num[j]&lt;=(long long)num[i]*p){
            count=max(count,j-i+1);
            j++;
        }
        i++;
    }
    printf(&quot;%d&quot;,count);
    return 0;
}
</code></pre>
<h3 id="a1086">A1086</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 50;
struct node {
	int data;
	node* lchild;
	node* rchild;
};
int  pre[maxn], in1[maxn];
int n;
node* create(int preL, int preR, int inL, int inR) {
	if (preL &gt; preR) return NULL;
	node* root = new node;
	root-&gt;data = pre[preL];
	int k;
	for (k = inL; k &lt; inR; k++) {
		if (in1[k] == pre[preL]) {
			break;
		}
	}
	int numleft = k - inL;
	root-&gt;lchild = create(preL + 1, preL + numleft, inL, k - 1);
	root-&gt;rchild = create(preL + numleft + 1, preR, k + 1, inR);
	return root;
}
int num=0;
void postorder(node* root) {
	if (root == NULL) return;
	postorder(root-&gt;lchild);
	postorder(root-&gt;rchild);
	printf(&quot;%d&quot;, root-&gt;data);
	num++;
	if (num &lt; n) printf(&quot; &quot;);
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	char str[5];
	stack&lt;int&gt; st;
	int preindex = 0, inindex = 0, x;
	for (int i = 0; i &lt;2*n; i++) {
		scanf(&quot;%s&quot;, str);
		if (strcmp(str,&quot;Push&quot;)==0) {
			scanf(&quot;%d&quot;, &amp;x);
			pre[preindex++] = x;
			st.push(x);
		}
		else {
			in1[inindex++] = st.top();
			st.pop();
		}
	}
	node* root = create(0, n - 1, 0, n - 1);
	postorder(root);
	return 0;
}
</code></pre>
<h3 id="a1087">A1087</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
const int maxn=210;
const int INF=1000000000;
int pre[maxn],num[maxn],d[maxn],w[maxn],weight[maxn],pt[maxn],G[maxn][maxn];
int n,k;
bool vis[maxn];
map&lt;int,string&gt; inttostring;
map&lt;string,int&gt; stringtoint;
void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(w,w+maxn,0);
	fill(pt,pt+maxn,0);
	fill(num,num+maxn,0);
    for(int i=0;i&lt;n;i++) pre[i]=i;
	d[s]=0;
	w[s]=weight[s];
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];	
					num[v]=num[u];
					pt[v]=pt[u]+1;
					pre[v]=u;
				}else if(d[v]==d[u]+G[u][v]){
					num[v]+=num[u];
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
						pt[v]=pt[u]+1;
						pre[v]=u;
					}else if(w[v]==weight[v]+w[u]){
						double avgfun1=w[v]*1.0/pt[v];
						double avgfun2=(weight[v]+w[u])*1.0/(pt[u]+1);
						if(avgfun2&gt;avgfun1){
							pt[v]=pt[u]+1;
							pre[v]=u;
						}
					}
				}
			}
		}
	}
}
void printpath(int v){
	if(v==0){
		cout&lt;&lt;inttostring[v];
		return;
	}
	printpath(pre[v]);
	cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;inttostring[v];
}
int main(){
	string begincity,tempcity,c1,c2;
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;begincity;
	stringtoint[begincity]=0;
	inttostring[0]=begincity;
	fill(G[0],G[0]+maxn*maxn,INF);
	for(int i=1;i&lt;=n-1;i++){
		cin&gt;&gt;tempcity&gt;&gt;weight[i];
		stringtoint[tempcity]=i;
		inttostring[i]=tempcity;
	}
	for(int i=0;i&lt;k;i++){
		cin&gt;&gt;c1&gt;&gt;c2;
		int id1=stringtoint[c1];
		int id2=stringtoint[c2];
		cin&gt;&gt;G[id1][id2];
		G[id2][id1]=G[id1][id2];
	}
	dijkst(0);
	int end=stringtoint[&quot;ROM&quot;];
	printf(&quot;%d %d %d %d\n&quot;,num[end],d[end],w[end],w[end]/pt[end]);
    printpath(end);
    return 0;
}
</code></pre>
<h3 id="a1088">A1088</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
ll gcd(ll a, ll b) {
	return b == 0 ? a : gcd(b, a % b);
}
struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction subtract(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down - f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction multi(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
fraction divide(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down;
	result.down = f1.down * f2.up;
	return reduction(result);
}
void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
int main() {
	scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down);
	showresult(a);
	printf(&quot; + &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(add(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; - &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(subtract(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; * &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	showresult(multi(a, b));
	printf(&quot;\n&quot;);
	showresult(a);
	printf(&quot; / &quot;);
	showresult(b);
	printf(&quot; = &quot;);
	if (b.up == 0) printf(&quot;Inf&quot;);
	else showresult(divide(a, b));
	return 0;
}
</code></pre>
<h3 id="a1089-two-points">A1089  TWO POINTS</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
	int a[100], b[100];
	int n,i,j;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
	}
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt;b[i];
	}
	for ( i = 0; b[i] &lt;= b[i + 1] &amp;&amp; i &lt; n-1; i++);
	for (j = i + 1; a[j] == b[j] &amp;&amp; j &lt; n; j++);
	if (j == n) {
		cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl;
		sort(a, a + i + 2);
	}
	else {
		cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;
		int k = 1;
		bool flag = true;
		while (flag) {
			flag = false;
			for (int k = 0; k &lt; n; k++) {
				if (a[k] != b[k]) {
					flag = true;
				}
			}
			k = k * 2;
			for (i = 0; i &lt; n / k; i++) {
				sort(a + i * k, a + i * k + k);
			}
			sort(a + n / k * k, a + n);
		}
	}
    cout&lt;&lt;a[0];
	for (int i = 1; i &lt; n; i++) {
		cout&lt;&lt;&quot; &quot; &lt;&lt; a[i];
	}
	return 0;
}
</code></pre>
<h3 id="a1090">A1090</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=100010;
vector&lt;int&gt; children[maxn];
int maxdepth=0,num=0;
void DFS(int index,int depth){
	if(children[index].size()==0){
		if(depth&gt;maxdepth){
			maxdepth=depth;
			num=1;
		}
		else if(depth==maxdepth){
			num++;
		}
		return;
	}
	for(int i=0;i&lt;children[index].size();i++){
		DFS(children[index][i],depth+1);
	}
}
int main(){
	int n,father,root;
	double p,r;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%lf%lf&quot;,&amp;p,&amp;r);
	r/=100;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;father);
		if(father!=-1){
			children[father].push_back(i);
		}
		else root=i;
	}
	DFS(root,0);
	printf(&quot;%.2f %d&quot;,p*pow((1+r),maxdepth),num);
	return 0;
}
</code></pre>
<h3 id="a1091">A1091</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
int m, n, slice,T;
struct node {
	int x, y, z;
}Node;
int pixel[61][1290][128] = { 0 };
bool inq[61][1290][128] = { false };
int Y[6] = { 0,0,0,0,-1,1 };
int X[6] = { 0,0,1,-1,0,0 };
int Z[6] = { 1,-1,0,0,0,0 };
bool judge(int z, int x, int y) {
	if (z &gt;= slice || z &lt; 0 || x &gt;= m || x &lt; 0 || y &gt;= n || y &lt; 0) {
		return false;
	}
	if (inq[z][x][y]==true||pixel[z][x][y]==0) {
		return false;
	}
	return true;
}
int BFS(int z,int x,int y){
	int total=0;
	Node.x = x;
	Node.y = y;
	Node.z = z;
	inq[z][x][y] = true;
	queue&lt;node&gt; q;
	q.push(Node);
	while (!q.empty()) {
		node topp = q.front();
		q.pop();
		total++;
		int newx, newy, newz;
		for (int i = 0; i &lt; 6; i++) {
			newz = topp.z + Z[i];
			newx = topp.x + X[i];
			newy = topp.y + Y[i];
			if (judge(newz, newx, newy)) {
				Node.x = newx;
				Node.y = newy;
				Node.z = newz;
				q.push(Node);
				inq[Node.z][Node.x][Node.y] = true;
			}
		}
	}
	if (total &gt;= T) return total;
	else return 0;
}
int main() {
	int ans = 0;
	scanf(&quot;%d%d%d%d&quot;, &amp;m, &amp;n, &amp;slice, &amp;T);
	for (int i = 0; i &lt; slice; i++) {
		for (int j = 0; j &lt; m; j++) {
			for (int k = 0; k &lt; n; k++) {
				scanf(&quot;%d&quot;, &amp;pixel[i][j][k]);
			}
		}
	}
	for (int i = 0; i &lt; slice; i++) {
		for (int j = 0; j &lt; m; j++) {
			for (int k = 0; k &lt; n; k++) {
				if (pixel[i][j][k] == 1 &amp;&amp; inq[i][j][k] == false) {
					ans += BFS(i, j, k);
				}
			}
		}
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1092">A1092</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	int  hashtable[128] = { 0 };
	string s1, s2;
	int miss = 0;
	getline(cin, s1);
	getline(cin, s2);
	int len1 = s1.length();
	int len2 = s2.length();
	for (int i = 0; i &lt; len1; i++) {
		hashtable[s1[i]]++;
	}
	for (int j = 0; j &lt; len2; j++) {
		if (hashtable[s2[j]] &gt; 0) {
			hashtable[s2[j]]--;
		}
		else {
			miss++;
		}
	}
	if (miss &gt; 0) printf(&quot;No %d&quot;, miss);
	else printf(&quot;Yes %d&quot;, len1 - len2);
	return 0;
}
</code></pre>
<h3 id="a1093">A1093</h3>
<pre><code>#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn = 100010;
int main() {
	string str;
	cin &gt;&gt; str;
	int left_p[maxn] = { 0 };
	int len = str.length();
	for (int i = 0; i &lt; len; i++) {
		if (i &gt; 0) {
			left_p[i] = left_p[i - 1];
		}
		if (str[i] == 'P') {
			left_p[i]++;
		}
	}
	int res=0,count_T=0;
	for (int i = len-1; i &gt;=0; i--) {
		if (str[i] == 'T') {
			count_T++;
		}
		if (str[i] == 'A') {
			res = (res + (left_p[i] * count_T) % 1000000007) % 1000000007;
		}
	}
	cout &lt;&lt; res;
	return 0;
}
</code></pre>
<h3 id="a1094">A1094</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn = 110;
vector&lt;int&gt; child[maxn];
int hashtable[maxn] = { 0 };
void DFS(int index, int level) {
	hashtable[level]++;
	if (child[index].size() == 0) return;
	for (int i = 0; i &lt; child[index].size(); i++) {
		DFS(child[index][i], level + 1);
	}
}
int main(){
	int n,m,index,k,temp;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;index,&amp;k);
		for (int j = 1; j &lt;= k; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			child[index].push_back(temp);
		}
	}
	DFS(1, 1);
	int level, maxgeneration = 0;
	for (int i = 1; i &lt; maxn; i++) {
		if (hashtable[i] &gt; maxgeneration) {
			maxgeneration = hashtable[i];
			level = i;
		}
	}
	printf(&quot;%d %d&quot;, maxgeneration, level);
	return 0;
}
</code></pre>
<h3 id="a1096">A1096</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
int main() {
	long long  n;
	scanf(&quot;%lld&quot;, &amp;n);
	long long  sqr = sqrt(n * 1.0);
	long long len=0, first;
	for (long long i = 2; i &lt;= sqr; i++) {
		long long j = i, product = 1 ;
		while (1) {
			product *= j;
			if (n % product != 0) break;
			else {
				if (j - i + 1 &gt; len) {
					len = j - i + 1;
					first = i;
				}
			}
			j++;
		}
	}
	if (len == 0) {
		printf(&quot;1\n&quot;);
		printf(&quot;%lld&quot;, n);
	}
	else {
		printf(&quot;%lld\n&quot;, len);
		for (long long i = first; i &lt; first + len; i++) {
			if (i == first) printf(&quot;%lld&quot;, i);
			else printf(&quot;*%lld&quot;, i);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1097">A1097</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct Node{
	int address,key,next;
	int order;
}node[maxn];
bool cmp(Node a,Node b){
	return a.order&lt;b.order;
}
bool judge[maxn]={false};
int main(){
	int begin,n,address;;
	scanf(&quot;%d%d&quot;,&amp;begin,&amp;n);
	for(int i=0;i&lt;maxn;i++){
		node[i].order=2*maxn;
	}
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;node[address].key,&amp;node[address].next);
		node[address].address=address;
	}
	int p=begin,countvalid=0,countremoved=0;
	while(p!=-1){
		if(judge[abs(node[p].key)]==false){
			judge[abs(node[p].key)]=true;
			node[p].order=countvalid++;
		}
		else{
			node[p].order=maxn+countremoved++;
		}
		p=node[p].next;
	}
	sort(node,node+maxn,cmp);
	int count=countvalid+countremoved;
	for(int i=0;i&lt;count;i++){
		if(i!=countvalid-1&amp;&amp;i!=count-1){
			printf(&quot;%05d %d %05d\n&quot;,node[i].address,node[i].key,node[i+1].address);
		}
		else{
			printf(&quot;%05d %d -1\n&quot;,node[i].address,node[i].key);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1098">A1098</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
void downadjust(vector&lt;int&gt; &amp;b,int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; b[j + 1] &gt; b[j]) {
			j = j + 1;
		}
		if (b[i] &lt; b[j]) {
			swap(b[i], b[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
int main() {
	int n,p=2;
	scanf(&quot;%d&quot;, &amp;n);
	vector&lt;int&gt;a(n + 1);
	vector&lt;int&gt;b(n + 1);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]);
	while (p &lt;= n &amp;&amp; b[p - 1] &lt;= b[p]) p++;
	int k = p;
	while (a[p] == b[p]&amp;&amp;p&lt;=n) p++;
	if (p == n + 1) {
		printf(&quot;Insertion Sort\n&quot;);
		sort(b.begin() + 1, b.begin() + k + 1);
	}
	else {
        printf(&quot;Heap Sort\n&quot;);
		p = n;
		while (p &gt; 2 &amp;&amp; b[p] &gt;= b[1]) p--;
		swap(b[1], b[p]);
		downadjust(b, 1, p - 1);
	}
    printf(&quot;%d&quot;, b[1]);
	for (int i = 2; i &lt;= n; i++) printf(&quot; %d&quot;, b[i]);
	return 0;
}
</code></pre>
<h3 id="a1099">A1099</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 110;
int n,inorder[maxn],index=0,num=0;
struct node {
	int data;
	int left, right;
}Node[maxn];
void in_insert(int root) {
	if (root == -1) return;
	in_insert(Node[root].left);
	Node[root].data = inorder[index++];
	in_insert(Node[root].right);
}
void BFS(int root) {
	queue&lt;int&gt;q;
	q.push(root);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		printf(&quot;%d&quot;, Node[now].data);
		num++;
		if (num &lt; n) printf(&quot; &quot;);
		if (Node[now].left != -1) q.push(Node[now].left);
		if (Node[now].right != -1) q.push(Node[now].right);
	}
}
int main() {
	scanf_s(&quot;%d&quot;, &amp;n);
	int root = 0;
	for (int i = 0; i &lt; n; i++) {
		scanf_s(&quot;%d%d&quot;, &amp;Node[i].left, &amp;Node[i].right);
	}
	for (int i = 0; i &lt; n; i++) {
		scanf_s(&quot;%d&quot;, &amp;inorder[i]);
	}
	sort(inorder, inorder + n);
	in_insert(0);
	BFS(0);
	return 0;
}
</code></pre>
<h3 id="a1100">A1100</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
string s1[13] = { &quot;tret&quot;,&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot; };
string s2[13] = { &quot;tret&quot;,&quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;,&quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot; };
map&lt;string, int&gt;strtonum;
int main() {
	int n;
	string str;
	scanf(&quot;%d%*c&quot;, &amp;n);
	while (n--) {
		getline(cin, str);
		if (str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') {
			int number = stoi(str);
			if (number &lt; 13) cout &lt;&lt; s1[number]&lt;&lt;endl;
			else {
				int unit = number % 13;
				number /= 13;
				int tens = number % 13;
				if (unit == 0) cout &lt;&lt; s2[tens] &lt;&lt; endl;
				else cout &lt;&lt; s2[tens] &lt;&lt; &quot; &quot; &lt;&lt; s1[unit] &lt;&lt; endl;
			}	
		}
		else {
			for (int i = 0; i &lt; 13; i++) {
				strtonum[s1[i]] = i;
			}
			for (int i = 1; i &lt; 13;i++ ) {
				strtonum[s2[i]] = 13 * i;
			}
			for (int i = 1; i &lt; 13; i++) {
				for (int j = 0; j &lt; 13; j++) {
					strtonum[s2[i] +&quot; &quot;+s1[j]] = i * 13 + j;
				}
			}
			cout &lt;&lt; strtonum[str] &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1101">A1101</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int maxn = 100010;
const int INF = 0x7fffffff;
int main() {
	int a[maxn], leftmax[maxn]  , rightmin[maxn] ;
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
	}
    leftmax[0]=0;
	for (int i = 1; i &lt; n; i++) {
			leftmax[i] = leftmax[i - 1];
			if (a[i - 1] &gt; leftmax[i]) leftmax[i] = a[i-1];
	}
	rightmin[n - 1] = INF;
	for (int i = n - 2; i &gt;= 0; i--) {
		rightmin[i] = rightmin[i + 1];
		if (a[i + 1] &lt; rightmin[i]) rightmin[i] = a[i + 1];
	}
	int count=0, num[maxn];
	for (int i = 0; i &lt; n; i++) {
		if (a[i] &gt; leftmax[i] &amp;&amp; a[i] &lt;rightmin[i]) {
			num[count++] = a[i];
		}
	}
	cout &lt;&lt; count&lt;&lt;endl;
	if(count!=0){
         cout &lt;&lt; num[0];
	    for (int i = 1; i &lt; count; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; num[i];
    }
    cout&lt;&lt;endl;
	return 0;
}
</code></pre>
<h3 id="a1102">A1102</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cctype&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int lchild, rchild;
}Node[11];
int n;
void layerorder(int root) {
	int num = 0;
	queue&lt;int&gt; q;
	q.push(root);
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		printf(&quot;%d&quot;, now);
		num++;
		if (num &lt; n) printf(&quot; &quot;);
		if (Node[now].lchild != -1) q.push(Node[now].lchild);
		if (Node[now].rchild != -1) q.push(Node[now].rchild);
	}
}
int num1 = 0; 
void inorder(int root) {
	if (root == -1) return;
    inorder(Node[root].lchild);
	printf(&quot;%d&quot;, root);
	num1++;
	if (num1 &lt; n) printf(&quot; &quot;);
	inorder(Node[root].rchild);
}
void postorder(int root) {
	if (root == -1) return;
	postorder(Node[root].lchild);
	postorder(Node[root].rchild);
	swap(Node[root].lchild, Node[root].rchild);
}
int main() {
	bool notroot[11] = { false };
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		char a, b;
		scanf(&quot;%*c%c %c&quot;, &amp;a, &amp;b);
		if (isdigit(a)) {
			Node[i].lchild = a - '0';
			notroot[Node[i].lchild] = true;
		}
		else {
			Node[i].lchild = -1;
		}
		if (isdigit(b)) {
			Node[i].rchild = b - '0';
			notroot[Node[i].rchild] = true;
		}
		else {
			Node[i].rchild = -1;
		}
	}
	int root;
	for (int i = 0; i &lt; n; i++) {
		if (notroot[i] == false) {
			root = i;
			break;
		}
	}
	postorder(root);
	layerorder(root);
	printf(&quot;\n&quot;);
	inorder(root);
	return 0;
}
</code></pre>
<h3 id="a1103">A1103</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
int n, k, p,maxfacsum=-1;
vector&lt;int&gt; temp, ans, fac;
void init() {
	int i = 0, temp=0;
	while (temp &lt;= n) {
		fac.push_back(temp);
		temp = (int)pow(1.0 * (++i),1.0* p);
	}
}
void DFS(int index, int nowk, int sum, int facsum) {
	if (sum == n &amp;&amp; nowk == k) {
		if (facsum &gt; maxfacsum) {
			ans = temp;//更新最优序列
			maxfacsum = facsum;
		}
		return;
	}
	if (nowk &gt; k || sum &gt; n) return;
	if (index - 1 &gt;= 0) {
		temp.push_back(index);
		DFS(index, nowk + 1, sum + fac[index], facsum + index);
		temp.pop_back();
		DFS(index - 1, nowk, sum, facsum);
	}
}
int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;p);
	init();
	DFS(fac.size() - 1, 0, 0, 0);
	if (maxfacsum == -1) printf(&quot;Impossible&quot;);
	else {
		printf(&quot;%d = %d^%d&quot;, n, ans[0], p);
		for (int i = 1; i &lt; ans.size(); i++) {
			printf(&quot; + %d^%d&quot;, ans[i], p);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1104">A1104</h3>
<pre><code>#include&lt;cstdio&gt;
const int maxn = 100010;
int main() {
	int n;
	double a[maxn],sum=0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%lf&quot;, &amp;a[i]);
        sum += a[i] * (n - i + 1) * i;
	}
	printf(&quot;%.2f&quot;, sum);
	return 0;
}
</code></pre>
<h3 id="a1105">A1105</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=100;
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int N,n,m,st=0;
	scanf(&quot;%d&quot;,&amp;N);
	vector&lt;int&gt; a(N);
	for(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	n=sqrt(1.0*N);
	while(n&gt;=1){
		if(N%n==0) break;
		n--;
	}
	m=N/n;
	int level=m/2+m%2;
	sort(a.begin(),a.end(),cmp);
	int putm=m,putn=n;
	vector&lt;vector&lt;int&gt; &gt; ans(m, vector&lt;int&gt;(n));
	for(int i=0;i&lt;level;i++){
		for(int j=i;j&lt;n&amp;&amp;st&lt;=N-1;j++) ans[i][j]=a[st++];
		for(int k=i+1;k&lt;=m-2&amp;&amp;st&lt;=N-1;k++) ans[k][n-1]=a[st++];
		for(int x=n-1;x&gt;=i&amp;&amp;st&lt;=N-1;x--) ans[m-1][x]=a[st++];
		for(int t=m-2;t&gt;=i+1&amp;&amp;st&lt;=N-1;t--) ans[t][i]=a[st++];
		n--;
		m--;
	}
	for(int i=0;i&lt;putm;i++){
		for(int j=0;j&lt;putn;j++){
			printf(&quot;%d&quot;,ans[i][j]);
			if(j&lt;putn-1) printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1106">A1106</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn = 100010;
const int  INF = 0x7fffffff;
vector&lt;int&gt; child[maxn];
double minprice = INF;
int n,num=0;
double p, r;
void DFS(int index, int depth) {
	if (child[index].size() == 0) {
		if (p * pow((1 + r/100), depth) &lt; minprice) {
			minprice = p * pow((1 + r/100), depth);
			num = 1;
		}
		else if (p * pow((1 + r/100), depth) == minprice) {
			num++;
		}
		return;
	}
	for (int i = 0; i &lt; child[index].size(); i++) {
		DFS(child[index][i], depth + 1);
	}
}
int main() {
	scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;p, &amp;r);
	int  k,temp;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;k);
		if (k == 0) continue;
		else {
			for (int j = 0; j &lt; k; j++) {
				scanf(&quot;%d&quot;, &amp;temp);
				child[i].push_back(temp);
			}
		}
	}
	DFS(0, 0);
	printf(&quot;%.4f %d&quot;, minprice, num);
	return 0;
}
</code></pre>
<h3 id="a1107">A1107</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1010;
int n;
int father[maxn];
int isroot[maxn]={0};
int course[maxn]={0};
bool cmp(int a,int b){
	return a&gt;b;
}
int findfather(int v){
	if(father[v]==v) return v;
	else{
		int F=findfather(father[v]);
		father[v]=F;
		return F;
	}
}
void Union(int a,int b){
	int fatherA=findfather(a);
	int fatherB=findfather(b);
	if(fatherA!=fatherB){
		father[fatherA]=fatherB;
	}
}
void init(int x){
	for(int i=1;i&lt;=n;i++){
		father[i]=i;
	}
}
int main(){
	int k,h;
	scanf(&quot;%d&quot;,&amp;n);
	init(n);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d:&quot;,&amp;k);
		for(int j=0;j&lt;k;j++){
			scanf(&quot;%d&quot;,&amp;h);
			if(course[h]==0){
				course[h]=i;
			}
			Union(i,findfather(course[h]));
		}
	}
	for(int i=1;i&lt;=n;i++){
		isroot[findfather(i)]++;
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		if(isroot[i]!=0){
			ans++;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	sort(isroot+1,isroot+n+1,cmp);
	for(int i=1;i&lt;=ans;i++){
		printf(&quot;%d&quot;,isroot[i]);
		if(i&lt;ans) printf(&quot; &quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1108">A1108</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main() {
	char a[100],b[100];
	int n,cnt=0;
	scanf(&quot;%d&quot;,&amp;n);
	double temp, sum = 0.0;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%s&quot;, a);
		sscanf(a, &quot;%lf&quot;, &amp;temp);
		sprintf(b, &quot;%.2f&quot;, temp);
		bool flag = false;
		for (int j = 0; j &lt; strlen(a); j++) {
			if (a[j] != b[j]) flag = true;
		}
		if (flag || temp &lt; -1000 || temp&gt;1000) {
			printf(&quot;ERROR: %s is not a legal number\n&quot;, a);
		}
		else {
			sum += temp;
			cnt++;
		}
	}
	if (cnt == 0) printf(&quot;The average of 0 numbers is Undefined&quot;);
	else if (cnt == 1) printf(&quot;The average of 1 number is %.2f&quot;, sum);
	else printf(&quot;The average of %d numbers is %.2f&quot;, cnt, sum / cnt);
	return 0;
}
</code></pre>
<h3 id="a1109">A1109</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn = 10010;
struct node {
	int height;
	char name[10];
}person[maxn];
bool cmp(node a, node b) {
	if (a.height != b.height) return a.height &gt; b.height;
	else return strcmp(a.name, b.name) &lt; 0;
}
int main() {
	int n, k, cnt = 0;
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; person[i].name;
		cin &gt;&gt; person[i].height;
	}
	int rownum = n / k;
	sort(person, person + n, cmp);
	for (int i = 0; i &lt; k; i++) {
		vector&lt;node&gt; ans(n+1);
		int num;
		if (i == 0)  num = n - (rownum * (k - 1));
		else  num = rownum;
		ans[num / 2 + 1] = person[cnt++];
		for (int j = 1; j &lt;= num / 2; j++) {
			if ((num / 2 + 1 - j) &gt;= 1) ans[num / 2 + 1 - j] = person[cnt++];
			if ((num / 2 + 1 + j) &lt;= num) ans[num / 2 + 1 + j] = person[cnt++];
		}
		for (int j = 1; j &lt;= num; j++) {
			cout &lt;&lt; ans[j].name;
			if (j &lt; num) cout &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
		ans.clear();
	}
	return 0;
}
</code></pre>
<h3 id="a1110">A1110</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	int lchild;
	int rchild;
}a[21];
int ans, maxn = -1;
void dfs(int root, int index) {
	if (index &gt; maxn) {
		maxn = index;
		ans = root;
	}
	if (a[root].lchild != -1) dfs(a[root].lchild, index * 2);
	if (a[root].rchild != -1) dfs(a[root].rchild, index * 2 + 1);
}
int main() {
	int root = 0,n, have[30] = { 0 };
	string c;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; c;
		if (c == &quot;-&quot;) a[i].lchild = -1;
		else {
			a[i].lchild = stoi(c);
			have[a[i].lchild] = 1;
		}
		cin &gt;&gt; c;
		if (c == &quot;-&quot;) a[i].rchild = -1;
		else {
			a[i].rchild = stoi(c);
			have[a[i].rchild] = 1;
		}
	}
	while (have[root] != 0) root++;
	dfs(root, 1);
	if (maxn == n) cout &lt;&lt; &quot;YES &quot; &lt;&lt; ans;
	else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;
	return 0;
}
</code></pre>
<h3 id="a1112">A1112</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
int main(){
	bool surenobroken[256]={false},hasprint[256]={false};
	map&lt;char,bool&gt; broken;
	vector&lt;char&gt; needprint;
	string s;
	int k;
	scanf(&quot;%d&quot;,&amp;k);
	cin&gt;&gt;s;
	int cnt=1;
	char pre='@';
	s=s+'@';
	for(int i=0;i&lt;s.size();i++){
		if(s[i]==pre){
			cnt++;
		}else{
			if(cnt%k!=0) surenobroken[pre]=true;
			cnt=1;
		}
		if(i&lt;s.size()-1) broken[s[i]]=(cnt%k==0);
		pre=s[i];
	}
	for(int i=0;i&lt;s.size()-1;i++){
		if(surenobroken[s[i]]==true) broken[s[i]]=false;
		if(broken[s[i]]==true&amp;&amp;hasprint[s[i]]==false){
			needprint.push_back(s[i]);
			hasprint[s[i]]=true;
		}
	}
	for(int i=0;i&lt;needprint.size();i++) cout&lt;&lt;needprint[i];
	cout&lt;&lt;endl;
    for(int i=0;i&lt;s.length()-1;i++){
    	cout&lt;&lt;s[i];
    	if(broken[s[i]]==true) i=i+k-1;
	}
	return 0;
}
</code></pre>
<h3 id="a1113小技巧水题">A1113(小技巧，水题)</h3>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt; 
#include&lt;vector&gt;
using namespace std;
int main(){
	int n,sum=0,halfsum=0;
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		sum+=v[i];
	}
	sort(v.begin(),v.end());
	for(int i=0;i&lt;n/2;i++) halfsum+=v[i]; 
    printf(&quot;%d %d&quot;,n%2,sum-2*halfsum);
	return 0;
}
</code></pre>
<h3 id="a1114-并查集">A1114 并查集</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node1 {
	int id, fid, mid,  num, area;
	int cid[10];
}person[100000];
struct node2 {
	int id, members = 0;
	double num = 0, area = 0;
	bool flag = false;
}ans[100000];
bool vis[100000] = { false };
int father[100000];
int findfather(int v) {
	while (v != father[v])
		v = father[v];
	return v;
}
void Union(int a, int b) {
	int fathera = findfather(a);
	int fatherb = findfather(b);
	if (fathera &lt; fatherb) father[fatherb] = fathera;
	else father[fathera] = fatherb;
}
bool cmp(node2 a, node2 b) {
	if (a.area != b.area ) return a.area &gt; b.area;
	else return a.id &lt; b.id;
}
int main() {
	int n, k, id, cnt = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; 10000; i++) father[i] = i;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d%d&quot;, &amp;person[i].id, &amp;person[i].fid, &amp;person[i].mid, &amp;k);
		vis[person[i].id] = true;
		if (person[i].fid != -1) {
			Union(person[i].id, person[i].fid);
			vis[person[i].fid] = true;
		}

		if (person[i].mid != -1) {
			Union(person[i].id, person[i].mid);
			vis[person[i].mid] = true;
		}
		for (int j = 0; j &lt; k; j++) {
			scanf(&quot;%d&quot;, &amp;person[i].cid[j]);
			Union(person[i].id, person[i].cid[j]);
			vis[person[i].cid[j]] = true;
		}
		scanf(&quot;%d%d&quot;, &amp;person[i].num, &amp;person[i].area);
	}
	for (int i = 0; i &lt; n; i++) {
		id = findfather(person[i].id);
		ans[id].id = id;
		ans[id].num += person[i].num;
		ans[id].area += person[i].area;
		ans[id].flag = true;
	}
	for (int i = 0; i &lt; 10000; i++) {
		if (ans[i].flag) cnt++;
		if (vis[i]) ans[findfather(i)].members++;
	}
	for (int i = 0; i &lt; 10000; i++) {
		if (ans[i].flag) {
			ans[i].num = (double)(ans[i].num * 1.0 / ans[i].members);
			ans[i].area = (double)(ans[i].area * 1.0 / ans[i].members);
		}
	}
	sort(ans, ans + 10000, cmp);
	printf(&quot;%d\n&quot;, cnt);
	for (int i = 0; i &lt; cnt; i++) {
		printf(&quot;%04d %d &quot;, ans[i].id, ans[i].members);
		printf(&quot;%.3f %.3f\n&quot;, ans[i].num, ans[i].area);
	}
	return 0;
}
</code></pre>
<h3 id="a1115二叉搜索树建立与dfs">A1115(二叉搜索树建立与DFS)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int data;
	node*lchild,*rchild; 
};
int maxdepth=-1,num[1001]={0},n;
node* create(node*root,int v){
	if(root==NULL){
		root=new node;
		root-&gt;data=v;
		root-&gt;lchild=root-&gt;rchild=NULL;
	}
	else if(root-&gt;data&gt;=v) root-&gt;lchild=create(root-&gt;lchild,v);
	else root-&gt;rchild=create(root-&gt;rchild,v);
	return root;
}
void dfs(node*root,int depth){
	if(root==NULL){
		maxdepth=max(depth,maxdepth);
		return;
	}
	num[depth]++;
	dfs(root-&gt;lchild,depth+1);
	dfs(root-&gt;rchild,depth+1); 
}	
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	vector&lt;int&gt; v(n);
	node*root=NULL;
	for(int i=0;i&lt;n;i++) {
		scanf(&quot;%d&quot;,&amp;v[i]);
		root=create(root,v[i]);
	}
	dfs(root,0);
	printf(&quot;%d + %d = %d&quot;,num[maxdepth-1],num[maxdepth-2],num[maxdepth-1]+num[maxdepth-2]);
	return 0;
}
</code></pre>
<h3 id="a1116">A1116</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(1.0*n);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	int id,n,k,rank[maxn],query;
	bool vis[maxn]={false};
	scanf(&quot;%d&quot;,&amp;n);
	fill(rank,rank+maxn,0);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;id);
		rank[id]=i;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;query);
		if(rank[query]==0) printf(&quot;%04d: Are you kidding?\n&quot;,query);
		else{
			if(vis[query]==true) printf(&quot;%04d: Checked\n&quot;,query);
		    else{
		    	vis[query]=true;
		    	if(rank[query]==1) printf(&quot;%04d: Mystery Award\n&quot;,query);
		    	else if(isprime(rank[query])) printf(&quot;%04d: Minion\n&quot;,query);
		    	else printf(&quot;%04d: Chocolate\n&quot;,query);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="a1117逻辑题">A1117(逻辑题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int a[100010]={0},n,j=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a,a+n,greater&lt;int&gt;());
    while(j&lt;n&amp;&amp;a[j]&gt;j+1) j++;
	printf(&quot;%d&quot;,j);
	return 0;
}
</code></pre>
<h3 id="a1118-并查集">A1118  并查集</h3>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
const int maxn = 10010;
int father[maxn], cnt[maxn] = { 0 };
int findfather(int v) {
	if (father[v] == v) return v;
	else {
		int F = findfather(father[v]);
		father[v] = F;
		return F;
	}
}
void Union(int a, int b) {
	int fa = findfather(a);
	int fb = findfather(b);
	if (fa != fb) father[fa] = fb;
}
bool vis[maxn] = { false };
int main() {
	int n, k, temp, id, num = 0, sum = 0,Q;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; maxn; i++) father[i] = i;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;k, &amp;id);
		vis[id] = true;
		for(int j = 0; j &lt; k-1; j++){
			scanf(&quot;%d&quot;, &amp;temp);
			vis[temp] = true;
			Union(id, temp);
		}
	}
	for (int i = 0; i &lt; maxn; i++) {
		if (vis[i]) cnt[findfather(i)]++;
	}
	for (int i = 0; i &lt; maxn; i++) {
		if (cnt[i] != 0) {
			num++;
			sum += cnt[i];
		}
	}
	printf(&quot;%d %d\n&quot;, num, sum);
	scanf(&quot;%d&quot;, &amp;Q);
	for (int i = 0; i &lt; Q; i++){
		int q1, q2;
		scanf(&quot;%d%d&quot;, &amp;q1, &amp;q2);
		if (findfather(q1) != findfather(q2)) printf(&quot;No\n&quot;);
		else printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1119-30-树的前序和后序-求中序">A1119 (30 树的前序和后序 求中序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt; pre, post, in;
bool unique = true;
void getin(int prel, int prer, int postl, int postr) {
	if (prel == prer) {
		in.push_back(pre[prel]);
		return;
	}
	if (pre[prel] == post[postr]) {
		int i = prel + 1;
		while (i &lt;= prer &amp;&amp; pre[i] != post[postr - 1]) i++;
		if (i - prel &gt; 1) getin(prel + 1, i - 1, postl, postl + (i - prel - 1) - 1);
		else unique = false;
		in.push_back(post[postr]);
		getin(i, prer, postl + (i - prel - 1), postr - 1);
	}
}
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	post.resize(n);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	getin(0, n - 1, 0, n - 1);
	if (unique) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	printf(&quot;%d&quot;, in[0]);
	for (int i = 1; i &lt; in.size(); i++) printf(&quot; %d&quot;, in[i]);
    printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
<h3 id="a1120">A1120</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=10010;
int main(){
	int n,sum[maxn]={0};
	string str;
	set&lt;int&gt; ans;
	cin&gt;&gt;n;
	bool flag[maxn]={false};
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;str;
		int len=str.size();
		for(int j=0;j&lt;len;j++){
			sum[i]+=(str[j]-'0');
		}
	}
	for(int i=0;i&lt;n;i++) ans.insert(sum[i]);
	printf(&quot;%d\n&quot;,ans.size());
	for(auto it=ans.begin();it!=ans.end();it++) {
		if(it!=ans.begin()) printf(&quot; %d&quot;,*it);
		else printf(&quot;%d&quot;,*it);
	}
	return 0;
}
</code></pre>
<h3 id="a1121-25-map-set应用">A1121 (25 map、set应用)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
bool flag[100000] = { false };
map&lt;int, int&gt;couple;
int main() {
	int n, m, p1, p2;
	set&lt;int&gt; ans;
	vector&lt;int&gt; guests;
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%d%d&quot;, &amp;p1, &amp;p2);
		couple[p1] = p2;
		couple[p2] = p1;
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d&quot;, &amp;p1);
		guests.push_back(p1);
		flag[p1] = true;
	}
	for (int i = 0; i &lt; guests.size(); i++) {
		if (couple.count(guests[i])==0||(flag[couple[guests[i]]]==false)&amp;&amp; couple.count(guests[i]) != 0) ans.insert(guests[i]);
	}
	printf(&quot;%d\n&quot;, ans.size());
	for (auto it = ans.begin(); it != ans.end(); it++) {
		if (it != ans.begin()) printf(&quot; &quot;);
		printf(&quot;%05d&quot;, *it);
	}
	return 0;
}
</code></pre>
<h3 id="a112225-哈密顿回路-set">A1122(25 哈密顿回路  set)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int n, m, g[201][201] = { 0 }, v1, v2;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;v1, &amp;v2);
		g[v1][v2] = 1;
		g[v2][v1] = 1;
	}
	int k, num, temp;
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		int flag1 = 1, flag2 = 1;
		scanf(&quot;%d&quot;, &amp;num);
		vector&lt;int&gt; data;
		set&lt;int&gt; path;
		for (int j = 0; j &lt; num; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			data.push_back(temp);
			path.insert(temp);
		}
		if (path.size() != n || data[0] != data[data.size() - 1] || num - 1 != n) flag1 = 0;
		for (int j = 0; j &lt; num - 1; j++) {
			if (g[data[j]][data[j + 1]] != 1) flag2 = 0;
		}
		if (flag1 &amp;&amp; flag2) printf(&quot;YES\n&quot;);
		else printf(&quot;NO\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a112330-avl-层序遍历-判断是否是完全二叉树">A1123(30 AVL 、层序遍历、判断是否是完全二叉树)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int data, height;
	node* lchild, * rchild;
};
node* newnode(int v) {
	node* Node = new node;
	Node-&gt;data = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
int getheight(node* root) {
	if (root == NULL) return 0;
	else return root-&gt;height;
}
int getbalance(node* root) {
	return getheight(root-&gt;lchild) - getheight(root-&gt;rchild);
}
void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newnode(v);
		return;
	}
	if (root-&gt;data &gt; v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalance(root) == 2) {
			if (getbalance(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalance(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild, v);
		updateheight(root);
		if (getbalance(root) == -2) {
			if (getbalance(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalance(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
int iscomplete = 1, after = 0;
vector&lt;int&gt; levelorder(node* root) {
	queue&lt;node*&gt; q;
	vector&lt;int&gt; v;
	q.push(root);
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		v.push_back(temp-&gt;data);
		if (temp-&gt;lchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;lchild);
		}
		else after = 1;
		if (temp-&gt;rchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;rchild);
		}
		else after = 1;
	}
	return v;
}
int main() {
	int n, temp;
	scanf(&quot;%d&quot;, &amp;n);
	node* root = NULL;
	vector&lt;int&gt; ans;
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;temp);
		insert(root, temp);
	}
	ans = levelorder(root);
	for (int i = 0; i &lt; ans.size(); i++) {
		if (i != 0) printf(&quot; &quot;);
		printf(&quot;%d&quot;, ans[i]);
	}
	printf(&quot;\n&quot;);
	if (iscomplete) printf(&quot;YES&quot;);
	else printf(&quot;NO&quot;);
	return 0;
}
</code></pre>
<h3 id="a1124-20-逻辑题">A1124  20 逻辑题</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int m,n,s;
	string temp;
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
	vector&lt;string&gt; follower(m+1),ans;
	map&lt;string,bool&gt; exist;
	for (int i = 1; i &lt;= m; i++) {
		cin &gt;&gt; temp;
		follower[i] = temp;
	}
	while (s &lt;= m) {
		if (exist.count(follower[s]) == 0) {
			exist[follower[s]] = true;
			ans.push_back(follower[s]);
			s += n;
		}
		else s += 1;
	}
	if (ans.size() == 0) printf(&quot;Keep going...&quot;);
	else {
		for (int i = 0; i &lt; ans.size(); i++)
			cout &lt;&lt; ans[i] &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a112525-贪心-排序">A1125(25 贪心 排序)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
	vector&lt;int&gt; v;
	int n, temp, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;temp);
		v.push_back(temp);
	}
	sort(v.begin(), v.end());
	ans = v[0];
	for (int i = 1; i &lt; v.size(); i++) ans = (ans + v[i] )/ 2;
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
<h3 id="a1126">A1126</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn = 520;
bool vis[maxn] = { false };
vector&lt;vector&lt;int&gt; &gt; g;
int cnt = 0;
void dfs(int index) {
	vis[index] = true;
	cnt++;
	for (int i = 0; i &lt; g[index].size(); i++) {
		if (vis[g[index][i]] == false) {
			dfs(g[index][i]);
		}
	}
}
int main() {
	int n, m, a, b, even = 0, odd = 0;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	g.resize(n + 1);
	for (int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(1);
	for (int i = 1; i &lt;= n; i++) {
		printf(&quot;%d&quot;, g[i].size());
		if (i &lt; n) printf(&quot; &quot;);
		else printf(&quot;\n&quot;);
		if (g[i].size() % 2 == 0) even++;
		else odd++;
	}
	if (cnt == n &amp;&amp; even == n) printf(&quot;Eulerian&quot;);
	else if (cnt == n &amp;&amp; even == n - 2 &amp;&amp; odd == 2) printf(&quot;Semi-Eulerian&quot;);
	else printf(&quot;Non-Eulerian&quot;);
	return 0;
}
</code></pre>
<h3 id="a112730-中序后序建树dfs输出z字形层序遍历">A1127(30 中序后序建树，dfs，输出z字形层序遍历)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int v;
	node* lchild, * rchild;
};
vector&lt;int&gt; in, post;
vector&lt;int&gt;ans[31];
node* create(int inl, int inr, int postl, int postr) {
	if (inl &gt; inr) return NULL;
	node* root = new node;
	root-&gt;v = post[postr];
	int i=inl;
	while (in[i] != post[postr]) i++;
	int leafnum = i - inl;
	root-&gt;lchild = create(inl, i - 1, postl, postl + leafnum - 1);
	root-&gt;rchild = create(i + 1, inr, postl + leafnum, postr - 1);
	return root;
}
int maxdepth = -1;
void dfs(node* root,int depth) {
	if (root == NULL) return;
	maxdepth = max(depth, maxdepth);
	ans[depth].push_back(root-&gt;v);
	dfs(root-&gt;lchild, depth + 1);
	dfs(root-&gt;rchild, depth + 1);
}int main() {
	int n;
	scanf_s(&quot;%d&quot;, &amp;n);
	in.resize(n), post.resize(n);
	for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;in[i]);
	for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;post[i]);
	node* root = NULL;
	root = create(0, n - 1, 0, n - 1);
	dfs(root, 0);
	printf(&quot;%d&quot;, ans[0][0]);
	for (int i = 1; i &lt;= maxdepth; i++) {
		if (i % 2 == 1) {
			for (int j = 0; j &lt; ans[i].size(); j++) printf(&quot; %d&quot;, ans[i][j]);
		}
		else {
			for (int j = ans[i].size()-1; j &gt;=0; j--) printf(&quot; %d&quot;, ans[i][j]);
		}
	}
	return 0;
}
</code></pre>
<h3 id="a112820-n皇后问题">A1128(20  n皇后问题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main() {
	int k, n;
	cin &gt;&gt; k;
	while (k--) {
		cin &gt;&gt; n;
		vector&lt;int&gt; v(n);
		bool flag = true;
		for (int i = 0; i &lt; n; i++) {
			cin &gt;&gt; v[i];
			for (int j = 0; j &lt; i; j++) {
				if (v[i] == v[j] || abs(v[i] - v[j]) == abs(i - j)){
           flag = false;
           break;
        } 
			}
		}
		if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1129-25-set的应用-结构体内运算符重载">A1129 (25 set的应用 结构体内运算符重载)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
struct node {
	int id;
	int freq;
	bool operator &lt; (const node&amp; a) const {
		return (freq != a.freq) ? freq &gt; a.freq:id &lt; a.id;
	}
};
int book[50001] = { 0 };
int main() {
	int n, k, id;
	cin &gt;&gt; n &gt;&gt; k;
	set&lt;node&gt; s;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; id;
		if (i != 0) {
			cout &lt;&lt; id &lt;&lt; &quot;:&quot;;
			int cnt = 0;
			for (auto it = s.begin(); cnt &lt; k &amp;&amp; it != s.end(); it++) {
				cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;id;
				cnt++;
			}
			cout &lt;&lt; endl;
		}
		auto it = s.find(node{ id,book[id] });
		if (it != s.end())s.erase(it);//如果能找到，就移除
		book[id]++;
		s.insert(node{ id,book[id] });
	}
	return 0;
}
</code></pre>
<h3 id="a1130dfs二叉树-输出中缀表达式">A1130(dfs二叉树 输出中缀表达式)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	string data;
	int l, r;
}tree[25];
string dfs(int root) {
	if (tree[root].l == -1 &amp;&amp; tree[root].r == -1) return tree[root].data;
	else if (tree[root].l == -1 &amp;&amp; tree[root].r != -1) return &quot;(&quot; + tree[root].data + dfs(tree[root].r) + &quot;)&quot;;
	else if (tree[root].l != -1 &amp;&amp; tree[root].r != -1) return &quot;(&quot; + dfs(tree[root].l) + tree[root].data + dfs(tree[root].r) + &quot;)&quot;;
}
int main() {
	int n, have[25] = { 0 }, root = 1;
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; tree[i].data &gt;&gt; tree[i].l &gt;&gt; tree[i].r;
		have[tree[i].l] = 1;
		have[tree[i].r] = 1;
	}
	while (have[root] == 1) root++;
	string ans = dfs(root);
	if (ans[0] == '(') ans = ans.substr(1, ans.length() - 2);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<h3 id="a113130-dfs-unordered_map邻接矩阵-难题">A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
vector&lt;vector&lt;int&gt; &gt; v(10000);
int visit[10000] = { 0 }, mincnt, mintransfer, st, ed;
unordered_map&lt;int, int&gt; line;
vector&lt;int&gt; path, temppath;
int transfercnt(vector&lt;int&gt; a) {
	int cnt = -1, preline = 0;
	for (int i = 1; i &lt; a.size(); i++) {
		if (line[a[i - 1] * 10000 + a[i]] != preline) cnt++;
		preline = line[a[i - 1] * 10000 + a[i]];
	}
	return cnt;
}
void dfs(int node, int cnt) {
	if (node == ed &amp;&amp; (cnt &lt; mincnt || (cnt == mincnt &amp;&amp; transfercnt(temppath) &lt; mintransfer))) {
		mincnt = cnt;
		mintransfer = transfercnt(temppath);
		path = temppath;
    return;
	}
	for (int i = 0; i &lt; v[node].size(); i++) {
		if (visit[v[node][i]] == 0) {
			visit[v[node][i]] = 1;
			temppath.push_back(v[node][i]);
			dfs(v[node][i], cnt + 1);
			visit[v[node][i]] = 0;
			temppath.pop_back();
		}
	}
}
int main() {
	int n, m, pre, temp, k;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) {
		scanf(&quot;%d%d&quot;, &amp;m, &amp;pre);
		for (int j = 1; j &lt; m; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			v[pre].push_back(temp);
			v[temp].push_back(pre);
			line[pre * 10000 + temp]=line[temp*10000+pre] = i;
			pre = temp;
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	while (k--) {
		mintransfer = mincnt = 1000000000;
		scanf(&quot;%d%d&quot;, &amp;st, &amp;ed);
		temppath.clear();
		temppath.push_back(st);
		visit[st] = 1;
		dfs(st, 0);
		visit[st] = 0;
		printf(&quot;%d\n&quot;, mincnt);
		int preline = 0, pretransfer = st;
		for (int i = 1; i &lt; path.size(); i++) {
			if (line[path[i - 1] * 10000 + path[i]] != preline) {
				if (preline != 0) printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, path[i - 1]);
				preline = line[path[i - 1] * 10000 + path[i]];
				pretransfer = path[i - 1];
			}
		}
		printf(&quot;Take Line#%d from %04d to %04d.\n&quot;, preline, pretransfer, ed);
	}
	return 0;
}
</code></pre>
<h3 id="a113220-字符串-水题">A1132(20 字符串 水题)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main() {
	string s, s1, s2;
	int n, len;
	cin &gt;&gt; n;
	while (n--) {
		cin &gt;&gt; s;
		len = s.size();
		s1 = s.substr(0, len / 2);
		s2 = s.substr(len / 2, len / 2);
		if (stoi(s1) == 0 || stoi(s2) == 0) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else if (stoi(s) % (stoi(s1) * stoi(s2)) == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a1133链表-重新排列">A1133(链表  重新排列)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int id, data, next;
};
vector&lt;node&gt; v, ans;
int main() {
	node a[100010];
	int begin, n, k;
	int id, data, next;
	scanf(&quot;%d%d%d&quot;, &amp;begin, &amp;n, &amp;k);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d%d&quot;, &amp;id, &amp;data, &amp;next);
		a[id] = { id,data,next };
	}
	for (; begin != -1; begin = a[begin].next) v.push_back(a[begin]);
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &lt; 0) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt;= 0 &amp;&amp; v[i].data &lt;= k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; v.size(); i++) {
		if (v[i].data &gt; k) ans.push_back(v[i]);
	}
	for (int i = 0; i &lt; ans.size() - 1; i++) {
		printf(&quot;%05d %d %05d\n&quot;, ans[i].id, ans[i].data, ans[i + 1].id);
	}
	printf(&quot;%05d %d -1&quot;, ans[ans.size() - 1].id, ans[ans.size() - 1].data);
	return 0;
}
</code></pre>
<h3 id="a1134图-结点与边的问题">A1134(图  结点与边的问题)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int n, m, v1, v2, k, nv;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	vector&lt;int&gt; v[10010];
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;v1, &amp;v2);
		v[v1].push_back(i);
		v[v2].push_back(i);
	}
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		scanf(&quot;%d&quot;, &amp;nv);
		bool flag[10010] = { false };
		int temp, j;
		for (int j = 0; j &lt; nv; j++) {
			scanf(&quot;%d&quot;, &amp;temp);
			for (int x = 0; x &lt; v[temp].size(); x++) flag[v[temp][x]] = true;
		}
		for (j = 0; j &lt; m; j++) {
			if (flag[j] == false) {
				printf(&quot;No\n&quot;);
				break;
			}
		}
		if(j==m) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a113530-判断红黑树-递归判断">A1135(30 判断红黑树 递归判断)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int v;
	node* lchild,*rchild;
};
node*create(node*root,int x){
	if(root==NULL) {
		root=new node;
		root-&gt;v=x;
		root-&gt;lchild=root-&gt;rchild=NULL;
	}
	else if(abs(root-&gt;v)&gt;abs(x)) root-&gt;lchild=create(root-&gt;lchild,x);
	else if(abs(root-&gt;v)&lt;=abs(x)) root-&gt;rchild=create(root-&gt;rchild,x);
	return root;
}
bool judge1(node*root){
	if(root==NULL) return true;
	if(root-&gt;v&lt;0){
		if(root-&gt;lchild!=NULL&amp;&amp;root-&gt;lchild-&gt;v&lt;0) return false;
		if(root-&gt;rchild!=NULL&amp;&amp;root-&gt;rchild-&gt;v&lt;0) return false;
	}
	return judge1(root-&gt;lchild)&amp;&amp;judge1(root-&gt;rchild);
}
int getblacknum(node*root){
	if(root==NULL) return 0;
	int l=getblacknum(root-&gt;lchild);
	int r=getblacknum(root-&gt;rchild);
	return root-&gt;v&gt;0?max(l,r)+1:max(l,r);
}
bool judge2(node*root){
	if(root==NULL) return true;
	int l=getblacknum(root-&gt;lchild);
	int r=getblacknum(root-&gt;rchild);
	if(l!=r) return false;
	return judge2(root-&gt;lchild)&amp;&amp;judge2(root-&gt;rchild);
}
int main(){
	int k,n;
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		scanf(&quot;%d&quot;,&amp;n);
		vector&lt;int&gt; tree(n);
		node*root=NULL;
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;tree[i]);
			root=create(root,tree[i]);
		}
		if(tree[0]&gt;0&amp;&amp;judge1(root)&amp;&amp;judge2(root)) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1136-20-回文串-字符串">A1136 (20 回文串 字符串)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
int main() {
	int n = 10;
	string origin, ans, ansv,rev;
	cin &gt;&gt; origin;
	rev = origin;
	reverse(rev.begin(), rev.end());
	if (origin == rev) {
		cout &lt;&lt; rev &lt;&lt; &quot; is a palindromic number.&quot;;
		return 0;
	}
	while (n--) {
		rev = origin;
		reverse(rev.begin(), rev.end());
		ans = add(origin, rev);
		ansv = ans;
		reverse(ansv.begin(), ansv.end());
		cout &lt;&lt; origin &lt;&lt; &quot; + &quot; &lt;&lt; rev &lt;&lt; &quot; = &quot; &lt;&lt; ans &lt;&lt; endl;
		if (ansv != ans) origin = ans;
		else {
			cout &lt;&lt; ans &lt;&lt; &quot; is a palindromic number.&quot;;
			return 0;
		}
	}
	cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
	return 0;
}
</code></pre>
<h3 id="a113725-map-排序">A1137(25 map 排序)</h3>
<pre><code>#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	string s;
	int gp,gm,gf,g; 
};
bool cmp(const node &amp;a,const node &amp;b){
	return a.g!=b.g? a.g&gt;b.g : a.s&lt;b.s;
}
map&lt;string,int&gt; mp;
int main(){
	vector&lt;node&gt;v,ans;
	int p,m,n,score,cnt=0;
	cin&gt;&gt;p&gt;&gt;m&gt;&gt;n;
	string stuid;
	for(int i=0;i&lt;p;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(score&gt;=200){
			v.push_back(node{stuid,score,-1,-1,-1});
			mp[stuid]=cnt++;
		}
	}
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(mp.count(stuid)!=0) v[mp[stuid]].gm=score; 
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;stuid&gt;&gt;score;
		if(mp.count(stuid)!=0) v[mp[stuid]].gf=v[mp[stuid]].g=score;
		if(v[mp[stuid]].gf&lt;v[mp[stuid]].gm) v[mp[stuid]].g=(int)(v[mp[stuid]].gm*0.4+v[mp[stuid]].gf*0.6+0.5);
	}
	for(int i=0;i&lt;v.size();i++){
		if(v[i].g&gt;=60) ans.push_back(v[i]);
	}
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i&lt;ans.size();i++) 
	    printf(&quot;%s %d %d %d %d\n&quot;,ans[i].s.c_str(),ans[i].gp,ans[i].gm,ans[i].gf,ans[i].g);
	return 0;
}
</code></pre>
<h3 id="a113930-逻辑题-unordered_map">A1139(30 逻辑题 unordered_map)</h3>
<pre><code>#include&lt;unordered_map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int a,b;
};
bool cmp(const node &amp;i,const node &amp;j){
	return i.a!=j.a? i.a&lt;j.a : i.b&lt;j.b;
}
unordered_map&lt;int ,bool&gt; isfri;
int main(){
	int n,m,k,c,d;
	cin&gt;&gt;n&gt;&gt;m;
	string a,b;
	vector&lt;int&gt; v[10000];
	for(int i=0;i&lt;m;i++){
		cin&gt;&gt;a&gt;&gt;b;
		if(a.length()==b.length()) {
			v[abs(stoi(a))].push_back(abs(stoi(b)));
			v[abs(stoi(b))].push_back(abs(stoi(a)));
		}
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
	}
	cin&gt;&gt;k;
	while(k--){
		vector&lt;node&gt; ans;
		cin&gt;&gt;c&gt;&gt;d;
		for(int i=0;i&lt;v[abs(c)].size();i++){
			for(int j=0;j&lt;v[abs(d)].size();j++){
				if(v[abs(c)][i]==abs(d)||v[abs(d)][j]==abs(c)) continue;
				if(isfri[v[abs(c)][i]*10000+v[abs(d)][j]]==true) ans.push_back(node{v[abs(c)][i],v[abs(d)][j]});
			}
		}
		sort(ans.begin(),ans.end(),cmp);
		cout&lt;&lt;ans.size()&lt;&lt;endl;
		for(int i=0;i&lt;ans.size();i++) printf(&quot;%04d %04d\n&quot;,ans[i].a,ans[i].b);
	}
	return 0;
}
</code></pre>
<h3 id="a1140">A1140</h3>
<pre><code>#include&lt;iostream&gt; 
#include&lt;string&gt;
using namespace std;
int main(){
	string s;
	int n,j;
	cin&gt;&gt;s&gt;&gt;n;
	for(int x=1;x&lt;n;x++){
       string ans;
       for(int i=0;i&lt;s.length();i=j){
       	for(j=i;j&lt;s.length()&amp;&amp;s[j]==s[i];j++);
       	ans+=s[i]+to_string(j-i);
	   }
	   s=ans;
	}
	cout&lt;&lt;s;
	return 0;
} 
</code></pre>
<h3 id="a1141">A1141</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt; 
#include&lt;map&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node{
	string name;
	double totalscore;
	int num;
}school[maxn];
bool cmp(node a,node b){
	if((int)a.totalscore!=(int)b.totalscore) return (int)a.totalscore&gt;(int)b.totalscore;
	else if(a.num!=b.num) return a.num&lt;b.num;
	else return a.name&lt;b.name;
}
map&lt;string,int&gt; s;
int main(){
	int n,num=0;
	double score;
	string id,schoolname;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0;i&lt;maxn;i++){
		school[i].totalscore=0;
		school[i].num=0;
	}
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;id&gt;&gt;score&gt;&gt;schoolname;
		for(int j=0;j&lt;schoolname.size();j++){
			if(isupper(schoolname[j])) schoolname[j]+=32;
		}
		if(s.count(schoolname)==0){
			s[schoolname]=num;
			school[s[schoolname]].name=schoolname;
			num++;
		}
		if(id[0]=='B') score=score/1.5;
		if(id[0]=='T') score=score*1.5;
		school[s[schoolname]].totalscore+=score;
		school[s[schoolname]].num++;
	}
	cout&lt;&lt;num&lt;&lt;endl;
	sort(school,school+num,cmp);
	int r=1;
	printf(&quot;%d %s %d %d\n&quot;,r,school[0].name.c_str(),(int)school[0].totalscore,school[0].num);
	for(int i=1;i&lt;num;i++){
		if((int)school[i].totalscore!=(int)school[i-1].totalscore) r=i+1;
		printf(&quot;%d %s %d %d\n&quot;,r,school[i].name.c_str(),(int)school[i].totalscore,school[i].num);
	}
	return 0;
}
</code></pre>
<h3 id="a114225-无向完全图-最大子图-两点相连">A1142(25 无向完全图 最大子图  两点相连)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main(){
	int g[210][210]={0};
	int nv,ne,v1,v2,k,n;
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	for(int i=0;i&lt;ne;i++){
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=1;
		g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--){
		int hash[nv+1]={0};
		int ismax=1,iscli=1;
		scanf(&quot;%d&quot;,&amp;n);
		vector&lt;int&gt; v(n);
		for(int i=0;i&lt;n;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			hash[v[i]]=1;
		}
		for(int i=0;i&lt;n-1;i++){
			for(int j=i+1;j&lt;n;j++){
				if(g[v[i]][v[j]]==0)
				iscli=0;
				break;
			}
		}
		if(iscli==0) {
			printf(&quot;Not a Clique\n&quot;);
			continue;
		}
		for(int i=1;i&lt;=nv;i++){
			if(hash[i]==0){
				for(int j=0;j&lt;n;j++){
					if(g[v[j]][i]==0) break;
					if(j==n-1) ismax=0;
				}
			}
		}
		if(iscli==1&amp;&amp;ismax==1) printf(&quot;Yes\n&quot;);
		else if(iscli==1&amp;&amp;ismax==0) printf(&quot;Not Maximal\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1143">A1143</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
const int maxn = 10010;
map&lt;int, bool&gt; node;
int main() {
	int m, n, v, u, a;
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	vector&lt;int&gt; pre(n);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d&quot;, &amp;pre[i]);
		node[pre[i]] = true;
	}
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		for (int j = 0; j &lt; n; j++) {
			a = pre[j];
			if ((a &gt;= u &amp;&amp; a &lt;= v) || (a &lt;= u &amp;&amp; a &gt;= v)) break;
		}
		if (node.count(u) == 0 &amp;&amp; node.count(v) == 0) printf(&quot;ERROR: %d and %d are not found.\n&quot;, u, v);
		else if (node.count(u) == 0 || node.count(v) == 0) printf(&quot;ERROR: %d is not found.\n&quot;, node.count(u) == 0?u:v);
		else if ((a &lt; u &amp;&amp; a &gt; v) || (a &gt; u &amp;&amp; a &lt; v)) printf(&quot;LCA of %d and %d is %d.\n&quot;, u, v, a);
		else if (a == v || a == u) printf(&quot;%d is an ancestor of %d.\n&quot;, a, a == v ? u : v);
	}
	return 0;
}
</code></pre>
<h3 id="a114525-hash-平方探查">A1145(25 hash 平方探查)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x){
	int sqr=sqrt(1.0*x);
	for(int i=2;i&lt;=sqr;i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	int msize,n,m,a;
	scanf(&quot;%d%d%d&quot;,&amp;msize,&amp;n,&amp;m);
	while(!isprime(msize)) msize++;
	vector&lt;int&gt; v(msize);
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a);
		int flag=0;
		for(int j=0;j&lt;msize;j++){
			int pos=(a+j*j)%msize;
			if(v[pos]==0){
				flag=1;
				v[pos]=a;
				break;
			}
		}
		if(flag==0) printf(&quot;%d cannot be inserted.\n&quot;,a);
	}
	int cnt=0,temp;
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		for(int j=0;j&lt;=msize;j++){//注意这里的&lt;=，因为要回到初始的位置才知道是否能插入
			cnt++;
			if(v[(temp+j*j)%msize]==temp||v[(temp+j*j)%msize]==0) break;
		}
	}
	printf(&quot;%.1f&quot;,cnt*1.0/m);
    return 0;
}
</code></pre>
<h3 id="a1144">A1144</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
int main(){
    int n,temp,num=0;
    map&lt;int,int&gt; s;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++) {
        scanf(&quot;%d&quot;,&amp;temp);
        s[temp]++;
    }
    while(++num){
        if(s.count(num)==0){
            printf(&quot;%d&quot;,num);
            break;
        }
    }
    return 0;
}
</code></pre>
<h3 id="a1146判断是否为拓扑排序序列">A1146(判断是否为拓扑排序序列 )</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int main() {
	int a, b, flag = 0, in[1010] = { 0 }, n, m, k;
	vector&lt;int&gt; v[1010];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 0; i &lt; m; i++) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		v[a].push_back(b);
		in[b]++;
	}
	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; i++) {
		int judge = 1;
		vector&lt;int&gt; query(in, in + n + 1);
		for (int j = 0; j &lt; n; j++) {
			scanf(&quot;%d&quot;, &amp;a);
			if (query[a] != 0) judge = 0;
			for (int x = 0; x &lt; v[a].size(); x++) query[v[a][x]]--;
		}
    if(judge==1) continue;
		else if (flag == 1 &amp;&amp; judge == 0) printf(&quot; %d&quot;, i);
		else if (flag == 0 &amp;&amp; judge == 0) printf(&quot;%d&quot;, i);
		flag = 1;
	}
	return 0;
}
</code></pre>
<h3 id="a114730-判断大顶堆小顶堆-后序遍历">A1147(30  判断大顶堆小顶堆 后序遍历)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int m, n, num = 0;
vector&lt;int&gt;v;
void dfs(int index) {//后序遍历
	if (index &gt; n) return;
	dfs(index * 2);
	dfs(index * 2 + 1);
	printf(&quot;%d&quot;, v[index]);
	if (num &lt; n - 1)printf(&quot; &quot;);
	num++;
}
int main() {
	scanf_s(&quot;%d%d&quot;, &amp;m, &amp;n);
	while (m--) {
		v.resize(n+1);
		bool flagmin = true, flagmax = true;
		for (int i = 1; i &lt;= n; i++) scanf_s(&quot;%d&quot;, &amp;v[i]);
		for (int i = 2; i &lt;= n; i++) {
			if (v[i] &gt;= v[i / 2]) flagmax = false;
			if (v[i] &lt;= v[i / 2]) flagmin = false;
		}
		if (flagmin) printf(&quot;Min Heap\n&quot;);
		else if (flagmax) printf(&quot;Max Heap\n&quot;);
		else if (flagmax == false &amp;&amp; flagmin == false) printf(&quot;Not Heap\n&quot;);
		dfs(1);
		num = 0;
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a1148狼人杀-找到两个狼人">A1148(狼人杀 找到两个狼人)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main(){
	int n;
	cin&gt;&gt;n;
	vector&lt;int&gt; v(n+1);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i];
	for(int i=1;i&lt;=n;i++){
		for(int j=i+1;j&lt;=n;j++){
			vector&lt;int&gt; lie,a(n+1,1);
			a[i]=a[j]=-1;
			for(int k=1;k&lt;=n;k++){
				if(v[k]*a[abs(v[k])]&lt;0) lie.push_back(k);
			}
			if(lie.size()==2&amp;&amp;(a[lie[0]]+a[lie[1]])==0){
				cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;
				return 0;
			}
		}
	}
	cout&lt;&lt;&quot;No Solution&quot;;
	return 0;
}
</code></pre>
<h3 id="a1149">A1149</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
map&lt;int, vector&lt;int&gt; &gt;danger;
int main() {
	int n, m, k, d1, d2;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	vector&lt;int&gt; G(n + 1);
	for (int i = 0; i &lt; n; i++) {
		scanf(&quot;%d%d&quot;, &amp;d1, &amp;d2);
		danger[d1].push_back(d2);
		danger[d2].push_back(d1);
	}
	for (int i = 0; i &lt; m; i++) {
		bool flag = false;
        vector&lt;int&gt; G(n + 1);
		int exist[100000] = { 0 };
		scanf(&quot;%d&quot;, &amp;k);
		for (int j = 0; j &lt; k; j++) {
			scanf(&quot;%d&quot;, &amp;G[j]);
			exist[G[j]] = 1;
		}
		for (int j = 0; j &lt; k; j++) {
			for (int p = 0; p &lt; danger[G[j]].size(); p++) {
				if (exist[danger[G[j]][p]] == 1) flag = true;
			}
		}
		if (flag == false) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115025-判断循环图-输出最小路径">A1150(25 判断循环图 输出最小路径)</h3>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
int main(){
	int n,m,k,mindis=1000000000,ansid;
	int g[210][210]={0};
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		int v1,v2,d;
		scanf(&quot;%d%d%d&quot;,&amp;v1,&amp;v2,&amp;d);
		g[v1][v2]=d;
		g[v2][v1]=d;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int y=1;y&lt;=k;y++){
		int cnt,flag=1,index,sum=0;
		scanf(&quot;%d&quot;,&amp;cnt);
		set&lt;int&gt;s;
		vector&lt;int&gt; v(cnt);
		for(int i=0;i&lt;cnt;i++){
			scanf(&quot;%d&quot;,&amp;v[i]);
			s.insert(v[i]);
		} 
		for(int i=0;i&lt;cnt-1;i++){
			if(g[v[i]][v[i+1]]==0) flag=0;
			sum+=g[v[i]][v[i+1]];
		}
		if(flag==0) printf(&quot;Path %d: NA (Not a TS cycle)\n&quot;,y);
		else if(v[0]!=v[cnt-1]||s.size()!=n) printf(&quot;Path %d: %d (Not a TS cycle)\n&quot;,y,sum);
		else if(cnt!=n+1){
			if(sum&lt;mindis){
				mindis=sum;
				ansid=y;
			}
			printf(&quot;Path %d: %d (TS cycle)\n&quot;,y,sum);
		}else{
			if(sum&lt;mindis){
				mindis=sum;
				ansid=y;
			}
			printf(&quot;Path %d: %d (TS simple cycle)\n&quot;,y,sum);
		}
	}
	printf(&quot;Shortest Dist(%d) = %d&quot;,ansid,mindis);
	return 0;
}
</code></pre>
<h3 id="a1151">A1151</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10010;
map&lt;int,int&gt; pos;
vector&lt;int&gt; ins,pre;
void lca(int inl,int inr,int preroot,int a,int b){
	if(inl&gt;inr) return;
	int inroot=pos[pre[preroot]],ain=pos[a],bin=pos[b];
	if(ain&lt;inroot&amp;&amp;bin&lt;inroot) lca(inl,inroot-1,preroot+1,a,b);
	else if((ain&lt;inroot&amp;&amp;bin&gt;inroot)||(ain&gt;inroot&amp;&amp;bin&lt;inroot)){
		printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,ins[inroot]);
	}
	else if(ain&gt;inroot&amp;&amp;bin&gt;inroot) lca(inroot+1,inr,preroot+1+(inroot-inl),a,b);
	else if(ain==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);
	else if(bin==inroot) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);
}
int main(){
	int m,n,a,b;
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	ins.resize(n + 1), pre.resize(n + 1);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;ins[i]);
		pos[ins[i]]=i;
	}
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,a);
		if(pos.count(b)==0&amp;&amp;pos.count(a)!=0) printf(&quot;ERROR: %d is not found.\n&quot;,b);
		if(pos.count(a)==0&amp;&amp;pos.count(b)==0) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);
		if(pos.count(a)!=0&amp;&amp;pos.count(b)!=0) lca(1,n,1,a,b);
	}
	return 0;
}
</code></pre>
<h3 id="a115325-模拟-排序引用传参-vector-unordered_map">A1153(25 模拟 排序引用传参 vector unordered_map)</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	string info;
	int score;
};
bool cmp(const node&amp; a, const node&amp; b) {
	return a.score != b.score ? a.score &gt; b.score : a.info &lt; b.info;
}
int main() {
	int n, m, type;
	string t;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; v(n);
	for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i].info &gt;&gt; v[i].score;
	for (int i = 1; i &lt;= m; i++) {
		vector&lt;node&gt; ans;
		cin &gt;&gt; type &gt;&gt; t;
		printf(&quot;Case %d: %d %s\n&quot;, i, type, t.c_str());
		int sum = 0, cnt = 0;
		if (type == 1) {
			for (int j = 0; j &lt; n; j++) {
				if (t[0] == v[j].info[0]) ans.push_back(v[j]);
			}
		}
		else if (type == 2) {
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(1, 3) == t) {
					cnt++;
					sum += v[j].score;
				}
			}
			if (cnt != 0) printf(&quot;%d %d\n&quot;, cnt, sum);
		}
		else {
			unordered_map&lt;string, int&gt; m;
			for (int j = 0; j &lt; n; j++) {
				if (v[j].info.substr(4, 6) == t) m[v[j].info.substr(1, 3)]++;
			}
			for (auto it : m) ans.push_back({ it.first,it.second });
		}
		sort(ans.begin(), ans.end(), cmp);
		for (int j = 0; j &lt; ans.size(); j++) printf(&quot;%s %d\n&quot;, ans[j].info.c_str(), ans[j].score);
		if (((type == 1 || type == 3) &amp;&amp; ans.size() == 0) || (type == 2 &amp;&amp; cnt == 0)) printf(&quot;NA\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="a115425-图-边的两端点的判断">A1154(25 图  边的两端点的判断  )</h3>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
struct node {
	int v1, v2;
};
int main() {
	int n, m, k;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;node&gt; g(10010);
	for (int i = 0; i &lt; m; i++) cin &gt;&gt; g[i].v1 &gt;&gt; g[i].v2;
	cin &gt;&gt; k;
	for (int i = 0; i &lt; k; i++) {
		set&lt;int&gt; color; 
		vector&lt;int&gt; e(n);
		bool flag = true;
		for (int j = 0; j &lt; n; j++) {
			cin &gt;&gt; e[j];
			color.insert(e[j]);
		}
		for (int j = 0; j &lt; m; j++) {
			if (e[g[j].v1] == e[g[j].v2]) flag = false;
		}
		if (flag == false) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
		else cout &lt;&lt; color.size() &lt;&lt; &quot;-coloring&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="a115530-完全二叉树-判断大顶堆小顶堆-dfs-打印路径">A1155(30 完全二叉树  判断大顶堆小顶堆 dfs  打印路径)</h3>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;int&gt;v;
int n, a[1010];
void dfs(int index) {
	if (index * 2 &gt; n &amp;&amp; index * 2 + 1 &gt; n) {
		if (index &lt;= n) {
			for (int i = 0; i &lt; v.size(); i++) {
				if (i != 0) printf(&quot; &quot;);
				printf(&quot;%d&quot;, v[i]);
			}
			printf(&quot;\n&quot;);
		}
	}
	else {
		v.push_back(a[index * 2 + 1]);
		dfs(index * 2 + 1);
		v.pop_back();
		v.push_back(a[index * 2]);
		dfs(index * 2);
		v.pop_back();
	}
}
int main() {
	bool minflag = true, maxflag = true;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	v.push_back(a[1]);
	for (int i = 2; i &lt;= n; i++) {
		if (a[i] &gt;= a[i / 2]) maxflag = false;
		if (a[i] &lt;= a[i / 2]) minflag = false;
	}
	dfs(1);
	if (minflag) printf(&quot;Min Heap&quot;);
	else if (maxflag) printf(&quot;Max Heap&quot;);
	else if (maxflag == false &amp;&amp; minflag == false) printf(&quot;Not Heap&quot;);
	return 0;
}
</code></pre>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      lxb&#39;blog
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://liuxbo.github.io/post/pat-ti-jie/" title="PAT题解">PAT题解</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://liuxbo.github.io/tag/a8Kpb5X9y/"># PAT</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="IDEA的使用" href="https://liuxbo.github.io/post/idea-de-shi-yong/">IDEA的使用</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="IDEA的使用" href="https://liuxbo.github.io/post/idea-de-shi-yong/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="c++刷题笔记" href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">c++刷题笔记</a>
        <a class="nav-mobile-next" title="c++刷题笔记" href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="\media\images\custom-bgImg.png" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>