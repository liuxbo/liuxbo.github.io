<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="菜鸡成长之路">
<meta name="theme-color" content="#000">
<title>PAT2019春、秋、冬，2020春、秋真题 | lxb&#39;blog</title>
<link rel="shortcut icon" href="https://liuxbo.github.io/favicon.ico?v=1607075787550">
<link rel="stylesheet" href="https://liuxbo.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="PAT2019春、秋、冬，2020春、秋真题" />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>lxb&#39;blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">左手蓝银右手锤</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://liuxbo.github.io/images/avatar.png"/>
    <p class="site-author-name">lxb&#39;blog</p>
    <p class="site-description right-motion">铅华洗尽</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://liuxbo.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#115620-sexy-primes-%E7%B4%A0%E6%95%B0">1156(20 Sexy Primes  素数)</a></li>
<li><a href="#115725-anniversary-unordered_mapset">1157(25 Anniversary unordered_map/set)</a></li>
<li><a href="#115825-%E7%94%B5%E4%BF%A1%E8%AF%88%E9%AA%97-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%9B%BE">1158(25 电信诈骗 并查集 图)</a></li>
<li><a href="#115930-map-sscanf-%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E5%BB%BA%E6%A0%91%E5%8A%A0%E6%A0%91%E7%9A%84%E7%BB%BC%E5%90%88%E6%80%A7%E8%80%83%E5%AF%9F">1159(30 map、sscanf、中序后序建树加树的综合性考察)</a></li>
<li><a href="#1160-20-forever-dfs%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D">1160 (20 Forever dfs+回溯剪枝)</a></li>
<li><a href="#116125-%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8">1161(25 合并链表)</a></li>
<li><a href="#116225-%E8%BE%93%E5%87%BA%E6%A0%91%E7%9A%84%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">1162(25 输出树的后缀表达式)</a></li>
<li><a href="#116330-%E5%88%A4%E6%96%ADdijkst%E7%9A%84%E5%90%88%E6%B3%95%E8%B7%AF%E5%BE%84">1163(30 判断dijkst的合法路径)</a></li>
<li><a href="#116420-%E5%9B%BE%E5%BD%A2%E8%BE%93%E5%87%BA-%E9%80%BB%E8%BE%91%E9%A2%98-%E6%B3%A8%E6%84%8F%E7%94%A8stringgetchar%E5%90%B8%E6%94%B6%E6%8D%A2%E8%A1%8C%E7%AC%A6">1164(20 图形输出 逻辑题 注意用string，getchar吸收换行符)</a></li>
<li><a href="#116525-%E9%93%BE%E8%A1%A8%E5%88%86%E6%AE%B5%E6%8B%BC%E6%8E%A5">1165(25 链表分段拼接)</a></li>
<li><a href="#116625-%E5%9B%BE">1166(25 图)</a></li>
<li><a href="#116730-%E7%94%A8%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%BB%BA%E7%AB%8B%E5%A0%86%E6%A0%91">1167(30 用中序遍历序列建立“堆”树)</a></li>
<li><a href="#1168-prime-day">1168  Prime Day</a></li>
<li><a href="#1169-the-judger">1169 The Judger</a></li>
<li><a href="#1170-safari-park">1170 Safari Park</a></li>
<li><a href="#1171-replacement-selection">1171 <strong>Replacement Selection</strong></a></li>
<li><a href="#1172-2020-%E7%A7%8B%E5%AD%A3panda-and-pp-milk20">1172 2020 秋季<strong>Panda and PP Milk</strong>（20）</a></li>
<li><a href="#1173-7-2-how-many-ways-to-buy-a-piece-of-land-25%E5%88%86">1173 <strong>7-2</strong> <strong>How Many Ways to Buy a Piece of Land</strong>  (25分)</a></li>
<li><a href="#1174-left-view-of-binary-tree-25%E5%88%86">1174 <strong>Left-View of Binary Tree</strong> (25分)</a></li>
<li><a href="#1175-professional-ability-test-30%E5%88%86">1175  <strong>Professional Ability Test</strong> (30分)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://liuxbo.github.io/post/2019-nian-pat-chun-qiu-dong-zhen-ti/">
      PAT2019春、秋、冬，2020春、秋真题
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-07-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>68分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>10951<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <h3 id="115620-sexy-primes-素数">1156(20 Sexy Primes  素数)</h3>
<p>题目描述：</p>
<p>Sexy primes are pairs of primes of the form (p, p+6), so-named since “sex” is the Latin word for “six”. (Quoted from http://mathworld.wolfram.com/SexyPrimes.html)</p>
<p>Now given an integer, you are supposed to tell if it is a sexy prime.</p>
<p>Input Specification:<br>
Each input file contains one test case. Each case gives a positive integer N (≤10^8).</p>
<p>Output Specification:<br>
For each case, print in a line Yes if N is a sexy prime, then print in the next line the other sexy prime paired with N (if the answer is not unique, output the smaller number). Or if N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N.</p>
<pre><code>Sample Input 1:
47
Sample Output 1:
Yes
41
Sample Input 2:
21
Sample Output 2:
No
23
</code></pre>
<p>————————————————</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
bool isprime(int x) {
	if(x&lt;=1) return false;
	int sqr=sqrt(1.0*x);
	for(int i=2; i&lt;=sqr; i++) {
		if(x%i==0) return false;
	}
	return true;
}
bool sexprime(int x) {
	if(((isprime(x)&amp;&amp;isprime(x+6)))||((isprime(x))&amp;&amp;isprime(x-6)))
		return true;
	return false;
}
int main() {
	int n;
	cin&gt;&gt;n;
	if(sexprime(n)) cout&lt;&lt;&quot;Yes\n&quot;&lt;&lt;n-6;
	else {
		cout&lt;&lt;&quot;No\n&quot;;
		while(!sexprime(n)) n++;
		cout&lt;&lt;n;
	}
	return 0;
}
</code></pre>
<h3 id="115725-anniversary-unordered_mapset">1157(25 Anniversary unordered_map/set)</h3>
<p>题目描述:</p>
<p>Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association （校友会） has gathered the ID’s of all her alumni. Now your job is to write a program to count the number of alumni<br>
among all the people who come to the celebration.</p>
<p>Input Specification:<br>
Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer NNN (≤105).<br>
Then NNN lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X. It is guaranteed that all the ID’s are distinct.<br>
The next part gives the information of all the people who come to the celebration.<br>
Again given in the first line is a positive integer MMM(≤105). Then MMM lines follow, each contains an ID number of a guest. It is guaranteed that all the ID’s are distinct.</p>
<p>Output Specification:<br>
First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus – notice that the 7th - 14th digits of the ID gives one’s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.</p>
<pre><code>Sample Input:
5
372928196906118710
610481197806202213
440684198612150417
13072819571002001X
150702193604190912
6
530125197901260019
150702193604190912
220221196701020034
610481197806202213
440684198612150417
370205198709275042

Sample Output:
3
150702193604190912
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;unordered_map&gt;
using namespace std;
int main() {
	int n,m,cnt=0;
	cin&gt;&gt;n;
	getchar();//注意 
	string s,oldest=&quot;999999999999999999&quot;;
	unordered_map&lt;string,bool&gt; mp;
	for(int i=0; i&lt;n; i+7+) {
		cin&gt;&gt;s;
		if(s.substr(6,8)&lt;oldest.substr(6,8)) oldest=s;
		mp[s]=true;
	}
	cin&gt;&gt;m;
	while(m--) {
		cin&gt;&gt;s;
		if(mp[s]==true) cnt++;
	}
	if(cnt!=0) cout&lt;&lt;cnt&lt;&lt;endl&lt;&lt;oldest;
    return 0;
}
</code></pre>
<h3 id="115825-电信诈骗-并查集-图">1158(25 电信诈骗 并查集 图)</h3>
<p>题目描述:</p>
<p>Telefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.</p>
<p>A person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes.</p>
<p>Input Specification:<br>
Each input file contains one test case. For each case, the first line gives 3 positive integers K (≤500, the threshold（阈值） of the amount of short phone calls), N (≤10^3, the number of different phone numbers), and M (≤10^5, the number of phone call records). Then M lines of one day's records are given, each in the format:</p>
<pre><code>caller receiver duration
</code></pre>
<p>where caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day.</p>
<p>Output Specification:<br>
Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>If no one is detected, output None instead.</p>
<pre><code>Sample Input 1:

5 15 31
1 4 2
1 5 2
1 5 4
1 7 5
1 8 3
1 9 1
1 6 5
1 15 2
1 15 5
3 2 2
3 5 15
3 13 1
3 12 1
3 14 1
3 10 2
3 11 5
5 2 1
5 3 10
5 1 1
5 7 2
5 6 1
5 13 4
5 15 1
11 10 5
12 14 1
6 1 1
6 9 2
6 10 5
6 11 2
6 12 1
6 13 1

Sample Output 1:
3 5
6

Sample Input 2:
5 7 8
1 2 1
1 3 1
1 4 1
1 5 1
1 6 1
1 7 1
2 1 1
3 1 1

Sample Output 2:
None
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
#include&lt;map&gt;
using namespace std;
const int maxn=1001;
int k,n,m,father[maxn],g[maxn][maxn],gangnum=0;
int findfather(int x){
	while(x!=father[x]) x=father[x];
	return x;
}
void Union(int a,int b) {
	int faA=findfather(a);
	int faB=findfather(b);
	if(faA&gt;faB) father[faA]=faB;
	else if(faA&lt;faB) father[faB]=faA;
}
int main() {
	for(int i=1; i&lt;=maxn; i++) father[i]=i;
	scanf(&quot;%d%d%d&quot;,&amp;k,&amp;n,&amp;m);
	vector&lt;int&gt; gang[n+1],susp;
	int v1,v2,time;
	fill(g[0],g[0]+maxn*maxn,0);
	for(int i=0; i&lt;m; i++) {
		scanf(&quot;%d%d%d&quot;,&amp;v1,&amp;v2,&amp;time);
		g[v1][v2]=time;
	}
	for(int i=1;i&lt;=n;i++){
		int total=0,cnt=0;
		for(int j=1;j&lt;=n;j++){
			if(g[i][j]&gt;0&amp;&amp;g[i][j]&lt;=5){
				total++;
				if(g[j][i]&gt;0) cnt++;
			}
		}
		if((double)(cnt*1.0/total)&lt;=0.2&amp;&amp;total&gt;k) susp.push_back(i);
	}
	for(int i=0;i&lt;susp.size();i++){
		for(int j=0;j&lt;susp.size();j++){
			if(g[susp[i]][susp[j]]&gt;0&amp;&amp;g[susp[j]][susp[i]]&gt;0) Union(susp[i],susp[j]);
		}
	}
	for(int i=0;i&lt;susp.size();i++){
		gang[findfather(susp[i])].push_back(susp[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(gang[i].size()!=0){
			for(int j=0;j&lt;gang[i].size();j++){
				if(j&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,gang[i][j]);
			}
			gangnum++;
			printf(&quot;\n&quot;);
		}
	}
	if(gangnum==0) printf(&quot;None&quot;);
	return 0;
}
</code></pre>
<h3 id="115930-map-sscanf-中序后序建树加树的综合性考察">1159(30 map、sscanf、中序后序建树加树的综合性考察)</h3>
<p>题目描述:</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p>
<p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p>
<pre><code>A is the root
A and B are siblings
A is the parent of B
A is the left child of B
A is the right child of B
A and B are on the same level
It is a full tree
</code></pre>
<p>Note:</p>
<ul>
<li>
<p>Two nodes are on the same level, means that they have the same depth.</p>
</li>
<li>
<p>A full binary tree is a tree in which every node other than the<br>
leaves has two children.</p>
</li>
</ul>
<p><strong>Input Specification:</strong><br>
Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 103 and are separated by a space.</p>
<p>Then another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree.</p>
<p><strong>Output Specification:</strong><br>
For each statement, print in a line Yes if it is correct, or No if not.</p>
<p><strong>Sample Input:</strong></p>
<pre><code>9
16 7 11 32 28 2 23 8 15
16 23 7 32 11 2 28 15 8
7
15 is the root
8 and 2 are siblings
32 is the parent of 11
23 is the left child of 16
28 is the right child of 2
7 and 11 are on the same level
It is a full tree
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>Yes
No
Yes
No
Yes
Yes
Yes
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct node {
	int v,level;
	node*parent,*lc,*rc;
	node(int val,int lev) : v(val),parent(NULL),lc(NULL),rc(NULL),level(lev) {}  //构造函数 
};
unordered_map&lt;int,node*&gt; mp;//妙啊
vector&lt;int&gt; in,post;
node*root=NULL;
bool isfull=true;
node*create(int postl,int postr,int inl,int inr,int level) {
	if(postl&gt;postr) return NULL;
	node*root=new node(post[postr],level);
	int k=inl;
	while(k&lt;=inr&amp;&amp;in[k]!=root-&gt;v) k++;
	int leftnum=k-inl;
	root-&gt;lc=create(postl,postl+leftnum-1,inl,k-1,level+1);
	root-&gt;rc=create(postl+leftnum,postr-1,k+1,inr,level+1);
	if(root-&gt;lc!=NULL) root-&gt;lc-&gt;parent=root;
	if(root-&gt;rc!=NULL) root-&gt;rc-&gt;parent=root;
	if((root-&gt;lc==NULL&amp;&amp;root-&gt;rc!=NULL)||(root-&gt;lc!=NULL&amp;&amp;root-&gt;rc==NULL)) isfull=false;
	mp[root-&gt;v]=root;
	return root;
}
bool judge(string s) {
	int a,b;
	if(s.find(&quot;root&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the root&quot;,&amp;a);
		return a==root-&gt;v;
	} else if(s.find(&quot;siblings&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d and %d are siblings&quot;,&amp;a,&amp;b);
		return mp[a]-&gt;parent==mp[b]-&gt;parent;
	} else if(s.find(&quot;parent&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the parent of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;parent==mp[a];
	} else if(s.find(&quot;left&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the left child of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;lc==mp[a]; //注意在判断时一定要判断地址是否相等， 不要判断数值，因为可能会有空地址 
	} else if(s.find(&quot;right&quot;)!=string::npos) {
		sscanf(s.c_str(),&quot;%d is the right child of %d&quot;,&amp;a,&amp;b);
		return mp[b]-&gt;rc==mp[a];
	}else if(s.find(&quot;on&quot;)!=string::npos){
		sscanf(s.c_str(),&quot;%d and %d are on the same level&quot;,&amp;a,&amp;b);
		return mp[a]-&gt;level==mp[b]-&gt;level;
	}else return isfull;
}
int main(){
	int n,m;
	string s;
	cin&gt;&gt;n;
	in.resize(n),post.reserve(n);
	for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i];
	root=create(0,n-1,0,n-1,0);
	cin&gt;&gt;m;
	getchar();//注意 
	while(m--){
		getline(cin,s);
		if(judge(s)) cout&lt;&lt;&quot;Yes\n&quot;;
		else cout&lt;&lt;&quot;No\n&quot;;
	}
	return 0;
}
</code></pre>
<h3 id="1160-20-forever-dfs回溯剪枝">1160 (20 Forever dfs+回溯剪枝)</h3>
<p>题目描述:</p>
<p>&quot;Forever number&quot; is a positive integer <em>A</em> with <em>K</em> digits, satisfying the following constrains:</p>
<ul>
<li>the sum of all the digits of <em>A</em> is <em>m</em>;</li>
<li>the sum of all the digits of <em>A</em>+1 is <em>n</em>; and</li>
<li>the greatest common divisor of <em>m</em> and <em>n</em> is a prime number which is greater than 2.</li>
</ul>
<p>Now you are supposed to find these forever numbers.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤5). Then <em>N</em> lines follow, each gives a pair of <em>K</em> (3&lt;<em>K</em>&lt;10) and <em>m</em> (1&lt;<em>m</em>&lt;90), of which the meanings are given in the problem description.</p>
<p>Output Specification:</p>
<p>For each pair of <em>K</em> and <em>m</em>, first print in a line <code>Case X</code>, where <code>X</code> is the case index (starts from 1). Then print <em>n</em> and <em>A</em> in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of <em>n</em>. If still not unique, output in the ascending order of <em>A</em>. If there is no solution, output <code>No Solution</code>.</p>
<p><strong>Sample Input:</strong></p>
<pre><code>2
6 45
7 80
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>Case 1
10 189999
10 279999
10 369999
10 459999
10 549999
10 639999
10 729999
10 819999
10 909999
Case 2
No Solution
</code></pre>
<pre><code>方法一:dfs
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct node {
	int n, A;	//n A+1各个位数之和 A求的数
};
int n,m,N,k;
vector&lt;node&gt; ans;
bool cmp(node a,node b) {	//按照n递增排序，n相同按照A递增排序
	if(a.n != b.n) return a.n &lt; b.n;
	else return a.A &lt; b.A;
}
bool isPrime(int x) {	//判断是不是大于3的素数
	if(x &lt;= 2) return false;
	for(int i = 2; i * i&lt;= x; i++)
		if(x % i == 0) return false;
	return true;
}
int gcd(int a,int b) {	//求最大公约数
	return b == 0 ? a : gcd(b,a%b);
}
int digit_sum(int A) {	//各个位数之和
	int sum = 0;
	while(A) {
		sum += A%10;
		A/=10;
	}
	return sum;
}
void DFS(int A, int sum, int rest_K) {	//A目标数 sum当前位数和 rest_k剩余k位
	if(rest_K == 0) {	//递归边界
		if(sum == m) {
			int n = digit_sum(A + 1);
			if(isPrime(gcd(m, n)))
				ans.push_back({n, A});
		}
	} else if(rest_K &gt; 0) {
		for(int i = 0; i &lt;= 9; i++) {
			//如果当前位为i，即时剩余的rest_k - 1位全部取9也无法达到m，则剪枝
			//当前位数和sum，当前位取i，已经超过了m也剪枝
			if(sum + i + (rest_K-1)*9 &gt;= m &amp;&amp; sum + i &lt;= m)
				DFS(A*10 + i, sum+i, rest_K-1);
		}
	}
}
int main() {
	scanf(&quot;%d&quot;,&amp;N);	//样例数
	for(int x = 1; x &lt;= N; x++) {
		ans.clear();
		printf(&quot;Case %d\n&quot;,x);
		scanf(&quot;%d%d&quot;,&amp;k,&amp;m);	//k A的位数， m A各位数之和
		for(int i = 1; i &lt;= 9; i++)	//i是最高位的数的取值
			DFS(i, i, k-1);
		if(ans.empty()) {
			printf(&quot;No Solution\n&quot;);
			continue;
		}
		sort(ans.begin(), ans.end(), cmp);
		for(int i = 0; i &lt; ans.size(); i++) {
			printf(&quot;%d %d\n&quot;,ans[i].n, ans[i].A);
		}
	}
	return 0;
}

方法二:数学规律
按照尾数为99的数枚举，加一不进位的话，这两个数的各位之和相差的是1，无论如何也不会有不小于三的最小公约数
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
using namespace std;
int k, n,m,a,b,c,d,num;
bool f=false;
struct node {
	int n,a;
};
int gcd(int a,int b) {
	return b==0?a:gcd(b,a%b);
}
bool isPrime(int n) {
	if(n&lt;=2)return false;
	int sq=(int)sqrt(n);
	for(int j=2; j&lt;=sq; j++) {
		if(n%j==0)return false;
	}
	return true;
}
int sum(int n) {
	return n==0? 0: n%10 + sum(n/10);
}
bool cmp(node &amp;a,node &amp;b) {
	if(a.n!=b.n)return a.n&lt;b.n;
	return a.a&lt;b.a;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++) {
		scanf(&quot;%d %d&quot;,&amp;k,&amp;m);
		printf(&quot;Case %d\n&quot;,i+1);
		a=(int)pow(10,k-3);//-3
		b=a*10;
		vector&lt;node&gt; v;
		for(int x=a; x&lt;b; x++) {
			c=x*100+99;
			d=sum(c+1);
			if(sum(c)==m &amp;&amp; isPrime(gcd(d,m))) {
				v.push_back({d,c});
			}
		}
		if(v.size()==0) printf(&quot;No Solution\n&quot;);
		else {
			sort(v.begin(),v.end(),cmp);
			for(auto it:v) {
				printf(&quot;%d %d\n&quot;,it.n,it.a);
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="116125-合并链表">1161(25 合并链表)</h3>
<p><strong>Merging Linked Lists</strong> (25分)</p>
<p>题目描述:</p>
<p>Merging Linked Lists (25分)</p>
<p>Given two singly linked lists <em>L</em>1=<em>a</em>1→<em>a</em>2→⋯→<em>a**n</em>−1→<em>a**n</em> and <em>L</em>2=<em>b</em>1→<em>b</em>2→⋯→<em>b**m</em>−1→<em>b**m</em>. If <em>n</em>≥2<em>m</em>, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like <em>a</em>1→<em>a</em>2→<em>b**m</em>→<em>a</em>3→<em>a</em>4→<em>b**m</em>−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of <em>L</em>1 and <em>L</em>2, plus a positive <em>N</em> (≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than 105, and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p>
<p>Output Specification:</p>
<p>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong></p>
<pre><code class="language-in">00100 01000 7
02233 2 34891
00100 6 00001
34891 3 10086
01000 1 02233
00033 5 -1
10086 4 00033
00001 7 -1
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code class="language-out">01000 1 02233
02233 2 00001
00001 7 34891
34891 3 10086
10086 4 00100
00100 6 00033
00033 5 -1
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100010;
struct node {
	int address,data,next;
} list[maxn];
int main() {
	int n,st1,st2;
	vector&lt;node&gt; v1,v2,v;
	scanf(&quot;%d%d%d&quot;,&amp;st1,&amp;st2,&amp;n);
	for(int i=0; i&lt;n; i++) {
		int addrs;
		scanf(&quot;%d&quot;,&amp;addrs);
		list[addrs].address=addrs;
		scanf(&quot;%d%d&quot;,&amp;list[addrs].data,&amp;list[addrs].next);
	}
	while(st1!=-1) {
		v1.push_back(list[st1]);
		st1=list[st1].next;
	}
	while(st2!=-1) {
		v2.push_back(list[st2]);
		st2=list[st2].next;
	}
	int len1=v1.size(),len2=v2.size(),index=0;
	if(len1&gt;len2) {
		reverse(v2.begin(),v2.end());
		for(int i=0; i&lt;=len1; i++) {
			if(i!=0&amp;&amp;i%2==0&amp;&amp;index&lt;len2) {
				v.push_back(v2[index++]);
			}
			if(i&lt;len1) v.push_back(v1[i]);
		}
	} else {
		reverse(v1.begin(),v1.end());
		for(int i=0; i&lt;=len2; i++) {
			if(i!=0&amp;&amp;i%2==0&amp;&amp;index&lt;len1) {
				v.push_back(v1[index++]);
			}
			if(i&lt;len2) v.push_back(v2[i]);
		}
	}
	for(int i=0;i&lt;v.size()-1;i++) printf(&quot;%05d %d %05d\n&quot;,v[i].address,v[i].data,v[i+1].address);
	printf(&quot;%05d %d -1&quot;,v[v.size()-1].address,v[v.size()-1].data);
	return 0;
}
</code></pre>
<h3 id="116225-输出树的后缀表达式">1162(25 输出树的后缀表达式)</h3>
<p><strong>Postfix Expression</strong>(25分)</p>
<p>Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <em>i</em>-th line corresponds to the <em>i</em>-th node) in the format:</p>
<pre><code>data left_child right_child
</code></pre>
<p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clxb%5CPictures%5C%E6%A0%91.png" alt="https://images.ptausercontent.com/4d1c4a98-33cc-45ff-820f-c548845681ba.JPG" loading="lazy"></figure>
<p>Output Specification:</p>
<p>For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.</p>
<p><strong>Sample Input 1:</strong></p>
<pre><code class="language-in">8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
</code></pre>
<p><strong>Sample Output 1:</strong></p>
<pre><code class="language-out">(((a)(b)+)((c)(-(d))*)*)
</code></pre>
<p><strong>Sample Input 2:</strong></p>
<pre><code class="language-in">8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
</code></pre>
<p><strong>Sample Output 2:</strong></p>
<pre><code class="language-out">(((a)(2.35)*)(-((str)(871)%))+)
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
struct node {
	string data;
	int lc,rc;
} v[21];
string ans;
void postorder(int index) {
	bool flag=false;
	if((v[index].rc!=-1&amp;&amp;v[index].lc!=-1)||(v[index].lc==-1&amp;&amp;v[index].rc!=-1)||(v[index].lc==-1&amp;&amp;v[index].rc==-1)) {
		flag=true;
		ans+=&quot;(&quot;;
	}
	if(v[index].lc==-1&amp;&amp;v[index].rc!=-1) {
		ans+=v[index].data;
		postorder(v[index].rc);
	} else {
		if(v[index].lc!=-1)postorder(v[index].lc);
		if(v[index].rc!=-1)postorder(v[index].rc);
		ans+=v[index].data;
	}
	if(flag) ans+=&quot;)&quot;;
}
int main() {
	int n,root=1,notroot[21]= {0};
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; i++) {
		cin&gt;&gt;v[i].data&gt;&gt;v[i].lc&gt;&gt;v[i].rc;
		if(v[i].lc!=-1) notroot[v[i].lc]=1;
		if(v[i].rc!=-1) notroot[v[i].rc]=1;
	}
	while(notroot[root]==1) root++;
	postorder(root);
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="116330-判断dijkst的合法路径">1163(30 判断dijkst的合法路径)</h3>
<p>Dijkstra Sequence (30分)</p>
<p>Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p>
<p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra's algorithm.</p>
<p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N**v</em> (≤103) and <em>N**e</em> (≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to <em>N**v</em>.</p>
<p>Then <em>N**e</em> lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p>
<p>Finally the number of queries, <em>K</em>, is given as a positive integer no larger than 100, followed by <em>K</em> lines of sequences, each contains a permutationof the <em>N**v</em> vertices. It is assumed that the first vertex is the source for each sequence.</p>
<p>All the inputs in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each of the <em>K</em> sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p>
<p><strong>Sample Input:</strong></p>
<pre><code class="language-in">5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code class="language-out">Yes
Yes
Yes
No
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1001;
const int INF=0x7fffffff;
int g[maxn][maxn],d[maxn],nv,ne,k,index;
bool vis[maxn];
vector&lt;int&gt; path;
bool judge(int s) {
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	d[s]=0;
	for(int i=1; i&lt;=nv; i++) {
		int u=-1,MIN=INF;
		for(int j=1; j&lt;=nv; j++) {
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN) {
				MIN=d[j];
				u=j;
			}
		}
		if(u==-1) return true;
		if(d[path[index]]==MIN&amp;&amp;vis[path[index]]==false) {
			u=path[index];
			index++;
			vis[u]=true;
		} else return false;
		for(int v=1; v&lt;=nv; v++) {
			if(vis[v]==false&amp;&amp;g[u][v]!=INF) {
				if(d[v]&gt;d[u]+g[u][v]) d[v]=d[u]+g[u][v];
			}
		}
	}
}
int main() {
	scanf(&quot;%d%d&quot;,&amp;nv,&amp;ne);
	fill(g[0],g[0]+maxn*maxn,INF);
	for(int i=0; i&lt;ne; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		scanf(&quot;%d&quot;,&amp;g[v1][v2]);
		g[v2][v1]=g[v1][v2];
	}
	scanf(&quot;%d&quot;,&amp;k);
	while(k--) {
		path.clear();
		path.resize(nv);
		for(int i=0; i&lt;nv; i++) scanf(&quot;%d&quot;,&amp;path[i]);
		index=0;
		if(judge(path[index])) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="116420-图形输出-逻辑题-注意用stringgetchar吸收换行符">1164(20 图形输出 逻辑题 注意用string，getchar吸收换行符)</h3>
<p>7-1 Good in C (20分)</p>
<p>When your interviewer asks you to write &quot;Hello World&quot; using C, can you do as the following figure shows?</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of <code>C</code>'s and <code>.</code>'s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.</p>
<p>It is guaranteed that there is at least one word given.</p>
<p>Output Specification:</p>
<p>For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.</p>
<p>Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.</p>
<p>Sample Input:</p>
<pre><code class="language-in">..C..
.C.C.
C...C
CCCCC
C...C
C...C
C...C
CCCC.
C...C
C...C
CCCC.
C...C
C...C
CCCC.
.CCC.
C...C
C....
C....
C....
C...C
.CCC.
CCCC.
C...C
C...C
C...C
C...C
C...C
CCCC.
CCCCC
C....
C....
CCCC.
C....
C....
CCCCC
CCCCC
C....
C....
CCCC.
C....
C....
C....
CCCC.
C...C
C....
C.CCC
C...C
C...C
CCCC.
C...C
C...C
C...C
CCCCC
C...C
C...C
C...C
CCCCC
..C..
..C..
..C..
..C..
..C..
CCCCC
CCCCC
....C
....C
....C
....C
C...C
.CCC.
C...C
C..C.
C.C..
CC...
C.C..
C..C.
C...C
C....
C....
C....
C....
C....
C....
CCCCC
C...C
C...C
CC.CC
C.C.C
C...C
C...C
C...C
C...C
C...C
CC..C
C.C.C
C..CC
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.CCC.
CCCC.
C...C
C...C
CCCC.
C....
C....
C....
.CCC.
C...C
C...C
C...C
C.C.C
C..CC
.CCC.
CCCC.
C...C
CCCC.
CC...
C.C..
C..C.
C...C
.CCC.
C...C
C....
.CCC.
....C
C...C
.CCC.
CCCCC
..C..
..C..
..C..
..C..
..C..
..C..
C...C
C...C
C...C
C...C
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.C.C.
..C..
C...C
C...C
C...C
C.C.C
CC.CC
C...C
C...C
C...C
C...C
.C.C.
..C..
.C.C.
C...C
C...C
C...C
C...C
.C.C.
..C..
..C..
..C..
..C..
CCCCC
....C
...C.
..C..
.C...
C....
CCCCC
HELLO~WORLD!
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">C...C CCCCC C.... C.... .CCC.
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
CCCCC CCCC. C.... C.... C...C
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
C...C CCCCC CCCCC CCCCC .CCC.

C...C .CCC. CCCC. C.... CCCC.
C...C C...C C...C C.... C...C
C...C C...C CCCC. C.... C...C
C.C.C C...C CC... C.... C...C
CC.CC C...C C.C.. C.... C...C
C...C C...C C..C. C.... C...C
C...C .CCC. C...C CCCCC CCCC.
</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;vector&gt;
using namespace std;
string a[30][10],str;
vector&lt;int&gt; word;
int main() {
	for(int i=0; i&lt;26; i++) {
		for(int j=0; j&lt;7; j++) {
			cin&gt;&gt;a[i][j];
		}
	}
	getchar();//因为cin会把换行符留在缓冲区，所以这里要将换行符忽略掉
	getline(cin,str);
	bool flag=false;
	for(int i=0; i&lt;str.size(); i++) {
		if(isupper(str[i]) &amp;&amp; i==str.size()-1)
			word.push_back(str[i]-'A');
		if(isupper(str[i]) &amp;&amp; i!=str.size()-1) {
			word.push_back(str[i]-'A');
		} else {
			if(word.size()==0) cout&lt;&lt;&quot;&quot;;
			else {
				if(flag) cout&lt;&lt;endl&lt;&lt;endl;
				for(int k=0; k&lt;7; k++) {
					for(int j=0; j&lt;word.size(); j++) {
						if(j!=0) cout&lt;&lt;&quot; &quot;;
						cout&lt;&lt;a[word[j]][k];
						flag=true;
					}
					if(k!=6)cout&lt;&lt;endl;
				}
				word.clear();
			}
		}
	}
	return 0;
}
</code></pre>
<h3 id="116525-链表分段拼接">1165(25 链表分段拼接)</h3>
<p>Given a singly linked list <em>L</em>. Let us consider every <em>K</em> nodes as a <strong>block</strong> (if there are less than <em>K</em> nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in <em>L</em>. For example, given <em>L</em> as 1→2→3→4→5→6→7→8 and <em>K</em> as 3, your output must be 7→8→4→5→6→1→2→3.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p>Output Specification:</p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p>Sample Input:</p>
<pre><code class="language-in">00100 8 3
71120 7 88666
00000 4 99999
00100 1 12309
68237 6 71120
33218 3 00000
99999 5 68237
88666 8 -1
12309 2 33218
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">71120 7 88666
88666 8 00000
00000 4 99999
99999 5 68237
68237 6 00100
00100 1 12309
12309 2 33218
33218 3 -1
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct node{
	int addrs,data,next;
}list[100000];
int main(){
	int st,n,k,cnt,len;
	scanf(&quot;%d%d%d&quot;,&amp;st,&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++){
		int addrs;
		scanf(&quot;%d&quot;,&amp;addrs);
		list[addrs].addrs=addrs;
		scanf(&quot;%d%d&quot;,&amp;list[addrs].data,&amp;list[addrs].next);
	}
	vector&lt;node&gt; v;
	while(st!=-1){
		v.push_back(list[st]);
		st=list[st].next;
	}
	if(v.size()%k==0) cnt=v.size()/k;
	else cnt=v.size()/k+1;
	int pos;
	for(int i=0;i&lt;cnt;i++){
		int j,x;
		if(i==0) j=v.size()-(cnt-1)*k;
		else j=k;
		if(i==0) pos=v.size()-j;
		for(x=pos;x&lt;pos+j-1;x++) printf(&quot;%05d %d %05d\n&quot;,v[x].addrs,v[x].data,v[x+1].addrs);
		pos-=k;
		if(pos&lt;0) printf(&quot;%05d %d -1\n&quot;,v[x].addrs,v[x].data);
		else printf(&quot;%05d %d %05d\n&quot;,v[x].addrs,v[x].data,v[pos].addrs);
	}
	return 0;
}
</code></pre>
<h3 id="116625-图">1166(25 图)</h3>
<p>7-3 Summit (25分)</p>
<p>A <strong>summit</strong> (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone.</p>
<p>Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N.</p>
<p>Then there is another positive integer K (≤ 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (≤ N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each of the K areas, print in a line your advice in the following format:</p>
<ul>
<li>if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print <code>Area X is OK.</code>.</li>
<li>if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print <code>Area X may invite more people, such as H.</code> where <code>H</code> is the smallest index of the head who may be invited.</li>
<li>if in this area the arrangement is not an ideal one, then print <code>Area X needs help.</code> so the host can provide some special service to help the heads get to know each other.</li>
</ul>
<p>Here <code>X</code> is the index of an area, starting from 1 to <code>K</code>.</p>
<p>Sample Input:</p>
<pre><code class="language-in">8 10
5 6
7 8
6 4
3 6
4 5
2 3
8 2
2 7
5 3
3 4
6
4 5 4 3 6
3 2 8 7
2 2 3
1 1
2 4 6
3 3 2 1
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">Area 1 is OK.
Area 2 is OK.
Area 3 is OK.
Area 4 is OK.
Area 5 may invite more people, such as 3.
Area 6 needs help.
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=205;
int main() {
	int n,m,g[maxn][maxn],k,num,vis[maxn];
	fill(g[0],g[0]+maxn*maxn,0);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=0; i&lt;m; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		g[v1][v2]=g[v2][v1]=1;
	}
	scanf(&quot;%d&quot;,&amp;k);
	for(int i=1; i&lt;=k; i++) {
		fill(vis,vis+maxn,false);
		scanf(&quot;%d&quot;,&amp;num);
		vector&lt;int&gt; v(num);
		int flag=1;
		for(int j=0; j&lt;num; j++) {
			scanf(&quot;%d&quot;,&amp;v[j]);
			vis[v[j]]=true;
		}
		for(int j=0; j&lt;num-1; j++) {
			for(int x=j+1; x&lt;num; x++) {
				if(flag==0) break;
				if(g[v[j]][v[x]]!=1) {
					flag=0;
					break;
				}
			}
		}
		if(flag==0) {
			printf(&quot;Area %d needs help.\n&quot;,i);
			continue;
		} else {
			for(int j=1; j&lt;=n; j++) {
				if(vis[j]==false) {
					int x;
					for(x=0; x&lt;v.size(); x++) {
						if(g[v[x]][j]==0) break;
					}
					if(x==v.size()) {
						printf(&quot;Area %d may invite more people, such as %d.\n&quot;,i,j);
						flag=0;
						break;
					}
				}
			}
			if(flag==1) printf(&quot;Area %d is OK.\n&quot;,i);
		}
	}
	return 0;
}
</code></pre>
<h3 id="116730-用中序遍历序列建立堆树">1167(30 用中序遍历序列建立“堆”树)</h3>
<p>7-4 Cartesian Tree (30分)</p>
<p>A <strong>Cartesian tree</strong> is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.</p>
<figure data-type="image" tabindex="2"><img src="https://images.ptausercontent.com/6a99f68a-6578-46e0-9232-fbf0adf3691f.jpg" alt="CTree.jpg" loading="lazy"></figure>
<p>Your job is to output the level-order traversal sequence of the min-heap Cartesian tree.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts from giving a positive integer <em>N</em> (≤30), and then <em>N</em> distinct numbers in the next line, separated by a space. All the numbers are in the range of <strong>int</strong>.</p>
<p>Output Specification:</p>
<p>For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
8 15 3 4 1 5 12 10 18 6
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">1 3 5 8 4 6 15 10 12 18
</code></pre>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node {
	int v;
	node*lc,*rc;
};
int n,v[31],num=0;
node*create(int inl,int inr) {
	if((inl&gt;inr)||inl&lt;0||inr&gt;=n) return NULL;
	node*root=new node;
	int *addrs=min_element(v+inl,v+inl+(inr-inl+1));
	int index=addrs-v;
	root-&gt;lc=create(inl,index-1);
	root-&gt;v=v[index];
	root-&gt;rc=create(index+1,inr);
	return root;
}
void levelorder(node*root) {
	queue&lt;node*&gt;q;
	q.push(root);
	while(!q.empty()) {
		node*t=q.front();
		q.pop();
		if(num!=0) printf(&quot; &quot;);
		printf(&quot;%d&quot;,t-&gt;v);
		num++;
		if(t-&gt;lc!=NULL) q.push(t-&gt;lc);
		if(t-&gt;rc!=NULL) q.push(t-&gt;rc);
	}
}
int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;v[i]);
	node*root=create(0,n-1);
	levelorder(root);
	return 0;
}
</code></pre>
<h3 id="1168-prime-day">1168  Prime Day</h3>
<figure data-type="image" tabindex="3"><img src="C:%5CUsers%5Clxb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200829143952987.png" alt="image-20200829143952987" loading="lazy"></figure>
<p>The above picture is from Sina Weibo, showing May 23rd, 2019 as a very cool “Prime Day”. That is, not only that the corresponding number of the date 20190523 is a prime, but all its sub-strings ended at the last digit 3 are prime numbers.</p>
<p>Now your job is to tell if a given date is a Prime Day.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, a date between January 1st, 0001 and December 31st, 9999 is given, in the format yyyymmdd.</p>
<p><strong>Output Specification:</strong></p>
<p>For each given date, output in the decreasing order of the length of the substrings, each occupies a line. In each line, print the string first, followed by a space, then Yes if it is a prime number, or No if not. If this date is a Prime Day, print in the last line All Prime!.</p>
<p><strong>Sample Input 1:</strong></p>
<p>20190523</p>
<p><strong>Sample Output 1:</strong></p>
<pre><code>20190523 Yes
0190523 Yes
190523 Yes
90523 Yes
0523 Yes
523 Yes
23 Yes
3 Yes
All Prime!
Sample Input 2:
20191231
Sample Output 2:
20191231 Yes
0191231 Yes
191231 Yes
91231 No
1231 Yes
231 No
31 Yes
1 No
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt; 
using namespace std;
bool isprime(int n){
	if(n&lt;=1) return false;
	int sqr=sqrt(n*1.0);
	for(int i=2;i&lt;=sqr;i++){
		if(n%i==0) return false;
	}
	return true;
}
int main(){
	string s;
	cin&gt;&gt;s;
	int flag=1;
	while(s.length()&gt;0){
		int t=stoi(s);
		cout&lt;&lt;s&lt;&lt;&quot; &quot;;
		if(isprime(t)) printf(&quot;Yes\n&quot;);
		else {
			flag=0;
			printf(&quot;No\n&quot;);
		}
		s.erase(s.begin());
	}
	if(flag) printf(&quot;All Prime!&quot;);
	return 0; 
}
</code></pre>
<h3 id="1169-the-judger">1169 The Judger</h3>
<p>A game of numbers has the following rules: at the beginning, two distinct positive integers are given by the judge. Then each player in turn must give a number to the judge. The number must be the difference of two numbers that are previously given, and must not be duplicated to any of the existed numbers. The game will run for several rounds. The one who gives a duplicate number or even a wrong number will be kicked out.</p>
<p>Your job is to write a judger program to judge the players' numbers and to determine the final winners.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two distinct positive integers to begin with. Both numbers are in [1,10^5 ].</p>
<p>In the second line, two numbers are given: N (2≤N≤10), the number of players, and M (2≤M≤10^3), the number of rounds.</p>
<p>Then N lines follow, each contains M positive integers. The i-th line corresponds to the i-th player (i=1,⋯,N). The game is to start from the 1st player giving his/her 1st number, followed by everybody else giving their 1st numbers in the 1st round; then everyone give their 2nd numbers in the 2nd round, and so on so forth.</p>
<p>Output Specification:</p>
<p>If the i-th player is kicked out in the k-th round, print in a line Round #k: i is out.. The rest of the numbers given by the one who is out of the game will be ignored. If more than one player is out in the same round, print them in increasing order of their indices. When the game is over, print in the last line Winner(s): W1 W2 ... Wn, where W1 ... Wn are the indices of the winners in increasing order. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. If there is no winner, print No winner. instead.</p>
<p>Sample Input 1:</p>
<pre><code>101 42
4 5
59 34 67 9 7
17 9 8 50 7
25 92 43 26 37
76 51 1 41 40
</code></pre>
<p>Sample Output 1:</p>
<pre><code>Round #4: 1 is out.
Round #5: 3 is out.
Winner(s): 2 4
</code></pre>
<p>Sample Input 2:</p>
<pre><code>42 101
4 5
59 34 67 9 7
17 9 18 50 49
25 92 58 1 39
102 32 2 6 41
</code></pre>
<p>Sample Output 2:</p>
<pre><code>Round #1: 4 is out.
Round #3: 2 is out.
Round #4: 1 is out.
Round #5: 3 is out.
No winner.
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n1,n2,n,m,isout[12]= {0},v[12][1005]= {0},exist[200010]= {0};
	vector&lt;int&gt; win,ex;
	scanf(&quot;%d%d%d%d&quot;,&amp;n1,&amp;n2,&amp;n,&amp;m);
	for(int i=1; i&lt;=n; i++) {
		for(int j=1; j&lt;=m; j++) {
			scanf(&quot;%d&quot;,&amp;v[i][j]);
		}
	}
	ex.push_back(n1);
	ex.push_back(n2);
	exist[n1]=1;
	exist[n2]=1;
	for(int j=1; j&lt;=m; j++) {
		for(int i=1; i&lt;=n; i++) {
			int flag=0;
			if(isout[i]==1) continue;
			if(exist[v[i][j]]==1) {
				isout[i]=1;
				printf(&quot;Round #%d: %d is out.\n&quot;,j,i);
				continue;
			}
			for(int k=0; k&lt;ex.size(); k++) {
				if(exist[v[i][j]+ex[k]]==1) {
					flag=1;
					break;
				}
			}
			if(flag==0) {
				isout[i]=1;
				printf(&quot;Round #%d: %d is out.\n&quot;,j,i);
				continue;
			}
			exist[v[i][j]]=1;
			ex.push_back(v[i][j]);
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		if(isout[i]==0) win.push_back(i);
	}
	if(win.size()==0) printf(&quot;No winner.\n&quot;);
	else{
		printf(&quot;Winner(s):&quot;);
		for(int i=0;i&lt;win.size();i++) printf(&quot; %d&quot;,win[i]);
	}
	return 0;
}
</code></pre>
<h3 id="1170-safari-park">1170 Safari Park</h3>
<p>A safari park（野生动物园）has K species of animals, and is divided into N regions. The managers hope to spread the animals to all the regions, but not the same animals in the two neighboring regions. Of course, they also realize that this is an NP complete problem, you are not expected to solve it. Instead, they have designed several distribution plans. Your job is to write a program to help them tell if a plan is feasible.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives 3 integers: N (0&lt;N≤500), the number of regions; R (≥0), the number of neighboring relations, and K (0&lt;K≤N), the number of species of animals. The regions and the species are both indexed from 1 to N.</p>
<p>Then R lines follow, each gives the indices of a pair of neighboring regions, separated by a space.</p>
<p>Finally there is a positive M (≤20) followed by M lines of distribution plans. Each plan gives N indices of species in a line (the i-th index is the animal in the i-th rigion), separated by spaces. It is guaranteed that any pair of neighboring regions must be different, and there is no duplicated neighboring relations.</p>
<p>Output Specification:</p>
<p>For each plan, print in a line Yes if no animals in the two neighboring regions are the same, or No otherwise. However, if the number of species given in a plan is not K, you must print Error: Too many species. or Error: Too few species. according to the case.</p>
<p>Sample Input:</p>
<pre><code>6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
5
1 2 3 3 1 2
1 2 3 4 5 6
4 5 6 6 4 5
2 3 4 2 3 4
2 2 2 2 2 2
</code></pre>
<p>Sample Output:</p>
<pre><code>Yes
Error: Too many species.
Yes
No
Error: Too few species.
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n,r,k,m;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;r,&amp;k);
	vector&lt;int&gt; v[r];
	for(int i=0; i&lt;r; i++) {
		int v1,v2;
		scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);
		v[i].push_back(v1);
		v[i].push_back(v2);
	}
	scanf(&quot;%d&quot;,&amp;m);
	for(int i=0; i&lt;m; i++) {
		int g[510],flag=1;
		set&lt;int&gt;s;
		for(int j=1; j&lt;=n; j++) {
			scanf(&quot;%d&quot;,&amp;g[j]);
			s.insert(g[j]);
		}
		if(s.size()&gt;k) {
			printf(&quot;Error: Too many species.\n&quot;);
			continue;
		} else if(s.size()&lt;k) {
			printf(&quot;Error: Too few species.\n&quot;);
			continue;
		}
		for(int j=0; j&lt;r; j++) {
			if(g[v[j][0]]==g[v[j][1]]) {
				flag=0;
				printf(&quot;No\n&quot;);
				break;
			}
		}
		if(flag==1) printf(&quot;Yes\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="1171-replacement-selection">1171 <strong>Replacement Selection</strong></h3>
<p>When the input is much too large to fit into memory, we have to do <strong>external sorting</strong> instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called <strong>runs</strong>) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.</p>
<p><strong>Replacement Selection</strong> sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.</p>
<p>For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the <strong>first run</strong>. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.</p>
<p>Your job is to implement this replacement selection algorithm.</p>
<p>Input Specification:</p>
<p>Each input file contains several test cases. The first line gives two positive integers <em>N</em> (≤105) and <em>M</em> (&lt;<em>N</em>/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then <em>N</em> numbers are given in the next line, all in the range of <strong>int</strong>. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">13 3
81 94 11 96 12 99 17 35 28 58 41 75 15
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">11 81 94 96 99
12 17 28 35 41 58 75
15
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	vector&lt;int&gt; v;
	for(int i=0; i&lt;n; i++) {
		int temp;
		scanf(&quot;%d&quot;,&amp;temp);
		v.push_back(temp);
	}
	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
	int index=0,count=0,TOP;
	vector&lt;int&gt;temp,ans;
	while(index&lt;m) q.push(v[index++]);
	while(count!=n) {
		TOP=q.top();
		ans.push_back(TOP);
		q.pop();
		count++;
		if(index&lt;n) {
			if(v[index]&gt;TOP) q.push(v[index++]);
			else temp.push_back(v[index++]);
		}
		if(q.empty()) {
			for(int i=0; i&lt;ans.size(); i++) {
				if(i&gt;0) printf(&quot; &quot;);
				printf(&quot;%d&quot;,ans[i]);
			}
			printf(&quot;\n&quot;);
			ans.clear();
			for (int i = 0; i &lt; temp.size(); i++)//v的数全都放到q里
				q.push(temp[i]);
			temp.clear();
		}

	}
	return 0;
}
</code></pre>
<h3 id="1172-2020-秋季panda-and-pp-milk20">1172 2020 秋季<strong>Panda and PP Milk</strong>（20）</h3>
<figure data-type="image" tabindex="4"><img src="https://images.ptausercontent.com/6049de68-39dd-4707-b952-a73f5049153c.jpg" alt="panda.jpg" loading="lazy"></figure>
<p>PP milk （盆盆奶）is Pandas' favorite. They would line up to enjoy it as show in the picture. On the other hand, they could drink in peace only if they believe that the amount of PP milk is fairly distributed, that is, fatter panda can have more milk, and the ones with equal weight may have the same amount. Since they are lined up, each panda can only compare with its neighbor(s), and if it thinks this is unfair, the panda would fight with its neighbor.</p>
<p>Given that the minimum amount of milk a panda must drink is 200 ml. It is only when another bowl of milk is at least 100 ml more than its own that a panda can sense the difference.</p>
<p>Now given the weights of a line of pandas, your job is to help the breeder（饲养员）to decide the minimum total amount of milk that he/she must prepare, provided that the pandas are lined up in the given order.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, first a positive integer <em>n</em> (≤104) is given as the number of pandas. Then in the next line, <em>n</em> positive integers are given as the weights (in kg) of the pandas, each no more than 200. the numbers are separated by spaces.</p>
<p>Output Specification:</p>
<p>For each test case, print in a line the minimum total amount of milk that the breeder must prepare, to make sure that all the pandas can drink in peace.</p>
<p>Sample Input:</p>
<pre><code class="language-in">10
180 160 100 150 145 142 138 138 138 140
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">3000
</code></pre>
<p>Hint:</p>
<p>The distribution of milk is the following:</p>
<pre><code>400 300 200 500 400 300 200 200 200 300
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main() {
	int  n,ans=0;
	cin&gt;&gt;n;
	vector&lt;int&gt; v,num,num1;
	v.resize(n),num.resize(n),num1.resize(n);
	for(int i=0; i&lt;n; i++) cin&gt;&gt;v[i];
	num[0]=200;
	for(int i=1; i&lt;n; i++) {
		if(v[i]&gt;v[i-1]) num[i]=num[i-1]+100;
		else num[i]=200;
	}
	num1[n-1]=200;
	ans+=num[n-1];
	for(int i=n-2; i&gt;=0; i--) {
		if(v[i]&gt;v[i+1]) 	num1[i]=num1[i+1]+100;
		else	num1[i]=200;
		if(num[i]&gt;num1[i]) ans+=num[i];
		else ans+=num1[i];
	}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
<h3 id="1173-7-2-how-many-ways-to-buy-a-piece-of-land-25分">1173 <strong>7-2</strong> <strong>How Many Ways to Buy a Piece of Land</strong>  (25分)</h3>
<p>The land is for sale in CyberCity, and is divided into several pieces. Here it is assumed that each piece of land has exactly two neighboring pieces, except the first and the last that have only one. One can buy several contiguous（连续的） pieces at a time. Now given the list of prices of the land pieces, your job is to tell a customer in how many different ways that he/she can buy with a certain amount of money.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case first gives in a line two positive integers: <em>N</em> (≤104), the number of pieces of the land (hence the land pieces are numbered from 1 to <em>N</em> in order), and <em>M</em> (≤109), the amount of money that your customer has.</p>
<p>Then in the next line, <em>N</em> positive integers are given, where the <em>i</em>-th one is the price of the <em>i</em>-th piece of the land.</p>
<p>It is guaranteed that the total price of the land is no more than 109.</p>
<p>Output Specification:</p>
<p>For each test case, print the number of different ways that your customer can buy. Notice that the pieces must be contiguous.</p>
<p>Sample Input:</p>
<pre><code class="language-in">5 85
38 42 15 24 9
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">11
</code></pre>
<p>Hint:</p>
<p>The 11 different ways are:</p>
<pre><code>38
42
15
24
9
38 42
42 15
42 15 24
15 24
15 24 9
24 9
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int n,mon,ans=0;
	cin&gt;&gt;n&gt;&gt;mon;
	vector&lt;int&gt; sum(n+1,0);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;sum[i];
		sum[i]+=sum[i-1];
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=i;j&lt;=n;j++){
			if(sum[j]-sum[i-1]&lt;=mon) ans++;
			else break;
		}
	}
	cout&lt;&lt;ans;
}
</code></pre>
<h3 id="1174-left-view-of-binary-tree-25分">1174 <strong>Left-View of Binary Tree</strong> (25分)</h3>
<p>The <strong>left-view</strong> of a binary tree is a list of nodes obtained by looking at the tree from left hand side and from top down. For example, given a tree shown by the figure, its left-view is { 1, 2, 3, 4, 5 }</p>
<figure data-type="image" tabindex="5"><img src="https://images.ptausercontent.com/d995df0a-31ea-4659-9f26-7bcd03ee23da.JPG" alt="fig.JPG" loading="lazy"></figure>
<p>Given the inorder and preorder traversal sequences of a binary tree, you are supposed to output its left-view.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20), which is the total number of nodes in the tree. Then given in the following 2 lines are the inorder and preorder traversal sequences of the tree, respectively. All the keys in the tree are distinct positive integers in the range of <strong>int</strong>.</p>
<p>Output Specification:</p>
<p>For each case, print in a line the left-view of the tree. All the numbers in a line are separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>
<p>Sample Input:</p>
<pre><code class="language-in">8
2 3 1 5 4 7 8 6
1 2 3 6 7 4 5 8
</code></pre>
<p>Sample Output:</p>
<pre><code class="language-out">1 2 3 4 5
</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,maxdepth=-1;
vector&lt;int&gt; level[22];
struct node{
	int v;
	node *lc,*rc;
};
vector&lt;int&gt; in,pre;
void dfs(node *root,int depth){
	if(root==NULL) {
		if(depth&gt;maxdepth) maxdepth=depth;
		return;
	}
	level[depth].push_back(root-&gt;v);
	dfs(root-&gt;lc,depth+1);
	dfs(root-&gt;rc,depth+1);
}
node* create(int prel,int prer,int inl,int inr){
	if(prel&gt;prer) return NULL;
	node *root=new node;
	root-&gt;v=pre[prel];
	int k=inl;
	while(in[k]!=root-&gt;v&amp;&amp;k&lt;=inr) k++;
	int leftnum=k-inl;
	root-&gt;lc=create(prel+1,prel+leftnum,inl,k-1);
	root-&gt;rc=create(prel+leftnum+1,prer,k+1,inr);
	return root;
}
int main(){
	cin&gt;&gt;n;
	in.resize(n);
	pre.resize(n);
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;in[i];
	}
	for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];
	node*root=create(0,n-1,0,n-1);
	dfs(root,1);
	for(int i=1;i&lt;maxdepth;i++){
		if(i&gt;1) printf(&quot; &quot;);
		printf(&quot;%d&quot;,level[i][0]);
	}
	return 0;
}
</code></pre>
<h3 id="1175-professional-ability-test-30分">1175  <strong>Professional Ability Test</strong> (30分)</h3>
<p>Professional Ability Test (PAT) consists of several series of subject tests. Each test is divided into several levels. Level A is a <strong>prerequisite (前置要求)</strong> of Level B if one must pass Level A with a score no less than <em>S</em> in order to be qualified to take Level B. At the mean time, one who passes Level A with a score no less than <em>S</em> will receive a voucher（代金券）of <em>D</em> yuans (Chinese dollar) for taking Level B.</p>
<p>At the moment, this PAT is only in design and hence people would make up different plans. A plan is <strong>NOT</strong> consistent if there exists some test T so that T is a prerequisite of itself. Your job is to test each plan and tell if it is a consistent one, and at the mean time, find the easiest way (with minimum total <em>S</em>) to obtain the certificate of any subject test. If the easiest way is not unique, find the one that one can win the maximum total value of vouchers.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (≤1000) and <em>M</em>, being the total numbers of tests and prerequisite relations, respectively. Then <em>M</em> lines follow, each describes a prerequisite relation in the following format:</p>
<pre><code>T1 T2 S D
</code></pre>
<p>where <code>T1</code> and <code>T2</code> are the indices (from 0 to <em>N</em>−1) of the two distinct tests; <code>S</code> is the minimum score (in the range (0, 100]) required to pass <code>T1</code> in order to be qualified to take <code>T2</code>; and <code>D</code> is the value of the voucher (in the range (0, 500]) one can receive if one passes <code>T1</code> with a score no less than <code>S</code> and plan to take <code>T2</code>. It is guaranteed that at most one pair of <code>S</code> and <code>D</code> are defined for a prerequisite relation.</p>
<p>Then another positive integer <em>K</em> (≤<em>N</em>) is given, followed by <em>K</em> queries of tests. All the numbers in a line are separated by spaces.</p>
<p>Output Specification:</p>
<p>Print in the first line <code>Okay.</code> if the whole plan is consistent, or <code>Impossible.</code> if not.</p>
<p>If the plan is consistent, for each query of test <code>T</code>, print in a line the easiest way to obtain the certificate of this test, in the format:</p>
<pre><code>T0-&gt;T1-&gt;...-&gt;T
</code></pre>
<p>However, if <code>T</code> is the first level of some subject test (with no prerequisite), print <code>You may take test T directly.</code> instead.</p>
<p>If the plan is impossible, for each query of test <code>T</code>, check if one can take it directly or not. If the answer is yes, print in a line <code>You may take test T directly.</code>; or print <code>Error.</code> instead.</p>
<p>Sample Input 1:</p>
<pre><code class="language-in">8 15
0 1 50 50
1 2 20 20
3 4 90 90
3 7 90 80
4 5 20 20
7 5 10 10
5 6 10 10
0 4 80 60
3 1 50 45
1 4 30 20
1 5 50 20
2 4 10 10
7 2 10 30
2 5 30 20
2 6 40 60
8
0 1 2 3 4 5 6 7
</code></pre>
<p>Sample Output 1:</p>
<pre><code class="language-out">Okay.
You may take test 0 directly.
0-&gt;1
0-&gt;1-&gt;2
You may take test 3 directly.
0-&gt;1-&gt;2-&gt;4
0-&gt;1-&gt;2-&gt;4-&gt;5
0-&gt;1-&gt;2-&gt;6
3-&gt;7
</code></pre>
<p>Sample Input 2:</p>
<pre><code class="language-in">4 5
0 1 1 10
1 2 2 10
3 0 4 10
3 2 5 10
2 0 3 10
2
3 1
</code></pre>
<p>Sample Output 2:</p>
<pre><code class="language-out">Impossible.
You may take test 3 directly.
Error.
</code></pre>
<pre><code>
</code></pre>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      lxb&#39;blog
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://liuxbo.github.io/post/2019-nian-pat-chun-qiu-dong-zhen-ti/" title="PAT2019春、秋、冬，2020春、秋真题">PAT2019春、秋、冬，2020春、秋真题</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="PAT题型总结" href="https://liuxbo.github.io/post/pat-ti-xing-zong-jie/">PAT题型总结</a>
        <a class="nav-mobile-next" title="PAT题型总结" href="https://liuxbo.github.io/post/pat-ti-xing-zong-jie/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="\media\images\custom-bgImg.png" />
    </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>