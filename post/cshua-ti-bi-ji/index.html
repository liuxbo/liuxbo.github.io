<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="菜鸡成长之路">
<meta name="theme-color" content="#000">
<title>c++刷题笔记 | lxb&#39;blog</title>
<link rel="shortcut icon" href="https://liuxbo.github.io/favicon.ico?v=1588817571740">
<link rel="stylesheet" href="https://liuxbo.github.io/styles/main.css">

<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css" rel="stylesheet">  

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <meta name="description" content="c++刷题笔记" />
    <meta name="keywords" content="c++" />
  </head>
  <body>
    <div class="head-top-line"></div>
    <div class="header-box">
      
<div class=" gemini">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>lxb&#39;blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">左手蓝银右手锤</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            <li class="nav-item ">
              
                <a href="/">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/archives">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/tags">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            <li class="nav-item ">
              
                <a href="/post/about">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          <li class="nav-item">
            <a>
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
    </div>
    <div class="main-continer">
      
      <div class="section-layout gemini ">
        <div class="section-layout-wrapper">
          

<div class="sidebar">
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          <div class="post-side-meta" id="post_side_meta">
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="https://liuxbo.github.io/images/avatar.png"/>
    <p class="site-author-name">lxb&#39;blog</p>
    <p class="site-description right-motion">铅华洗尽</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  


</div>
          </div>
          <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
            <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto" id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-c%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%840%E9%97%AE%E9%A2%98">1. c++字符串数组的\0问题</a></li>
<li><a href="#2%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">2.数组相关问题</a></li>
<li><a href="#3%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98">3.字符串问题</a></li>
<li><a href="#4%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C-%E5%90%8E%E5%BA%8F%E6%88%96%E5%85%88%E5%BA%8F%E6%88%96%E5%B1%82%E5%BA%8F-%E6%90%AD%E9%85%8D-%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91">4.中序序列和 后序或先序或层序 搭配， 确定一棵二叉树</a></li>
<li><a href="#5-%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98hash-map-%E6%95%A3%E5%88%97">5. 映射问题(hash 、map、散列...)</a></li>
<li><a href="#6-stl%E5%AE%B9%E5%99%A8">6. <code>STL</code>容器</a></li>
<li><a href="#7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98">7. 输入输出问题</a></li>
<li><a href="#8-%E6%8F%90%E5%8F%96%E6%95%B0%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0">8. 提取数中的元素</a></li>
<li><a href="#9-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">9. 常用函数</a></li>
<li><a href="#10%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">10.进制转换</a></li>
<li><a href="#11-ascll-%E7%A0%81%E8%A1%A8">11. <code>ASCLL</code> 码表</a></li>
<li><a href="#12%E5%9B%9E%E6%96%87%E4%B8%B2">12.回文串</a></li>
<li><a href="#13%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">13.数字、字符数组相互转换</a></li>
<li><a href="#14-%E6%8E%92%E5%BA%8F-%E6%89%BE%E6%9C%80%E5%80%BC">14 排序、找最值</a></li>
<li><a href="#15-%E8%AE%A1%E7%AE%97%E6%97%B6%E9%95%BF">15 计算时长</a></li>
<li><a href="#16%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98">16.数据类型问题</a></li>
<li><a href="#17%E6%A0%88-%E9%98%9F%E5%88%97-%E9%93%BE%E8%A1%A8">17.栈、队列、链表</a></li>
<li><a href="#18%E8%B4%AA%E5%BF%83">18.贪心</a></li>
<li><a href="#19-%E4%BA%8C%E5%88%86">19 二分</a></li>
<li><a href="#20-two-points">20 two points</a></li>
<li><a href="#21-%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98">21 数学问题</a></li>
<li><a href="#22%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F">22.入门模拟</a></li>
<li><a href="#23%E6%8A%80%E5%B7%A7-%E9%80%BB%E8%BE%91">23.技巧、逻辑</a></li>
<li><a href="#24-dfs-bfs">24 DFS BFS</a></li>
<li><a href="#25-%E6%A0%91">25 树</a></li>
<li><a href="#26-%E5%B9%B6%E6%9F%A5%E9%9B%86">26 并查集</a></li>
<li><a href="#27-%E5%9B%BE">27 图</a></li>
<li><a href="#28-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">28 动态规划</a></li>
<li><a href="#29-%E5%88%86%E5%9D%97-%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98">29 分块  (实时查询问题)</a></li>
<li><a href="#30-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84bit-%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2">30 树状数组(BIT) (实时查询)</a></li>
<li><a href="#31-%E5%8F%AF%E6%80%95%E6%A8%A1%E6%8B%9F">31 可怕模拟</a></li>
<li><a href="#32-n%E7%9A%87%E5%90%8E">32 n皇后</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>

  </div>
</div>

<script>

let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1; 
let active = 'active-show', activeClass = 'active-current';
let tocWrapper = document.querySelector('#toc_wrapper');
let tocContent = tocWrapper.children[0];
let autoNumber = tocWrapper&&tocWrapper.classList.contains('auto-number');

function addTocNumber(elem, deep) {
  if (!elem) {
    return;
  }
  let prop = elem.__proto__;

  if (prop === HTMLUListElement.prototype) {
    for (let i = 0; i < elem.children.length; i++) {
      addTocNumber(elem.children[i], deep + (i + 1) + '.');
    }
  } else if (prop === HTMLLIElement.prototype) {
    // 保存li元素
    lList.push(elem);
    for (let i = 0; i < elem.children.length; i++) {
      let cur = elem.children[i];
      if (cur.__proto__ === HTMLAnchorElement.prototype) {
        if (autoNumber) {
          cur.text =  deep + ' ' + cur.text;
        }
      } else if (cur.__proto__ === HTMLUListElement.prototype) {
        addTocNumber(cur, deep);
      }
    }
  }
}


document.addEventListener('scroll', function(e) {
  if (lList.length <= 0) {
    return;
  }
  let scrollTop = document.scrollingElement.scrollTop;
  let dir;

  if (lastTop - scrollTop > 0) {
    dir = 'up';
  } else {
    dir = 'down';
  }

  lastTop = scrollTop;
  if (scrollTop <= 0) {
    if (lastIndex >= 0 && lastIndex < hList.length) {
      lList[lastIndex].classList.remove(activeClass);
    }
    return;
  }

  let current = 0, hasFind = false;
  for (let i = 0; i < hList.length; i++) {
    if (hList[i].offsetTop > scrollTop) {
      current = i;
      hasFind = true;
      break;
    }
  }
  if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
    current = hList.length - 1;
  } else {
    current--;
  }
  if (dir === 'down') {
    if (current > lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex) 
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  } else {
    if (current < lastIndex) {
      addActiveClass(current);
      removeActiveClass(lastIndex);
      lastIndex = current;
      removeParentActiveClass();
      lList[current] && addActiveLiElemment(lList[current].parentElement,tocContent);
    }
  }
});

function removeParentActiveClass() {
  let parents = tocContent.querySelectorAll('.'+active)
  parents.forEach(function(elem) {
    elem.classList.remove(active);
  });
}

function addActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.add(activeClass);
  }
}

function removeActiveClass(index) {
  if (index >= 0 && index < hList.length) {
    lList[index].classList.remove(activeClass);
  }
}

function addActiveLiElemment(elem, parent) {
  if (!elem || elem === parent) {
    return;
  } else {
    if (elem.__proto__ === HTMLLIElement.prototype) {
      elem.classList.add(active);
    }
    addActiveLiElemment(elem.parentElement, parent);
  }
}

function showToc() {
  if (tocWrapper) {
    postBody = document.querySelector('#post_body');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        hList.push(postBody.children[i]);
      }
    }
    if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
    } else if (tocWrapper.classList.contains('no_compress')){
      tocContent.classList.add('expanded');
    } else {
      if (hList.length > 10) {
        active = 'active-hidden'
        tocContent.classList.add('closed');
      } else {
        tocContent.classList.add('expanded');
      }
    }
  }
}
addTocNumber(tocContent, '');

window.addEventListener('load', function() {
  showToc();
  document.querySelector('#sidebar').style='display: block;';
  tocWrapper.classList.add('toc-active');
  setTimeout(function() {
    if ("createEvent" in document) {
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("scroll", false, true);
      document.dispatchEvent(evt);
    }
    else {
      document.fireEvent("scroll");
    }
  }, 500)
})

</script>
          </div>
        
      </div>
    </div>
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });


  if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
    let hasFix = false;
    let scrollEl = document.querySelector('.main-continer');
    let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
    window.addEventListener('scroll', function(e) {
    if (document.scrollingElement.scrollTop >= limitTop) {
      if (!hasFix) {
        sidebar.classList.add('sidebar-fixed');
        hasFix = true;
      }
    } else {
      if (hasFix) {
        sidebar.classList.remove('sidebar-fixed');
        hasFix = false;
      }
    }
  });
  }
  
</script>
          <div class="section-box box-shadow-wrapper">
            <div class="section bg-color post post-page">
              <div class="article-box">
    <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://liuxbo.github.io/post/cshua-ti-bi-ji/">
      c++刷题笔记
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-05-06</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
      <span class="meta-item">
        <i class="fa fa-folder-o"></i>
        <span class="pc-show">分类于</span>
        
          
            <a href="https://liuxbo.github.io/tag/ebIooEyCk/">
              <span>c++</span>
            </a>
          
        
      </span>
      <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>52分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>10805<span class="pc-show">字数</span></span>
    </span>
  </div>
</header>
</div>
              <div class="post-body next-md-body" id="post_body">
                <h3 id="1-c字符串数组的0问题">1. c++字符串数组的\0问题</h3>
<pre><code>#include&lt;stdio.h&gt;
int main() {
	char str1[8] = { 'd','e','d','g','o' };
	char str2[5] = { 'd','e','d','g','o' };
	printf(&quot;%d\n&quot;, sizeof(str1));
	printf(&quot;%d\n&quot;, sizeof(str2));
	return 0;
}
</code></pre>
<p>![](C:\Users\lxb\Pictures\Camera Roll\KG1V`[}F4D7YE5L_NIJ289O.png)</p>
<p>对于字符串数组，当定义时直接对其赋值，无论元素是否占满数组，其储存的字符个数都是数组的元素个数，未占满时会自动用\0补全</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	puts(str);
	return 0;
}
</code></pre>
<p>输出会乱码</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Clxb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191205103056228.png" alt="image-20191205103056228" loading="lazy"></figure>
<p>使用<code>getchar</code>要在输入的每个字符串后面加\0,例如</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main() {
	char str[14];
	for (int i = 0; i &lt; 5; i++) {
		str[i] = getchar();
	}
	str[5] = '\0';
	puts(str);
	return 0;
}
</code></pre>
<h3 id="2数组相关问题">2.数组相关问题</h3>
<ul>
<li>
<p>反转一个一维数组</p>
<pre><code>#include &lt;cstdio&gt;
int main() {
	int a[5] = { 5,2,3,6,9 };
	for (int i = 0, j = 4; i &lt;= j; i++, j--) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	for(int i=0;i&lt;5;i++)
	printf(&quot;%d&quot;, a[i]);
	return 0;
}
</code></pre>
</li>
<li>
<p>找二维(或三维)数组中的“块”(比如相邻的若干个数组元素1)</p>
<p>用BFS，要设置增量数组，</p>
<p>对于一维的情况，可以设置</p>
<pre><code>int X[4]={0,0,1,-1};
int Y[4]={1,-1,0,0};
</code></pre>
<p>以便于访问上下左右四个位置</p>
<p>对于三维的情况，可以设置</p>
<pre><code>int X[6]={0,0,0,0,1,-1};
int Y[6]={0,0,1,-1,0,0};
int Z[6]={1,-1,0,0,0,0};
</code></pre>
<p>对应前后左右上下6个位置</p>
</li>
</ul>
<h3 id="3字符串问题">3.字符串问题</h3>
<ul>
<li>
<p><code>scanf (&quot;%s&quot;)</code>识别空格作为字符串结尾</p>
<p><code>getchar</code>  <code>putchar</code> 用来输入输出单个字符</p>
<p><code>gets</code> <code>puts</code> 用来输入输出一行字符串，<code>gets</code> 识别换行符\n作为输入结束  ，gets现在已经不支持了</p>
</li>
<li>
<p><code>cin</code> 读入字符串时，以空格为分隔符，如果想读入一整行字符串，用<code>getline(cin,s)</code>，注意前面如果输入数字n，一定要注意<code>scanf(&quot;%d\n&quot;,&amp;n);</code> 这样写，防止getline读入错误</p>
</li>
<li>
<p>判断两个字符串是否一样时可以用<code>strcmp()==0</code>，该函数其中一个参数可以为字符数组的名称</p>
</li>
<li>
<p>使⽤ <code>stoi()</code> 、 <code>stod()</code>  可以将字符串 string 转化为对应的 int 型、 double 型变量</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
 string str = &quot;123&quot;;
 int a = stoi(str);
 cout &lt;&lt; a;//输出123
 str = &quot;123.44&quot;;
 double b = stod(str);
 cout &lt;&lt; b;//输出123.44
 return 0;
}
</code></pre>
<p><code>stoi</code>如果遇到的是⾮法输⼊（⽐如<code>stoi(&quot;123.4&quot;)</code>，123.4不是⼀个int型变量）： 1.会⾃动截取最前⾯的     数字，直到遇到不是数字为⽌ (所以说如果是浮点型，会截取前⾯的整数部分) 2.如果最前⾯不是数字，会运⾏时发⽣错误</p>
<p><code>stod</code>如果是⾮法输⼊： 1.会⾃动截取最前⾯的浮点数，直到遇到不满⾜浮点数为⽌ 2.如果最前⾯不是数字或者⼩数点，会运⾏时发⽣错误 3.如果最前⾯是⼩数点，会⾃动转化后在前⾯补0</p>
<p>不仅有<code>stoi</code>、<code>stod</code>两种，相应的还有：</p>
<p><code>stof (string to float)</code></p>
<p><code>stold (string to long double)</code></p>
<p><code>stol (string to long)</code></p>
<p><code>stoll (string to long long)</code></p>
<p><code>stoul (string to unsigned long)</code></p>
<p><code>stoull (string to unsigned long long)</code></p>
</li>
<li>
<p><code>to_string()</code>将数值转化为字符串。返回对应的字符串。头文件同样为<code>include&lt;string&gt;</code></p>
</li>
<li>
<p><code>printf(&quot;%s\n&quot;, (s1 + s2).c_str());</code>  如果想⽤<code>printf</code>输出string，需要加⼀ 个<code>.c_str()</code></p>
</li>
<li>
<p>字符串形式的两个数字相加</p>
<pre><code>string add(string s1, string s2) {
	string s = s1;
	int carry = 0;
	for (int i = s1.size() - 1; i &gt;= 0; i--) {
		s[i] = ((s1[i] - '0') + (s2[i] - '0') + carry) % 10 + '0';
		carry = ((s1[i] - '0') + (s2[i] - '0') + carry) / 10;
	}
	if (carry &gt; 0) s = '1' + s;
	return s;
}
</code></pre>
</li>
<li>
<p>涉及到的题目:A1035，A1077,A1082,A1093,A1061，<strong>A1073</strong>(科学计数法)，A1077(公共后缀)，<strong>A1082</strong>,</p>
<p>A1112, A1152, A1140  A1136(回文串、字符串) 、 A1132(20 水题)</p>
</li>
</ul>
<h3 id="4中序序列和-后序或先序或层序-搭配-确定一棵二叉树">4.中序序列和 后序或先序或层序 搭配， 确定一棵二叉树</h3>
<ul>
<li>
<p>先由后序序列或先序序列确定根节点</p>
</li>
<li>
<p>利用在先序或后序序列找到的根节点的值，确定中序序列中根节点的位置</p>
</li>
<li>
<p>确定左子树、右子树的 先序/后序  和中序序列（左子树所有节点的个数只能在中序序列中得知）</p>
</li>
<li>
<p>分别向左孩子和右孩子递归构建</p>
<p>注意递归时区间的书写格式</p>
</li>
</ul>
<h3 id="5-映射问题hash-map-散列">5. 映射问题(hash 、map、散列...)</h3>
<ul>
<li>
<p>直接开数组，将数组下标与下标对应的内容作为映射,ASCII码表有128个字符，对于一些题目可以直接开<code>hashtable[128]</code>数组，关于其下标，可以用以下函数获得</p>
<pre><code>int change(char c){
    if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0';
    if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'+10;
    if(c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'+36;
}
</code></pre>
</li>
<li>
<p>字符串hash</p>
<ul>
<li>
<pre><code>for(int i = 0; i &lt; 3; i++)  id = 26 * id + (name[i] - 'A'); //大写字母字符串映射为整数
</code></pre>
</li>
</ul>
</li>
<li>
<p>涉及到的题目</p>
<p>A1084,A1092,A1041,A1050，A1048  <strong>A1129(25 set的应用 结构体内运算符重载)</strong></p>
<p>A1145(25 hash 平方探查)</p>
</li>
</ul>
<h3 id="6-stl容器">6. <code>STL</code>容器</h3>
<ul>
<li>
<p>vector</p>
<p>定义一个m行n列的数组 <code>vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n));</code></p>
<pre><code>vector&lt;int&gt; vec1(4,1);              //vec1的内容为1,1,1,1
vector&lt;int&gt; vec1{ 1, 2, 3, 4, 5, 6 };       //vec1内容1,2，3,4,5,6
</code></pre>
<pre><code>vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值
</code></pre>
<pre><code>vector&lt;int&gt; vec(arr, arr + 5);   //将arr数组的元素用于初始化vec向量
//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，
//这个主要是为了和vec.end()指针统一。
</code></pre>
</li>
<li>
<p>异同</p>
<p>只有<code>vector</code>和<code>string</code>支持<code>*(it+i)</code>的访问方式 ,<code>set</code>只能通过迭代器访问(即*it)，</p>
<p><code>map</code> 、<code>string</code>和<code>vector</code>支持下标访问和迭代器访问。</p>
<p>map与set内部都会自动递增排序，(这里指map的key），并且set的元素值与map的key在其各自内部都是唯一的，包括数字和字</p>
</li>
<li>
<p>常用函数</p>
<ul>
<li>
<p><code>string</code>  <code>s.begin() s.end()</code>  <code>s.c_str()</code> <code>s.length() s.size()</code> <code>s.substr()</code></p>
</li>
<li>
<p><code>map</code></p>
<p>使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。count(key值)</p>
<p>find() erase() size() clear()</p>
</li>
</ul>
</li>
<li>
<p>注意</p>
<p>begin()函数返回一个迭代器,指向字符串的第一个元素.</p>
<p>end()函数返回一个迭代器，指向字符串的末尾(最后一个字符的下一个位置).</p>
<p>rbegin()返回一个逆向迭代器，指向字符串的最后一个字符。</p>
<p>rend()函数返回一个逆向迭代器，指向字符串的开头（第一个字符的前一个位置）。</p>
<p>vector数组可以直接用==判断两个数组是否相同</p>
<p>string类型可以直接用&lt;  或 &gt; 或== 直接进行字典序的比较，而char数组必须用strcmp比较</p>
<p>vector使用下标访问前注意先resize一下</p>
</li>
</ul>
<p>A1039,A1047,A1063,A1060,A1100,A1054，A1071,A1022 A1120 ,A1149(map、vector)</p>
<p>A1121 (25 map、set应用)   A1137(25 map 排序)    A1139(30 逻辑题 unordered_map)</p>
<h3 id="7-输入输出问题">7. 输入输出问题</h3>
<p><code>scanf</code>中 ，<code>long long</code>型 ：<code>scanf(&quot;%lld&quot;,&amp;n)</code> , <code>double</code>型：<code>scanf(&quot;lf&quot;,&amp;n)</code></p>
<p><code>printf</code>中，<code>long long</code> 型：<code>printf(&quot;%lld&quot;,n)</code>   , <code>double</code> 型：<code>printf(&quot;%f&quot;,n)</code></p>
<p>若<code>getline(cin, str);</code>前有<code>scanf(&quot;%d%*c&quot;, &amp;n);</code>输入，可以用%*c忽略一个字符型(比如换行),或者%*d忽略一个数字型。也可以用getchar()吸收掉字符</p>
<p><code>scanf(&quot;%*c%d&quot;,&amp;n);可以吸收掉上一行末尾的的换行符</code></p>
<p>若输入格式为数字<code>空格</code> 字符<code>空格</code> 数字，可以写成<code>scanf(&quot;%d %c %d&quot;)</code> ,因为空格也算字符。</p>
<p>注意string类型用printf输出时一定要用c_str()转化一下</p>
<p><code>sscanf(a, &quot;%lf&quot;, &amp;temp);</code> 从左到右，将字符数组a以浮点数的形式存到double类型temp中；</p>
<p><code>sprintf(b, &quot;%.2f&quot;, temp);</code> 从右到左，将double类型temp以保留两位小数的形式存到字符数组b中</p>
<h3 id="8-提取数中的元素">8. 提取数中的元素</h3>
<pre><code>while (b != 0) {
		if (b % 10 == db) pb = pb * 10 + db;
		b = b / 10;
	}
提取b中的重复数字组成新的数字 b=38633 ，db为3，新数字为333
</code></pre>
<h3 id="9-常用函数">9. 常用函数</h3>
<ul>
<li>
<p><code>math.h</code>头文件函数</p>
<p><code>fabs(double x)</code>  取绝对值 ，</p>
<p><code>floor(double x)</code>和<code>ceil(double x)</code> ，分别为向上取整和向下取整，返回double型</p>
<p><code>pow(double r,double p)</code> 用于返回r^p</p>
<p><code>sqrt(double x)</code> ,返回算数平方根</p>
<p><code>log(double x)</code> ,返回以自然对数为底的对数，用换底公式求具体对数</p>
<p><code>sin(double x)</code> <code>cos(double x)</code> <code>tan(double x)</code></p>
<p><code>asin(double x)</code> <code>acos(double x)</code> <code>atan(double x)</code></p>
<p><code>round(double x)</code> 将x四舍五入，返回为double型</p>
</li>
<li>
<p><code>algorithm</code>头文件下的函数，加<code>using namespace std;</code></p>
<p><code>max(x,y)</code> <code>min(x,y)</code>  <code>abs(x)</code> 返回x的绝对值，x必须为整数</p>
<p><code>swap(x,y)</code></p>
<p><code>reverse(it,it2)</code> <code>reverse(a,a+4)</code>  ,将数组元素反转</p>
<p><code>next_permutation(a,a+...)</code> ,给出一个序列在全排列中的下一个序列，该函数在到达全排列的最后一个时会返回false</p>
<p><code>fill(a,a+4,233)</code> ,赋相同值，对于<code>G[maxn] [maxn]</code>二维数组<code>fill(G[0],G[0]+maxn*maxn,INF);</code></p>
<p><code>sort(首元素地址，尾元素地址的下一个地址，比较函数（非必填)）</code>,无比较函数，默认递增排序。</p>
<p><code>sort(a, a+n, greater());</code>  从大到小排序(要用<code>iostream</code>头文件)</p>
<p><code>lower_bound(first,last,val)</code>  <code>upper_bound(first,last,val)</code> ,用于有序数组或容器，前者用来寻找[first,last)范围内第一个值大于等于val的元素的位置，后者寻找第一个值大于val的元素位置.若是数组，这两个函数返回的是地址，如<code>int* right=upper_bound(num, num+n, k)</code>，返回num数组中第一个大于k的元素所在地址，其下标=<code>right-num</code></p>
<p><code>max_element(a, a+len)</code>返回序列中最大元素地址（迭代器）,可用其减去数组首地址(即数组名)获取其下标,若要获取该元素值，直接在前面加一个*,表示取地址即可</p>
<p><code>min_element(begin, end)</code> 返回序列中最小元素地址</p>
</li>
<li>
<p><code>string.h</code> 头文件(<code>cstring</code>头文件)</p>
<p><code>memset(数组名,-1或0,sizeof(数组名))</code></p>
<p><code>strlen(字符数组)</code> 得到字符数组中第一个\0前的字符个数</p>
<p><code>strcmp(字符数组1，字符数组2)</code>返回两个字符串大小比较结果，按字典序。字符数组1&lt;2 ,返回负整数;1=2，返回0;1&gt;2，返回正整数</p>
<p><code>strcpy(字符数组1，字符数组2)</code>，把字符数组2复制给字符数组1，包括\0</p>
<p><code>strcat(字符数组1，字符数组2)</code> ,把2接在1后面</p>
</li>
<li>
<p><code>cctype</code>头文件</p>
<p>1.不仅仅能判断字⺟，还能判断数字、⼩写字⺟、⼤写字⺟等</p>
<p><code>isalpha</code>字⺟（包括⼤写、⼩写）</p>
<p><code>islower</code> （⼩写字⺟）</p>
<p><code>isupper</code>（⼤写字⺟）</p>
<p><code>isalnum</code> （字⺟⼤写⼩写+数字）</p>
<p><code>isblank</code>（space和 \t ）</p>
<p><code>isspace</code>（ space 、 \t 、 \r 、 \n ）</p>
<p><code>isdigit</code>(数字)</p>
<p>2 .<code>tolower (char c)</code>和 <code>toupper(char c)</code> 将某个字符转为⼩写或⼤写</p>
</li>
</ul>
<h3 id="10进制转换">10.进制转换</h3>
<ul>
<li>十进制转化为其他进制</li>
</ul>
<pre><code>int z[maxn],num=0;
do{
z[num++]=n%b;
n/=b;
}while(n!=0);
或者
void change(int n,int b){
	if(n&gt;0){
		int i=0;
		change(n/b,b);
		a.push_back(n%b);
	}
	else return;
}
</code></pre>
<ul>
<li>
<p>给定⼀个数值和⼀个进制，将它转化为10进制。转化过程中可能产⽣溢出,数值中只有小写字母和数字</p>
<pre><code>long long convert(string n, long long radix) {
 long long sum = 0;
 int index = 0, temp = 0;
 for (auto it = n.rbegin(); it != n.rend(); it++) {
 temp = isdigit(*it) ? *it - '0' : *it - 'a' + 10;
 sum += temp * pow(radix, index++);
 }
 return sum;
}
</code></pre>
</li>
</ul>
<h3 id="11-ascll-码表">11. <code>ASCLL</code> 码表</h3>
<p>A-Z对应十进制65-90</p>
<p>a-z对应十进制97-122</p>
<h3 id="12回文串">12.回文串</h3>
<pre><code>bool judge(int arr[],int index){
    for(int i = 0; i &lt;index / 2; i++) {
       if(arr[i] != arr[index-i-1]) {
           return false;
     }
   }
   return true;
}

</code></pre>
<h3 id="13数字-字符数组相互转换">13.数字、字符数组相互转换</h3>
<pre><code>1.数字存到数组中
void to_array(int n,int a[]){
    int j=0;
    while(n){
        a[j++]=n%10;
        n/=10;
    }
}
2.数组变为数字
int exp=0;
for(int i=0;i&lt;len;i++){
    exp=exp*10+(str[i]='0');
}
或

</code></pre>
<h3 id="14-排序-找最值">14 排序、找最值</h3>
<ul>
<li>
<pre><code>int best=0;
for (int j = 0; j &lt; 4; j++) {
	if (a[j] &lt; a[best])
	best = j;
}
找出数组a中最小元素的位置
</code></pre>
</li>
<li>
<p>结构体内重载运算符</p>
<p>运算符重载的格式如下：</p>
<p>函数类型 operator 运算符名称（形参表列）{对运算符的重载处理},例如：</p>
<pre><code>struct node {
	int id;
	int freq;
	bool operator &lt; (const node&amp; a) const {
		return (freq != a.freq) ? freq &gt; a.freq:id &lt; a.id;
	}
};
</code></pre>
</li>
<li>
<p>使用sort()对char数组排序</p>
<p>正确方法：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
char name[3][4] = {&quot;wu&quot;,&quot;jia&quot;,&quot;jun&quot;};//二维数组保存n个字符串 
bool cmp(int a,int b){
    return strcmp(name[a],name[b]) &lt; 0;
}
int main(){
    int arr[3] = {0,1,2};//与字符串数组下标一一对应 
    sort(arr,arr+3,cmp);//排列的实际是标号 ，这么做更快 
    for(int i = 0;i &lt;3 ;i++){
        printf(&quot;%s &quot;,name[arr[i]]);
    }
}
</code></pre>
<p>错误方法：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
char stu[6][6] = { &quot;ahda&quot;,&quot;jwnd&quot;,&quot;djsh&quot;,&quot;yrhw&quot;,&quot;JWJs&quot; };
bool cmp(int a, int  b) { return strcmp(stu[a], stu[b]) &lt; 0; }
int main() {
	sort(stu, stu + 5, cmp);
	for (int i = 0; i &lt; 5; i++)
		printf(&quot;%s&quot;, stu[i]);
	return 0;
}
</code></pre>
</li>
<li>
<pre><code> testee[0].rank=1;
  	for(int k=1;k&lt;total;k++){
  		if(testee[k].grade==testee[k-1].grade) testee[k].rank=testee[k-1].rank;
  		else testee[k].rank=k+1;
  	}
确保排名为 1 1 3 3 4...的形式
</code></pre>
</li>
<li>
<p>A1062 ,A1075,A1012,A1016,A1025,A1028,A1055,A1075,A1083,A1080,A1095,A1109,A1141(注意1080中cmp的写法和使用)</p>
<p>思路：</p>
<p>定义结构体，cmp函数，初始化结构体内的变量，for循环中边输入边处理</p>
<p>排序时注意是否能用学号等信息作为数组下标，因为排序后下标会改变，所以可以在结构体中设置id变量</p>
<p>平均数作为最后成绩可以不用除，直接用总和比较</p>
<p>有些题要找出有效记录(比如常出现的配对问题)</p>
</li>
<li>
<p>各种排序算法</p>
<ul>
<li>
<p>选择排序</p>
<pre><code>void selectsort(){
    for(int i=0;i&lt;n;i++){
        int k=i;
        for(int j=k;j&lt;n;j++){
            if(A[j]&lt;A[k]){
                k=j;
            }
        }
        int temp=A[K];
        A[k]=A[i];
        A[i]=temp;
    }
}
</code></pre>
</li>
<li>
<p>插入排序</p>
<pre><code>void insertSort(){
   for(int i=2;i&lt;=n;i++){
      int temp=a[i],j=i;
      while(j&gt;1&amp;&amp;a[j-1]&gt;temp){
         a[j]=a[j-1];
         j--;
      }
      a[j]=temp;
   }
}
</code></pre>
</li>
<li>
<p>归并排序  (合并两个有序序列时，注意其中一个数列先扫描完的情况)</p>
<pre><code>
</code></pre>
</li>
<li>
<p>快排(递归法)</p>
<pre><code>int partition(int A[],int left,int right){
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
<p>快排(改进后)</p>
<p>生成随机数需要添加stdlib.h与time.h头文件，mian函数内开头加上srand((unsigned)time(NULL));</p>
<pre><code>int partition(int A[],int left,int right){//只改进该函数
    int p=(round(1.0*rand()/RAND_MAX*(right-left)+left);
    //生成[left,right]范围内的随机数
    swap(A[left],A[p]);
    int temp=A[left];
    while(left&lt;right){
        while(right&gt;left&amp;&amp;A[right]&gt;temp) right--;
        A[left]=A[right];
        while(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;
        A[right]=A[left];
    }
    A[left]=temp;
    return left;
}
void quicksort(int A[],int left,int right){//该函数不变
    if(left&lt;right){
        int pos=partition(A,left,right);
        quicksort(A,left,pos-1);
        quciksort(A,pos+1,right);
    }
}
</code></pre>
</li>
<li>
<p>堆排序</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
void createheap() {//建堆
	for (int i = n / 2; i &gt;= 1; i--) {
		downadjust(i, n);
	}
}
void heapsort(){
    createheap();
    for(int i=n;i&gt;1;i--){
        swap(heap[1],heap[i]);
        upadjust(1,i-1);
    }
}
</code></pre>
</li>
<li>
<p>拓扑排序</p>
<pre><code>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="15-计算时长">15 计算时长</h3>
<ul>
<li>
<p>对已知的起止时间，不断将起始时间加1，判断是否到达终止时间</p>
<pre><code>void get_ans(int on, int off, int&amp; time, int&amp; money) {
	temp = rec[on];
  while (temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) {
		time++;
		money += toll[temp.hh];
		temp.mm++;
		if (temp.mm &gt;= 60) {
			temp.mm = 0;
			temp.hh++;
		}
		if (temp.hh &gt;= 24) {
			temp.hh = 0;
			temp.dd++;
		}
	}
}
</code></pre>
</li>
<li>
<p>对于<code>hh:mm:ss</code>类型的时间处理：可以<code>hh * 3600 + mm * 60 + ss</code> 转化成秒，方便处理</p>
</li>
</ul>
<h3 id="16数据类型问题">16.数据类型问题</h3>
<ul>
<li>且C++把所有⾮零值解释为 true ，零值解 释为 false ～所以直接赋值⼀个数字给 <code>bool</code> 变量也是可以的，它会⾃动根据 int 值是不是零来决定 给 <code>bool</code> 变量赋值 true 还是 false ～</li>
</ul>
<pre><code>bool flag = true;//flag为1，若是flase则为0
bool flag2 = -2; // flag2为true
bool flag3 = 0; // flag3为false
</code></pre>
<h3 id="17栈-队列-链表">17.栈、队列、链表</h3>
<p>在使用栈的pop()和top()函数前必须使用empty()判断栈是否非空。</p>
<p>栈：A1051</p>
<p>记得清空栈</p>
<pre><code>while(!st.empty()){
    st.pop();
}
</code></pre>
<p>队列：A1056</p>
<p>链表：A1074，A1032，A1052, A1097 A1133(链表  重新排列)</p>
<pre><code>for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;address);
		scanf(&quot;%d%d&quot;,&amp;node[address].key,&amp;node[address].next);
		node[address].address=address;
	}
</code></pre>
<p>当结点的地址是比较小的整数(比如5位数的整数),可以使用静态链表，没有必要建立动态链表。</p>
<p>注意初始化，排除无效结点(可以结合sort，cmp中针对order)。用count计数有效结点</p>
<p>某些情况下的最后一个结点要特殊处理(比如令next为-1)。</p>
<p>注意链表结构体元素order的使用</p>
<h3 id="18贪心">18.贪心</h3>
<p>A1070 ,<strong>A1033</strong> ,A1037,A1067 A1125(简单贪心 排序)</p>
<h3 id="19-二分">19 二分</h3>
<p>A1085,A1010,A1044 A1048</p>
<p>注意二分法的几种写法,以及非严格递增序列的处理,可以使用<code>lower_bound</code>和<code>upper_bouned</code></p>
<h3 id="20-two-points">20 two points</h3>
<p>A1085,A1089,A1029</p>
<h3 id="21-数学问题">21 数学问题</h3>
<ul>
<li>
<p>求最大公约数,(最小公倍数：a和b的最大公约数为d，则a和b的最小公倍数为ab/d)</p>
<pre><code>long long gcd(long long a, long long b) {
     return b == 0 ? abs(a) : gcd(b, a %b);
 }
</code></pre>
</li>
<li>
<p>分数化简</p>
<pre><code>struct fraction {
	ll up, down;
}a, b;
fraction reduction(fraction result) {
	if (result.down &lt; 0) {
		result.up = -result.up;
		result.down = -result.down;
	}
	if (result.up == 0) result.down = 1;
	else {
		ll gcdvalue = gcd(abs(result.up), abs(result.down));
		result.up /= gcdvalue;
		result.down /= gcdvalue;
	}
	return result;
}
</code></pre>
</li>
<li>
<p>四则运算</p>
<pre><code>fraction add(fraction f1, fraction f2) {
	fraction result;
	result.up = f1.up * f2.down + f1.down * f2.up;
	result.down = f1.down * f2.down;
	return reduction(result);
}
</code></pre>
</li>
<li>
<p>分数输出</p>
<pre><code>void showresult(fraction r) {
	r = reduction(r);
	if (r.up &lt; 0) printf(&quot;(&quot;);
	if (r.down == 1) printf(&quot;%lld&quot;, r.up);
	else if (abs(r.up) &lt; r.down) printf(&quot;%lld/%lld&quot;, r.up, r.down);
	else if (abs(r.up) &gt; r.down) printf(&quot;%lld %lld/%lld&quot;, r.up / r.down, abs(r.up) % r.down, r.down);
	if (r.up &lt; 0) printf(&quot;)&quot;);
}
</code></pre>
</li>
<li>
<p>判断是否为素数</p>
<pre><code>bool isprime(int n) {
	if (n &lt;= 1) return false;
    int sqr = sqrt(1.0 * n);
	for (int i = 2; i &lt;= sqr; i++) {
		if (n % i == 0) return false;
	}
	return true;
}

</code></pre>
</li>
<li>
<p>建立素数表</p>
<pre><code>
int prime[maxn], pnum=0;
void find_prime() {
	for (int i = 1; i &lt; maxn; i++) {
		if (isprime(i)) {
			prime[pnum++] = i;
		}
	}
}
</code></pre>
</li>
<li>
<p>大整数运算</p>
<pre><code>struct bign {
	int d[1000];
	int len;
	bign() {
		len = 0;
		memset(d, 0, sizeof(d));
	}
};
bign change(string str) {
	bign a;
	a.len = str.length();
	for (int i = 0; i &lt; a.len; i++) {
		a.d[i] = str[a.len - 1 - i]-'0';
	}
	return a;
}
bign multi(bign a, int b) {
	bign c;
	int carry=0;
	for (int i = 0; i &lt; a.len; i++) {
		int temp = a.d[i] * b + carry;
		c.d[c.len++] = temp % 10;
		carry = temp / 10;
	}
	while (carry != 0) {
		c.d[c.len++] = carry % 10;
		carry /= 10;
	}
	return c;
}
</code></pre>
</li>
</ul>
<p>A1069,A1049,A1088,A1015,A1078,A1096,A1023,A1024</p>
<h3 id="22入门模拟">22.入门模拟</h3>
<p>A1042(洗扑克牌) ，A1046(环形两点间距离) ，A1065(两数相加判断大小)， A1002(多项式相加)，A1009(多项式相乘)，A1011，A1006(签到签离) ，A1036(找最值)，A1031(输出图形)，A1019(回文串)，A1027(进制转换)，A1058(加法进位)，A1061(字符串问题)，***A1073(科学计数法)***，A1001(a+b)，A1005,A1035,A1077(公共后缀)，<strong>A1082(用汉语读数字)</strong></p>
<h3 id="23技巧-逻辑">23.技巧、逻辑</h3>
<p>A1093,A1101, A1113 A1117(逻辑)  A1148(狼人杀 找到两个狼人)</p>
<h3 id="24-dfs-bfs">24 DFS BFS</h3>
<ul>
<li>
<p>DFS用递归实现，A1103</p>
<pre><code>void DFS(int index, int nowk, int sum, int facsum) {
	if (sum == n &amp;&amp; nowk == k) {
		if (facsum &gt; maxfacsum) {
			ans = temp;//更新最优序列
			maxfacsum = facsum;
		}
		return;
	}
	if (nowk &gt; k || sum &gt; n) return;
	if (index - 1 &gt;= 0) {
		temp.push_back(index);
		DFS(index, nowk + 1, sum + fac[index], facsum + index);
		temp.pop_back();
		DFS(index - 1, nowk, sum, facsum);
	}
}
</code></pre>
</li>
<li>
<p>BFS用队列实现    A1091</p>
<pre><code>void BFS(int s){
    queue&lt;int&gt; q;
    q.push(s);
    while(!q.empty()){
        取出队首元素top;
        访问队首元素top;
        将队首元素出队;
        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;
    }
}
</code></pre>
<pre><code>int BFS(int z,int x,int y){
	int total=0;
	Node.x = x;
	Node.y = y;
	Node.z = z;
	inq[z][x][y] = true;
	queue&lt;node&gt; q;
	q.push(Node);
	while (!q.empty()) {
		node topp = q.front();
		q.pop();
		total++;
		int newx, newy, newz;
		for (int i = 0; i &lt; 6; i++) {
			newz = topp.z + Z[i];
			newx = topp.x + X[i];
			newy = topp.y + Y[i];
			if (judge(newz, newx, newy)) {
				Node.x = newx;
				Node.y = newy;
				Node.z = newz;
				q.push(Node);
				inq[Node.z][Node.x][Node.y] = true;
			}
		}
	}
	if (total &gt;= T) return total;
	else return 0;
}
</code></pre>
</li>
</ul>
<h3 id="25-树">25 树</h3>
<p>A1020,A1086,A1102 , A1151(二叉树LCA)，A1143(二叉搜索树LCA) 、A1119(前序和后序求中序)</p>
<p>A1123(30 AVL 、层序遍历、判断是否是完全二叉树) 、 A1110(判断是否为完全二叉树)</p>
<p>A1127(30 中序后序建树，dfs，输出z字形层序遍历)   A1130(dfs二叉树 输出中缀表达式)</p>
<p>A1155(30 完全二叉树  判断大顶堆小顶堆 dfs 打印路径)    A1147(30  判断大顶堆小顶堆 后序遍历)</p>
<p>A1135(30 判断红黑树 递归判断)</p>
<ul>
<li>
<p>二叉树</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node{
    typename data;
    node* lchild;
    node* rchild;
}
</code></pre>
</li>
<li>
<p>新建结点</p>
<pre><code>node* newNode(int v){
    node* root=new node;
    Node-&gt;data=v;
    Node-&gt;lchild=Node-&gt;rchild=NULL;
    return Node;
}
</code></pre>
</li>
<li>
<p>中序遍历</p>
<pre><code>void inorder(node* root){
    if(root==NULL) return;
    inorder(root-&gt;lchild);
    printf(&quot;%d&quot;,root-&gt;data);
    inorder(root-&gt;rchild);
}
</code></pre>
</li>
<li>
<p>二叉树的层序遍历(BFS)</p>
<pre><code>void layerorder(node* root) {
	queue&lt;node*&gt; q;
	q.push(root);
	while (!q.empty()) {
		node* now = q.front();
		q.pop();
		printf(&quot;%d&quot;, now-&gt;data);
		if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);
	if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);
	}
}
</code></pre>
</li>
<li>
<p>用已知的两个序列构建唯一二叉树</p>
<pre><code>node* create(int postL, int postR, int inL, int inR) {//后序加中序
	if (postL &gt; postR) return NULL;
	node* root = new node;
	root-&gt;data = postorder[postR];
	int k;
	for (int i = inL; i &lt;= inR; i++) {
		if (inorder[i] == root-&gt;data) {
			k = i;
			break;
		}
	}
	int leafnum = k - inL;
	root-&gt;lchild = create(postL, postL + leafnum - 1, inL, k - 1);
	root-&gt;rchild = create(postL + leafnum, postR - 1, k + 1, inR);
	return root;
}

</code></pre>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
using namespace std;
#define INF 0x3fffffff
typedef struct node{				//结点定义 
	int data;
	struct node *right,*left;
}Node;
vector&lt;int&gt; inor,layor;				//中序和层序序列 
unordered_map&lt;int,int&gt; inmp,laymp;	//序列与其下标的映射，（建立映射可以减少递归时候查找序列的次数） 
Node *creat(int il,int ir){			//建树函数 ，il表示中序序列的左端，ir便是中序序列的右端 
	if(il&gt;ir) return NULL;			//如果树中序列长度为0，表示到了空结点 
	int min=INF,id;					//min表示中序序列中的元素在层序中下标最小的那个，其中序的下标 
	for(int i=il;i&lt;=ir;i++){		//遍历中序序列，找出对应层序中下边最小的元素 
		if(laymp[inor[i]]&lt;min){
			min=laymp[inor[i]];
		}
	}
	Node *root=new node;			
	root-&gt;data=layor[min];			//中序序列中 层序中下标最小的便是根 
	id=inmp[root-&gt;data];			//获得根在中序的位置，划分为左子树和右子树 
	root-&gt;left=creat(il,id-1);		//递归左子树 
	root-&gt;right=creat(id+1,ir);		//递归右子树 
	return root;					//返回当前子树的根 
}
void preorder(Node *root){			//递归的先序遍历函数 
	if(root==NULL) return;
	printf(&quot;%d &quot;,root-&gt;data);
	preorder(root-&gt;left);
	preorder(root-&gt;right);
}
int main(void){

	int n;
	cin&gt;&gt;n;
	inor.resize(n); layor.resize(n);//读入元素个数并初始化 
	for(int i=0;i&lt;n;i++){			//读入中序序列并完成映射 
		cin&gt;&gt;inor[i];
		inmp[inor[i]]=i;
	} 
	for(int i=0;i&lt;n;i++){			//读入层序序列并完成映射 
		cin&gt;&gt;layor[i];
		laymp[layor[i]]=i;
	} 
	Node *root=creat(0,n-1);		//建树 
	preorder(root);					//先序遍历，验证树的结构 
	return 0;
} 
</code></pre>
</li>
<li>
<p>前序后序 求中序</p>
<pre><code>void getin(int prel, int prer, int postl, int postr) {
	if (prel == prer) {
		in.push_back(pre[prel]);
		return;
	}
	if (pre[prel] == post[postr]) {
		int i = prel + 1;
	while (i &lt;= prer &amp;&amp; pre[i] != post[postr - 1]) i++;
		if (i - prel &gt; 1) getin(prel + 1, i - 1, postl, postl + (i - prel - 1) - 1);
		else unique = false;
		in.push_back(post[postr]);
		getin(i, prer, postl + (i - prel - 1), postr - 1);
	}
}
</code></pre>
</li>
<li>
<p>静态二叉树(如果题目中直接给出结点序号之间的父子关系，可以用静态)</p>
<pre><code>struct node{
    typename data;
    int lchild;
    int rchild;
}Node[maxn];
</code></pre>
</li>
<li>
<p>二叉树反转(静态)</p>
<pre><code>void postorder(int root) {
	if (root == -1) return;
	postorder(Node[root].lchild);
	postorder(Node[root].rchild);
	swap(Node[root].lchild, Node[root].rchild);
}
</code></pre>
</li>
<li>
<p>完全二叉树</p>
<p>1.判断是否是完全二叉树</p>
<pre><code>int iscomplete = 1, after = 0;
vector&lt;int&gt; levelorder(node* root) {//层序遍历中
	queue&lt;node*&gt; q;
	vector&lt;int&gt; v;
	q.push(root);
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		v.push_back(temp-&gt;data);
		if (temp-&gt;lchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;lchild);
		}
		else after = 1;
		if (temp-&gt;rchild != NULL) {
			if (after) iscomplete = 0;
			q.push(temp-&gt;rchild);
		}
		else after = 1;
	}
	return v;
}
</code></pre>
<p>2.给出⼀个n表示有n个结点，这n个结点为0~n-1，给出这n个结点的左右孩⼦，求问这棵树是 不是完全⼆叉树</p>
<p>分析：递归出最⼤的下标值，完全⼆叉树⼀定把前⾯的下标充满： 最⼤的下标值 == 最⼤的节点数； 不完全⼆叉树前满⼀定有位置是空，会往后挤： 最⼤的下标值 &gt; 最⼤的节点数</p>
</li>
<li>
<p>注意点</p>
<ul>
<li>完全二叉树的存储中，如果根节点下标为1，则该树中任何一个结点i，其左孩子编号为2i，右孩子编号为2i+1，父亲节点为下取整(i/2);如果根节点下标为0，对树中某结点i,父亲结点为下取整((i-1)/2);左孩子为2i+1，右孩子为2i+2</li>
<li>函数参数中，对指针指向的结点内容进行修改是不需要加引用的，。如果函数中需要新建结点，即对二叉树的结构做出修改，就需要加引用(如insert，)，如果是修改当前已有结点的内容，或者是遍历树，就不需要加引用。</li>
<li>无论是先序还是后序，都必须知道中序序列才能唯一确定一棵树</li>
<li>对于题目中给出左右孩子结点编号的情况，没有被当做孩子结点的结点编号即为根结点，可以用一个数组来判断</li>
</ul>
</li>
</ul>
</li>
<li>
<p>普通树</p>
<p>深度遍历，递归边界为无孩子结点，根节点深度为0</p>
<pre><code>void DFS(int index,int depth){
	if(Node[index].child.size()==0){
		ans+=Node[index].data*p*pow((1+r/100),depth);
		return;
	}
	for(int i=0;i&lt;Node[index].child.size();i++){
		DFS(Node[index].child[i],depth+1);
	}
}
</code></pre>
<p>广度遍历</p>
<pre><code>void BFS() {
  	level[1] = 1;
  	queue&lt;int&gt; q;
  	q.push(1);
  	while (!q.empty()) {
  		int now = q.front();
  		q.pop();
  		if (child[now].size() == 0) {
  			hashtable[level[now]]++;
  			maxlevel = max(maxlevel, level[now]);
  		}
  		for (int i = 0; i &lt; child[now].size(); i++) {
  			level[child[now][i]] = level[now] + 1;
  			q.push(child[now][i]);
  		}
  	}
  }`
</code></pre>
<p>二叉查找树BST</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node{
	int data;
	node* lchild;
	node* rchild;
};
</code></pre>
</li>
<li>
<p>插入</p>
<pre><code>void insert(node*&amp; root, int x) {
	if (root == NULL) {
		root = new node;
		root-&gt;data = x;
		root-&gt;lchild = NULL;
		root-&gt;rchild = NULL;
		return;
	}
	if (x &lt; root-&gt;data) insert(root-&gt;lchild, x);
	else insert(root-&gt;rchild, x);
}
</code></pre>
</li>
<li>
<p>完全二叉查找树</p>
<p>用数组存放完全二叉查找树时，可以先将待插入的权值递增排列，然后用中序遍历的方式将其插入到树中，并且要注意结点序号的关系</p>
<pre><code>void inorder(int root) {
	if (root &gt; n) return;
	inorder(root * 2);
	CBT[root] = number[index++];
	inorder(root * 2 + 1);
}
</code></pre>
</li>
<li>
<p>注意点：对二叉查找树进行中序遍历，其结果是有序的</p>
</li>
</ul>
</li>
<li>
<p>平衡二叉树(AVL)</p>
<p>A1066</p>
<p>任意结点左子树与右子树的高度之差的绝对值不超过1</p>
<p>某结点左子树与右子树的高度之差成为该结点的平衡因子。</p>
<p>在对AVL进行插入操作时，只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡。</p>
<ul>
<li>
<p>存储结构</p>
<pre><code>struct node {
	int data, height;
	node* lchild, * rchild;
};
</code></pre>
</li>
<li>
<p>生成一个新结点</p>
<pre><code>node* newNode(int v) {
	node* Node = new node;
	Node-&gt;v = v;
	Node-&gt;height = 1;
	Node-&gt;lchild = Node-&gt;rchild = NULL;
	return Node;
}
</code></pre>
</li>
<li>
<p>获取结点root所在子树当前高度</p>
<pre><code>int getheight(node* root) {
    if (root == NULL) return 0;
	return root-&gt;height;
}
</code></pre>
</li>
<li>
<p>更新高度</p>
<pre><code>void updateheight(node* root) {
	root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1;
}
</code></pre>
</li>
<li>
<p>计算平衡因子</p>
<pre><code>int getbalancefactor(node* root) {
	return getheight(root-&gt;lchild) - getbalancefactor(root-&gt;rchild);
	//注意是左减右
}
</code></pre>
</li>
<li>
<p>左旋</p>
<pre><code>void L(node*&amp; root) {
	node* temp = root-&gt;rchild;
	root-&gt;rchild = temp-&gt;lchild;
	temp-&gt;lchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>右旋</p>
<pre><code>void R(node*&amp; root) {
	node* temp = root-&gt;lchild;
	root-&gt;lchild = temp-&gt;rchild;
	temp-&gt;rchild = root;
	updateheight(root);
	updateheight(temp);
	root = temp;
}
</code></pre>
</li>
<li>
<p>建树</p>
<pre><code>void insert(node*&amp; root, int v) {
	if (root == NULL) {
		root = newnode(v);
		return;
	}
	if (root-&gt;data &gt; v) {
		insert(root-&gt;lchild, v);
		updateheight(root);
		if (getbalance(root) == 2) {
			if (getbalance(root-&gt;lchild) == 1) {
				R(root);
			}
			else if (getbalance(root-&gt;lchild) == -1) {
				L(root-&gt;lchild);
				R(root);
			}
		}
	}
	else {
		insert(root-&gt;rchild, v);
		updateheight(root);
		if (getbalance(root) == -2) {
			if (getbalance(root-&gt;rchild) == -1) {
				L(root);
			}
			else if (getbalance(root-&gt;rchild) == 1) {
				R(root-&gt;rchild);
				L(root);
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>堆(完全二叉树(大顶堆、小顶堆))，下面以大顶堆为例</p>
<ul>
<li>
<p>向下调整</p>
<pre><code>void downadjust(int low, int high) {
	int i = low, j = 2 * i;
	while (j &lt;= high) {
		if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {
			j = j + 1;
		}
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = 2 * i;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>删除堆顶元素</p>
<pre><code>void deletetop() {
	heap[1] = heap[n--];
	downadjust(1, n);
}
</code></pre>
</li>
<li>
<p>向上调整</p>
<pre><code>void upadjust(int low, int high) {
	int i = high, j = i / 2;
	while (j &gt;= low) {
		if (heap[i] &lt; heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = i / 2;
		}
		else {
			break;
		}
	}
}
</code></pre>
</li>
<li>
<p>插入元素</p>
<pre><code>void insert(int x) {
	heap[++n] = x;
	upadjust(1, n);
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="26-并查集">26 并查集</h3>
<p>A1107 A1114 A1118</p>
<ul>
<li>
<p>找根结点</p>
<pre><code>for(int i=0;i&lt;N;i++){//初始化，千万不要忘了
    father[i]=i;
}
int findfather(int x){//普通版找根节点
    while(x!=father[x]){
    x=father[x];
    }
    return x;
}
int findfather(int v){//路径压缩版找根结点
	if(father[v]==v) return v;
	else{
		int F=findfather(father[v]);
		father[v]=F;//把路径上所有结点的父节点都变为根节点
		return F;
	}
}
</code></pre>
</li>
<li>
<p>合并两个集合</p>
<pre><code>void union(int a,int b){
    int fatherA=findfather(a);
    int fatherB=findfather(b);
    if(fatherA!=fatherB) father[fatherA]=fatherB;
}
</code></pre>
</li>
</ul>
<h3 id="27-图">27 图</h3>
<p>A1013 A1021, A1034 <strong>A1076</strong> A1003 <strong>A1018</strong> A1030 A1072 A1087，A1126(欧拉图)  A1134(图  结点与边的问题)</p>
<p>A1146(判断是否为拓扑排序序列 )    A1154(25 图  边的两端点的判断 )    A1142(25 无向完全图 最大子图  两点相连)</p>
<p>A1150(25 判断循环图 输出最小路径)    A1131(30 DFS 、unordered_map邻接矩阵、 难题  )</p>
<ul>
<li>
<p>存储方式</p>
<p>邻接表或邻接矩阵</p>
<p>G[maxn] [maxn] 或者vector&lt; vector <int> &gt; G 或vector<int> G[maxn] 等等</p>
<pre><code>struct node{
   int id;
   int layer;
}
vector&lt;node&gt; adj[amxn];
</code></pre>
</li>
<li>
<p>深度遍历</p>
<pre><code>void DFS(u) {//访问顶点u所在的连通块
	vis[u] = true;
	......
	for (从u出发能到达的所有顶点v) {
        ......
		if (vis[i] == false) {
			DFS(v);
		}
	}
}
void DFStrave(G) {//遍历图G
	for (G的所有顶点u) {
		if (vis[u] == false) {
			......
			DFS(u);
		    ......
		}
	}
}
</code></pre>
</li>
<li>
<p>广度遍历</p>
<pre><code>BFS(u){
   queue q;
   inq[u]=true;
   while(q非空){
     取出队首元素u进行访问；
     for(从u出发可以到达的所有顶点v){
       if(inq[v]==false){
         将v入队;
       inq[v]=true;
       }
     }
}
BFStrave(G){
   for(G的所有结点u){
      if(inq[u]==false){
         BFS(u);
      }
   }
}
</code></pre>
</li>
<li>
<p>判断是否为连通图的两种方法</p>
<ul>
<li>
<p>深度搜索记录访问结点的数量，如果记录的访问的节点数等于总结点数，则为连通图</p>
<pre><code>void dfs(int index) {
 visit[index] = true;
 cnt++;
 for (int i = 0; i &lt; v[index].size(); i++)
 if (visit[v[index][i]] == false)
 dfs(v[index][i]);
}
</code></pre>
</li>
<li>
<p>深度搜索记录连通块数量</p>
</li>
</ul>
<pre><code>for(int j=1;j&lt;=n;j++){
			if(vis[j]==false){
				DFS(j);
				block++;
			}
		}
</code></pre>
</li>
<li>
<p>最短路径dijkstra</p>
<ul>
<li>
<p>dijkstra函数内首先进行初始化</p>
<p>包括fill(vis,vis+maxn,false);//某个结点是否访问<br>
fill(d,d+maxn,INF);//到某个结点的最短路径<br>
fill(w,w+maxn,0);//到某个结点路径上的总点权(一般为最大值)<br>
fill(pt,pt+maxn,0);//路径上的结点个数<br>
fill(num,num+maxn,0);//最短路径条数，</p>
<p>​     for(int i=0;i&lt;n;i++) pre[i]=i;//每个结点的前驱结点设为其本身</p>
<p>最后在main函数中还有对临接矩阵或临接链表的初始化，即设为INF</p>
</li>
<li>
<p>输出路径</p>
<pre><code>void printpath(int v){
	if(v==0){//到达起始节点，开始输出，并逐层返回
		cout&lt;&lt;inttostring[v];
		return;
	}
	printpath(pre[v]);
	cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;inttostring[v];
}
</code></pre>
</li>
<li>
<p>dijkstra示例代码</p>
<pre><code>void dijkst(int s){
	fill(vis,vis+maxn,false);
	fill(d,d+maxn,INF);
	fill(w,w+maxn,0);
	fill(pt,pt+maxn,0);
	fill(num,num+maxn,0);
    for(int i=0;i&lt;n;i++) pre[i]=i;
	d[s]=0;
	w[s]=weight[s];
	num[s]=1;
	for(int i=0;i&lt;n;i++){
		int u=-1,MIN=INF;
		for(int j=0;j&lt;n;j++){
			if(vis[j]==false&amp;&amp;d[j]&lt;MIN){
				u=j;
				MIN=d[u];
			}
		}
		if(u==-1) return;
		vis[u]=true;
		for(int v=0;v&lt;n;v++){
			if(vis[v]==false&amp;&amp;G[u][v]!=INF){
				if(d[v]&gt;d[u]+G[u][v]){
					d[v]=d[u]+G[u][v];
					w[v]=w[u]+weight[v];	
					num[v]=num[u];
					pt[v]=pt[u]+1;
					pre[v]=u;
				}else if(d[v]==d[u]+G[u][v]){
					num[v]+=num[u];
					if(w[v]&lt;w[u]+weight[v]){
						w[v]=w[u]+weight[v];
						pt[v]=pt[u]+1;
						pre[v]=u;
					}else if(w[v]==weight[v]+w[u]){
						double avgfun1=w[v]*1.0/pt[v];
						double avgfun2=(weight[v]+w[u])*1.0/(pt[u]+1);
						if(avgfun2&gt;avgfun1){
							pt[v]=pt[u]+1;
							pre[v]=u;
						}
					}
				}
			}
		}
	}
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>哈密顿问题</p>
<p>A1122(哈密顿回路 set)</p>
</li>
<li>
<p>笔记</p>
<ul>
<li>
<p>连通的、且边数为N-1的具有N个结点的图一定是棵树。在这N个结点中选择合适的根节点，使树的高度最大的办法是：先任意选择一个结点，从该结点出发遍历整个树，获取能达到的最深的结点(记为集合A)，然后从集合A中任意一个结点出发遍历整个树，获取能达到的最深的结点(记为集合B)，集合A与集合B的并集即为所求的使树的高度最大的根结点。</p>
</li>
<li>
<p>删除图中某个顶点及其相连的边时，不用真的删除，可以在DFS访问到该顶点时返回即可,如下</p>
<pre><code>void DFS(int v){
	if(v==deletepoint) return;//访问到删除的结点时返回
	vis[v]=true;
	for(int i=0;i&lt;G[v].size();i++){
		if(vis[G[v][i]]==false){
			DFS(G[v][i]);
		}
	}
}
</code></pre>
</li>
<li>
<p>结点标号为字符串时，可以用map进行和数字间的转化</p>
</li>
<li>
<p>对于每个结点只能访问一次的情况，可以优先考虑BFS(A1076)</p>
</li>
<li>
<p>不论是DFS、BFS、djkst都要先初始化传入参数(即起始结点)的相关信息</p>
</li>
</ul>
</li>
</ul>
<h3 id="28-动态规划">28 动态规划</h3>
<ul>
<li>
<p>最大连续子序列和  A1007</p>
<p>状态转移方程:<code>dp[i]=max{a[i],dp[i-1]+a[i]}</code></p>
<p>注意边界初始条件</p>
<pre><code>#include&lt;cstdio&gt;
const int maxn=10010;
int a[maxn],dp[maxn],s[maxn]={0};//s数组记录最大连续子序列的起始元素
int main(){
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	bool flag=false;
	for(int i=0;i&lt;n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
		if(a[i]&gt;=0) flag=true;
	}
	if(flag==false){
		printf(&quot;0 %d %d&quot;,a[0],a[n-1]);
		return 0;
	}
    dp[0]=a[0];//边界初始条件--------------------------------------------------------
	for(int i=1;i&lt;n;i++){
		if(a[i]&gt;dp[i-1]+a[i]){
			dp[i]=a[i];
			s[i]=i;
		} 
		else {
			dp[i]=dp[i-1]+a[i];
			s[i]=s[i-1];
		}
	}
	int k=0;
	for(int i=1;i&lt;n;i++){
		if(dp[i]&gt;dp[k]){//题目要求输出i，j最小的序列，所以这里的判断是&gt;而不是&gt;=
			k=i;
		}
	}
	printf(&quot;%d %d %d&quot;,dp[k],a[s[k]],a[k]);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长不下降子序列 (LIS) A1045</p>
<p>状态转移方程:<code>dp[i]=max{1,dp[j]+1}</code></p>
<p>如果存在a[i]之前的元素a[j] (j&lt;i)，使得a[j]&lt;=a[i]并且dp[j]+1&gt;dp[i],那么就把a[i]跟在以a[j]为结尾的LIS后面，形成一条更长的不下降子序列(令dp[i]=dp[j]+1)</p>
<p>如果a[i]之前的元素都比a[i]大，那么a[i]就只好自己形成一条LIS，长度为1</p>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int hashtable[maxn],a[maxn],dp[maxn];
int main(){
	int num=0,ans=-1,n,m,L,temp;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
	fill(hashtable,hashtable+maxn,-1);
	for(int i=0;i&lt;m;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		hashtable[temp]=i;
	}
	scanf(&quot;%d&quot;,&amp;L);
	for(int i=0;i&lt;L;i++){
		scanf(&quot;%d&quot;,&amp;temp);
		if(hashtable[temp]&gt;=0){
			a[num++]=hashtable[temp];
		}
	}
	for(int i=0;i&lt;num;i++){
		dp[i]=1;//边界初始条件--------------------------------------
		for(int j=0;j&lt;i;j++){
			if(a[i]&gt;=a[j]&amp;&amp;dp[j]+1&gt;dp[i]){
				dp[i]=dp[j]+1;
			}
		}
  	ans=max(ans,dp[i]);
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长公共子序列 A1045</p>
<ul>
<li>经典LCS模型，两个序列的元素匹配必须一一对应：</li>
</ul>
<p>​      状态转移方程:如果a[i]==b[j],<code>dp[i] [j]=dp[i-1] [j-1]+1</code>,</p>
<p>​      如果a[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
<ul>
<li>
<p>本题中允许公共部分产生重复元素</p>
<p>状态转移方程修改为:</p>
<p>如果a[i]==b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}+1</code></p>
<p>如果a[i]!=b[j],<code>dp[i] [j]=max{dp[i-1] [j],dp[i] [j-1]}</code></p>
</li>
</ul>
<pre><code>#include&lt;cstdio&gt; 
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
int a[maxn],b[maxn],dp[maxn][maxn];
int main(){
	int n,m,L;
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    scanf(&quot;%d&quot;,&amp;L);
    for(int i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for(int i=0;i&lt;m;i++) dp[i][0]=0;//边界起始条件
    for(int i=0;i&lt;L;i++) dp[0][i]=0;//边界起始条件
    for(int i=1;i&lt;=m;i++){
    	for(int j=1;j&lt;=L;j++){
    		int maxone=max(dp[i-1][j],dp[i][j-1]);
    		if(a[i]==b[j]) dp[i][j]=maxone+1;                   
    		else dp[i][j]=maxone;
		}
	}
	printf(&quot;%d&quot;,dp[m][L]);
	return 0;
}
</code></pre>
</li>
<li>
<p>最长回文子串 A1040</p>
<p>dp[i] [j]表示s[i]至s[j]表示的子串是否为回文子串</p>
<p>状态转移方程: 如果s[i]==s[j],<code>dp[i] [j]=dp[i+1] [j-1]</code></p>
<p>如果s[i]!=s[j], <code>dp[i] [j]=0</code></p>
</li>
</ul>
<p>​       边界：<code>dp[i] [i] =1;dp[i] [i+1]=(s[i]==s[i+1])? 1 : 0</code></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int maxn=1010;
string str;
int dp[maxn][maxn];
int main(){
	memset(dp,0,sizeof(dp));
	getline(cin,str);
	int ans=1,len=str.length();
	for(int i=0;i&lt;len;i++){//边界初始化
		dp[i][i]=1;
		if(i&lt;len-1){
			if(str[i]==str[i+1]){
				dp[i][i+1]=1;
				ans=2;//初始化时注意最长回文子串的长度
			}
		}
	}
	for(int L=3;L&lt;=len;L++){
		for(int i=0;i+L-1&lt;len;i++){
			int j=i+L-1;
			if(str[i]==str[j]&amp;&amp;dp[i+1][j-1]==1){
				dp[i][j]=1;
				ans=L;
			}
		}
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<ul>
<li>
<p>背包问题</p>
<ul>
<li>
<p>01背包 A1068</p>
<p>dp[i] [v]=max{dp[i-1] [v],dp[i-1] [v-w[i]]+c[i]}(1&lt;=i&lt;=n, w[i]&lt;=v&lt;=V)</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
const int maxv=110;
int dp[maxv]={0},w[maxn];
bool choice[maxn][maxv],flag[maxn];
bool cmp(int a,int b){
	return a&gt;b;
}
int main(){
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w[i]);
	}
	sort(w+1,w+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		for(int v=m;v&gt;=w[i];v--){
			if(dp[v]&lt;=dp[v-w[i]]+w[i]){
				dp[v]=dp[v-w[i]]+w[i];
				choice[i][v]=1;
			}else{
				choice[i][v]=0;
			}
		}
	}
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int k=n,num=0,v=m;
		while(k&gt;=0){
			if(choice[k][v]==1){
				flag[k]=true;
				v-=w[k];
				num++;
			}else flag[k]=false;
			k--;
		}
		for(int i=n;i&gt;0;i--){
			if(flag[i]==true){
				printf(&quot;%d&quot;,w[i]);
				num--;
				if(num&gt;0) printf(&quot; &quot;);
			}
		}
	}
	return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="29-分块-实时查询问题">29 分块  (实时查询问题)</h3>
<p>A1057</p>
<p>某非负整数序列元素的取值范围为0到N，则每块中元素个数是根号N(向下取整)，块数是根号N(向上取整)</p>
<p>例如所有元素都不超过100000，则可以将序列分为317块，每块316个元素，并用table[]数组记录每个元素出现的次数，用block[]数组记录每块中的元素个数</p>
<h3 id="30-树状数组bit-实时查询">30 树状数组(BIT) (实时查询)</h3>
<p><code>#define lowbit(i) ((i) &amp; (-i))</code></p>
<p>C[i]的覆盖长度是<code>lowbit(i)</code>,树状数组的下标必须从1开始</p>
<pre><code>int getsum(int x)//返回前x个整数之和{
   int sum=0;
   for(int i=x;i&gt;0;i-=lowbit(i)){
      sum+=c[i];
   }
   return sum;
}
</code></pre>
<pre><code>void update(int x,int v){
   for(int i=x;i&lt;=N;i+=lowbit(i)){
      c[i]+=v;
   }
}
</code></pre>
<h3 id="31-可怕模拟">31 可怕模拟</h3>
<p>A1017(25 )   A1153( 25 模拟 排序引用传参 vector unordered_map)</p>
<p>A1014(30 模拟  难题)</p>
<h3 id="32-n皇后">32 n皇后</h3>
<p>A1128(20)</p>
<h1 id="注意">注意</h1>
<p>1.= 与 ==</p>
<p>2.变量初始化赋值时有时必须赋值为0或1</p>
<p>3.注意全局变量与局部变量</p>
<p>4.<code>s1[i]-'0'</code>，字符数组变为整型数字</p>
<p>5.<code>s1[i]&gt;='0' &amp;&amp; s1[1]&lt;='9'</code>，字符数组中寻找0到9之间的数字</p>
<p>6.注意输出结果为0时的特殊情况，隐藏的测试点等</p>
<p>7.段错误很可能是数组越界，可能是定义的数组长度不符合题目限制的最大范围</p>
<p>8.注意if 和else if 的搭配使用， 注意函数传入值node* root ，下面对应root=new node,而不是node*root=new node,输出格式<code>printf(&quot;\n&quot;)</code>,<code>printf(&quot; &quot;)</code>是否正确</p>
<p>9.如果想要在 Dev-Cpp ⾥⾯使⽤C++11, 在菜单栏中⼯具-编译选项-编译器-编译时加⼊ -std=c++11 这句命令即可</p>
<p>11.有时并不一定真的要实现出正确的算法，最后不管用什么方式，只要能输出正确的格式就好</p>
<p>12.注意设置bool型的变量用于判断</p>
<p>13.注意输入的例子中可能有无效的数据，要找出有效的数据进行处理</p>
<p>14.<code>cmp</code>中写按字母大小排序，注意写成<code>strcmp()&lt;0</code>......的形式</p>
<p>15.看题目中的数据是整数还是浮点数，注意题目中数据的保留位数</p>
<p>16.注意是使用while还是if，不要忘了break或continue，注意区分是用break还是continue</p>
<p>17.<code>long long k=(long long)p*num[i]</code>;    若新声明的变量为long long 型，右边为int乘int型，最好在右边带上强制转换(long long)，其他情况也这样吧....</p>
<p>18.注意是多个if并列 还是if与else if结合使用</p>
<p>19.int上限为<code>0x7fffffff</code>, 即2^31 -1,可以用<code>const int INF=0x7fffffff</code>,也可以写成<code>(1&lt;&lt;31)-1</code></p>
<p>​     int下限为-2^31。const double eps=1e-8(即10的-8次方，注意是数字1不是字母l)，const double     INF=1e12(即10^12)</p>
<p>20.字符数组变为数字时要注意减'0',<code>res.d[i] = str[res.len - 1 - i]-'0'</code></p>
<p>21.函数的参数前有时需要加引用&amp;</p>
<p>22.操作放在花括号内还是花括号外，注意条件的判断</p>
<p>23.注意DFS的下一层进行DFS时，要写DFS(i,height+1)  不要写height++</p>
<p>24.涉及到排序问题时，可以考虑使用set或map内部自动排序的容器，也可以先把题目中给出的数据先排序再处理</p>
<p>25.提交时出现“运行时发生错误”的情况，一般是开的数组太小，没有达到题目要求的最大值</p>
<p>26.不要忘了一些算法的初始化，比如使用并查集千万不要忘了初始化<code>father[i]=i</code></p>
<p>27一些题目处理的是五位数的格式，(比如id号)，所以输出时注意<code>printf(&quot;%05d&quot;)</code></p>
<p>28.四舍五入为整数<code>int(v[temp].gm * 0.4 + v[temp].gf * 0.6 + 0.5);</code></p>
<p>​      在最后加上0.5并强制转换为int型</p>
<p>29.A1139邻接矩阵的巧妙写法</p>
<pre><code>unordered_map&lt;int ,bool&gt; isfri;
isfri[abs(stoi(a))*10000+abs(stoi(b))]=isfri[abs(stoi(b))*10000+abs(stoi(a))]=true;
10000为超过最大范围的整数
</code></pre>

              </div>
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      lxb&#39;blog
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://liuxbo.github.io/post/cshua-ti-bi-ji/" title="c++刷题笔记">c++刷题笔记</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://liuxbo.github.io/tag/ebIooEyCk/"># c++</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="PAT题解" href="https://liuxbo.github.io/post/pat-ti-jie/">PAT题解</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="PAT题解" href="https://liuxbo.github.io/post/pat-ti-jie/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Hello Gridea" href="https://liuxbo.github.io/post/hello-gridea/">Hello Gridea</a>
        <a class="nav-mobile-next" title="Hello Gridea" href="https://liuxbo.github.io/post/hello-gridea/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
              
            </div>
          </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      © 2019-2020 <i class="fa fa-heart"></i> HsxyHao
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    </div>
  </body>
  <script src="/media/js/motion.js"></script>
</html>